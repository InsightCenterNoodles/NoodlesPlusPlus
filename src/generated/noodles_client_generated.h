// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOODLESCLIENT_NOODLES_H_
#define FLATBUFFERS_GENERATED_NOODLESCLIENT_NOODLES_H_

#include "flatbuffers/flatbuffers.h"

#include "noodles_generated.h"

namespace noodles {

struct IntroductionMessage;
struct IntroductionMessageBuilder;

struct MethodInvokeMessage;
struct MethodInvokeMessageBuilder;

struct AssetRefreshMessage;
struct AssetRefreshMessageBuilder;

struct ClientMessage;
struct ClientMessageBuilder;

struct ClientMessages;
struct ClientMessagesBuilder;

inline const flatbuffers::TypeTable *IntroductionMessageTypeTable();

inline const flatbuffers::TypeTable *MethodInvokeMessageTypeTable();

inline const flatbuffers::TypeTable *AssetRefreshMessageTypeTable();

inline const flatbuffers::TypeTable *ClientMessageTypeTable();

inline const flatbuffers::TypeTable *ClientMessagesTypeTable();

enum class ClientMessageType : uint8_t {
  NONE = 0,
  IntroductionMessage = 1,
  MethodInvokeMessage = 2,
  AssetRefreshMessage = 3,
  MIN = NONE,
  MAX = AssetRefreshMessage
};

inline const ClientMessageType (&EnumValuesClientMessageType())[4] {
  static const ClientMessageType values[] = {
    ClientMessageType::NONE,
    ClientMessageType::IntroductionMessage,
    ClientMessageType::MethodInvokeMessage,
    ClientMessageType::AssetRefreshMessage
  };
  return values;
}

inline const char * const *EnumNamesClientMessageType() {
  static const char * const names[5] = {
    "NONE",
    "IntroductionMessage",
    "MethodInvokeMessage",
    "AssetRefreshMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameClientMessageType(ClientMessageType e) {
  if (flatbuffers::IsOutRange(e, ClientMessageType::NONE, ClientMessageType::AssetRefreshMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClientMessageType()[index];
}

template<typename T> struct ClientMessageTypeTraits {
  static const ClientMessageType enum_value = ClientMessageType::NONE;
};

template<> struct ClientMessageTypeTraits<noodles::IntroductionMessage> {
  static const ClientMessageType enum_value = ClientMessageType::IntroductionMessage;
};

template<> struct ClientMessageTypeTraits<noodles::MethodInvokeMessage> {
  static const ClientMessageType enum_value = ClientMessageType::MethodInvokeMessage;
};

template<> struct ClientMessageTypeTraits<noodles::AssetRefreshMessage> {
  static const ClientMessageType enum_value = ClientMessageType::AssetRefreshMessage;
};

bool VerifyClientMessageType(flatbuffers::Verifier &verifier, const void *obj, ClientMessageType type);
bool VerifyClientMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct IntroductionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntroductionMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntroductionMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_NAME = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *client_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_NAME);
  }
  flatbuffers::String *mutable_client_name() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_NAME);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENT_NAME) &&
           verifier.VerifyString(client_name()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct IntroductionMessageBuilder {
  typedef IntroductionMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_client_name(flatbuffers::Offset<flatbuffers::String> client_name) {
    fbb_.AddOffset(IntroductionMessage::VT_CLIENT_NAME, client_name);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(IntroductionMessage::VT_VERSION, version, 0);
  }
  explicit IntroductionMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntroductionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntroductionMessage>(end);
    fbb_.Required(o, IntroductionMessage::VT_CLIENT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<IntroductionMessage> CreateIntroductionMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> client_name = 0,
    uint32_t version = 0) {
  IntroductionMessageBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_client_name(client_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntroductionMessage> CreateIntroductionMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_name = nullptr,
    uint32_t version = 0) {
  auto client_name__ = client_name ? _fbb.CreateString(client_name) : 0;
  return noodles::CreateIntroductionMessage(
      _fbb,
      client_name__,
      version);
}

struct MethodInvokeMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodInvokeMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodInvokeMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_ID = 4,
    VT_ON_OBJECT = 6,
    VT_ON_TABLE = 8,
    VT_ON_PLOT = 10,
    VT_INVOKE_IDENT = 12,
    VT_METHOD_ARGS = 14
  };
  const noodles::MethodID *method_id() const {
    return GetPointer<const noodles::MethodID *>(VT_METHOD_ID);
  }
  noodles::MethodID *mutable_method_id() {
    return GetPointer<noodles::MethodID *>(VT_METHOD_ID);
  }
  const noodles::ObjectID *on_object() const {
    return GetPointer<const noodles::ObjectID *>(VT_ON_OBJECT);
  }
  noodles::ObjectID *mutable_on_object() {
    return GetPointer<noodles::ObjectID *>(VT_ON_OBJECT);
  }
  const noodles::TableID *on_table() const {
    return GetPointer<const noodles::TableID *>(VT_ON_TABLE);
  }
  noodles::TableID *mutable_on_table() {
    return GetPointer<noodles::TableID *>(VT_ON_TABLE);
  }
  const noodles::PlotID *on_plot() const {
    return GetPointer<const noodles::PlotID *>(VT_ON_PLOT);
  }
  noodles::PlotID *mutable_on_plot() {
    return GetPointer<noodles::PlotID *>(VT_ON_PLOT);
  }
  const flatbuffers::String *invoke_ident() const {
    return GetPointer<const flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  flatbuffers::String *mutable_invoke_ident() {
    return GetPointer<flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  const noodles::AnyList *method_args() const {
    return GetPointer<const noodles::AnyList *>(VT_METHOD_ARGS);
  }
  noodles::AnyList *mutable_method_args() {
    return GetPointer<noodles::AnyList *>(VT_METHOD_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_METHOD_ID) &&
           verifier.VerifyTable(method_id()) &&
           VerifyOffset(verifier, VT_ON_OBJECT) &&
           verifier.VerifyTable(on_object()) &&
           VerifyOffset(verifier, VT_ON_TABLE) &&
           verifier.VerifyTable(on_table()) &&
           VerifyOffset(verifier, VT_ON_PLOT) &&
           verifier.VerifyTable(on_plot()) &&
           VerifyOffsetRequired(verifier, VT_INVOKE_IDENT) &&
           verifier.VerifyString(invoke_ident()) &&
           VerifyOffset(verifier, VT_METHOD_ARGS) &&
           verifier.VerifyTable(method_args()) &&
           verifier.EndTable();
  }
};

struct MethodInvokeMessageBuilder {
  typedef MethodInvokeMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method_id(flatbuffers::Offset<noodles::MethodID> method_id) {
    fbb_.AddOffset(MethodInvokeMessage::VT_METHOD_ID, method_id);
  }
  void add_on_object(flatbuffers::Offset<noodles::ObjectID> on_object) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_OBJECT, on_object);
  }
  void add_on_table(flatbuffers::Offset<noodles::TableID> on_table) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_TABLE, on_table);
  }
  void add_on_plot(flatbuffers::Offset<noodles::PlotID> on_plot) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_PLOT, on_plot);
  }
  void add_invoke_ident(flatbuffers::Offset<flatbuffers::String> invoke_ident) {
    fbb_.AddOffset(MethodInvokeMessage::VT_INVOKE_IDENT, invoke_ident);
  }
  void add_method_args(flatbuffers::Offset<noodles::AnyList> method_args) {
    fbb_.AddOffset(MethodInvokeMessage::VT_METHOD_ARGS, method_args);
  }
  explicit MethodInvokeMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodInvokeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodInvokeMessage>(end);
    fbb_.Required(o, MethodInvokeMessage::VT_METHOD_ID);
    fbb_.Required(o, MethodInvokeMessage::VT_INVOKE_IDENT);
    return o;
  }
};

inline flatbuffers::Offset<MethodInvokeMessage> CreateMethodInvokeMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> method_id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    flatbuffers::Offset<flatbuffers::String> invoke_ident = 0,
    flatbuffers::Offset<noodles::AnyList> method_args = 0) {
  MethodInvokeMessageBuilder builder_(_fbb);
  builder_.add_method_args(method_args);
  builder_.add_invoke_ident(invoke_ident);
  builder_.add_on_plot(on_plot);
  builder_.add_on_table(on_table);
  builder_.add_on_object(on_object);
  builder_.add_method_id(method_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodInvokeMessage> CreateMethodInvokeMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> method_id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    const char *invoke_ident = nullptr,
    flatbuffers::Offset<noodles::AnyList> method_args = 0) {
  auto invoke_ident__ = invoke_ident ? _fbb.CreateString(invoke_ident) : 0;
  return noodles::CreateMethodInvokeMessage(
      _fbb,
      method_id,
      on_object,
      on_table,
      on_plot,
      invoke_ident__,
      method_args);
}

struct AssetRefreshMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetRefreshMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssetRefreshMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOR_BUFFERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *for_buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *>(VT_FOR_BUFFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *mutable_for_buffers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *>(VT_FOR_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FOR_BUFFERS) &&
           verifier.VerifyVector(for_buffers()) &&
           verifier.VerifyVectorOfTables(for_buffers()) &&
           verifier.EndTable();
  }
};

struct AssetRefreshMessageBuilder {
  typedef AssetRefreshMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_for_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>>> for_buffers) {
    fbb_.AddOffset(AssetRefreshMessage::VT_FOR_BUFFERS, for_buffers);
  }
  explicit AssetRefreshMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssetRefreshMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetRefreshMessage>(end);
    fbb_.Required(o, AssetRefreshMessage::VT_FOR_BUFFERS);
    return o;
  }
};

inline flatbuffers::Offset<AssetRefreshMessage> CreateAssetRefreshMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>>> for_buffers = 0) {
  AssetRefreshMessageBuilder builder_(_fbb);
  builder_.add_for_buffers(for_buffers);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetRefreshMessage> CreateAssetRefreshMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::BufferID>> *for_buffers = nullptr) {
  auto for_buffers__ = for_buffers ? _fbb.CreateVector<flatbuffers::Offset<noodles::BufferID>>(*for_buffers) : 0;
  return noodles::CreateAssetRefreshMessage(
      _fbb,
      for_buffers__);
}

struct ClientMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClientMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  noodles::ClientMessageType content_type() const {
    return static_cast<noodles::ClientMessageType>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const noodles::IntroductionMessage *content_as_IntroductionMessage() const {
    return content_type() == noodles::ClientMessageType::IntroductionMessage ? static_cast<const noodles::IntroductionMessage *>(content()) : nullptr;
  }
  const noodles::MethodInvokeMessage *content_as_MethodInvokeMessage() const {
    return content_type() == noodles::ClientMessageType::MethodInvokeMessage ? static_cast<const noodles::MethodInvokeMessage *>(content()) : nullptr;
  }
  const noodles::AssetRefreshMessage *content_as_AssetRefreshMessage() const {
    return content_type() == noodles::ClientMessageType::AssetRefreshMessage ? static_cast<const noodles::AssetRefreshMessage *>(content()) : nullptr;
  }
  void *mutable_content() {
    return GetPointer<void *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           VerifyClientMessageType(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::IntroductionMessage *ClientMessage::content_as<noodles::IntroductionMessage>() const {
  return content_as_IntroductionMessage();
}

template<> inline const noodles::MethodInvokeMessage *ClientMessage::content_as<noodles::MethodInvokeMessage>() const {
  return content_as_MethodInvokeMessage();
}

template<> inline const noodles::AssetRefreshMessage *ClientMessage::content_as<noodles::AssetRefreshMessage>() const {
  return content_as_AssetRefreshMessage();
}

struct ClientMessageBuilder {
  typedef ClientMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content_type(noodles::ClientMessageType content_type) {
    fbb_.AddElement<uint8_t>(ClientMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(ClientMessage::VT_CONTENT, content);
  }
  explicit ClientMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientMessage>(end);
    fbb_.Required(o, ClientMessage::VT_CONTENT);
    return o;
  }
};

inline flatbuffers::Offset<ClientMessage> CreateClientMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::ClientMessageType content_type = noodles::ClientMessageType::NONE,
    flatbuffers::Offset<void> content = 0) {
  ClientMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct ClientMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientMessagesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClientMessagesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ClientMessagesBuilder {
  typedef ClientMessages Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>>> messages) {
    fbb_.AddOffset(ClientMessages::VT_MESSAGES, messages);
  }
  explicit ClientMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientMessages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientMessages>(end);
    fbb_.Required(o, ClientMessages::VT_MESSAGES);
    return o;
  }
};

inline flatbuffers::Offset<ClientMessages> CreateClientMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>>> messages = 0) {
  ClientMessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientMessages> CreateClientMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::ClientMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<noodles::ClientMessage>>(*messages) : 0;
  return noodles::CreateClientMessages(
      _fbb,
      messages__);
}

inline bool VerifyClientMessageType(flatbuffers::Verifier &verifier, const void *obj, ClientMessageType type) {
  switch (type) {
    case ClientMessageType::NONE: {
      return true;
    }
    case ClientMessageType::IntroductionMessage: {
      auto ptr = reinterpret_cast<const noodles::IntroductionMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientMessageType::MethodInvokeMessage: {
      auto ptr = reinterpret_cast<const noodles::MethodInvokeMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientMessageType::AssetRefreshMessage: {
      auto ptr = reinterpret_cast<const noodles::AssetRefreshMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyClientMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClientMessageType(
        verifier,  values->Get(i), types->GetEnum<ClientMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *ClientMessageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::IntroductionMessageTypeTable,
    noodles::MethodInvokeMessageTypeTable,
    noodles::AssetRefreshMessageTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "IntroductionMessage",
    "MethodInvokeMessage",
    "AssetRefreshMessage"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntroductionMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "client_name",
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodInvokeMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::AnyListTypeTable
  };
  static const char * const names[] = {
    "method_id",
    "on_object",
    "on_table",
    "on_plot",
    "invoke_ident",
    "method_args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssetRefreshMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "for_buffers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClientMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ClientMessageTypeTypeTable
  };
  static const char * const names[] = {
    "content_type",
    "content"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClientMessagesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ClientMessageTypeTable
  };
  static const char * const names[] = {
    "messages"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const noodles::ClientMessages *GetClientMessages(const void *buf) {
  return flatbuffers::GetRoot<noodles::ClientMessages>(buf);
}

inline const noodles::ClientMessages *GetSizePrefixedClientMessages(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<noodles::ClientMessages>(buf);
}

inline ClientMessages *GetMutableClientMessages(void *buf) {
  return flatbuffers::GetMutableRoot<ClientMessages>(buf);
}

inline bool VerifyClientMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<noodles::ClientMessages>(nullptr);
}

inline bool VerifySizePrefixedClientMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<noodles::ClientMessages>(nullptr);
}

inline void FinishClientMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ClientMessages> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ClientMessages> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace noodles

#endif  // FLATBUFFERS_GENERATED_NOODLESCLIENT_NOODLES_H_
