// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_
#define FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_

#include "flatbuffers/flatbuffers.h"

namespace noodles {

struct ObjectID;
struct ObjectIDBuilder;

struct TableID;
struct TableIDBuilder;

struct SignalID;
struct SignalIDBuilder;

struct MethodID;
struct MethodIDBuilder;

struct MaterialID;
struct MaterialIDBuilder;

struct GeometryID;
struct GeometryIDBuilder;

struct LightID;
struct LightIDBuilder;

struct TextureID;
struct TextureIDBuilder;

struct BufferID;
struct BufferIDBuilder;

struct AnyID;
struct AnyIDBuilder;

struct MapEntry;
struct MapEntryBuilder;

struct Text;
struct TextBuilder;

struct Integer;
struct IntegerBuilder;

struct IntegerList;
struct IntegerListBuilder;

struct Real;
struct RealBuilder;

struct RealList;
struct RealListBuilder;

struct Data;
struct DataBuilder;

struct AnyList;
struct AnyListBuilder;

struct AnyMap;
struct AnyMapBuilder;

struct Any;
struct AnyBuilder;

struct Vec2;

struct Vec3;

struct Vec4;

struct Mat4;

struct BufferRef;
struct BufferRefBuilder;

inline const flatbuffers::TypeTable *ObjectIDTypeTable();

inline const flatbuffers::TypeTable *TableIDTypeTable();

inline const flatbuffers::TypeTable *SignalIDTypeTable();

inline const flatbuffers::TypeTable *MethodIDTypeTable();

inline const flatbuffers::TypeTable *MaterialIDTypeTable();

inline const flatbuffers::TypeTable *GeometryIDTypeTable();

inline const flatbuffers::TypeTable *LightIDTypeTable();

inline const flatbuffers::TypeTable *TextureIDTypeTable();

inline const flatbuffers::TypeTable *BufferIDTypeTable();

inline const flatbuffers::TypeTable *AnyIDTypeTable();

inline const flatbuffers::TypeTable *MapEntryTypeTable();

inline const flatbuffers::TypeTable *TextTypeTable();

inline const flatbuffers::TypeTable *IntegerTypeTable();

inline const flatbuffers::TypeTable *IntegerListTypeTable();

inline const flatbuffers::TypeTable *RealTypeTable();

inline const flatbuffers::TypeTable *RealListTypeTable();

inline const flatbuffers::TypeTable *DataTypeTable();

inline const flatbuffers::TypeTable *AnyListTypeTable();

inline const flatbuffers::TypeTable *AnyMapTypeTable();

inline const flatbuffers::TypeTable *AnyTypeTable();

inline const flatbuffers::TypeTable *Vec2TypeTable();

inline const flatbuffers::TypeTable *Vec3TypeTable();

inline const flatbuffers::TypeTable *Vec4TypeTable();

inline const flatbuffers::TypeTable *Mat4TypeTable();

inline const flatbuffers::TypeTable *BufferRefTypeTable();

enum class AnyIDType : uint8_t {
  NONE = 0,
  ObjectID = 1,
  TableID = 2,
  SignalID = 3,
  MethodID = 4,
  MaterialID = 5,
  GeometryID = 6,
  LightID = 7,
  TextureID = 8,
  BufferID = 9,
  MIN = NONE,
  MAX = BufferID
};

inline const AnyIDType (&EnumValuesAnyIDType())[10] {
  static const AnyIDType values[] = {
    AnyIDType::NONE,
    AnyIDType::ObjectID,
    AnyIDType::TableID,
    AnyIDType::SignalID,
    AnyIDType::MethodID,
    AnyIDType::MaterialID,
    AnyIDType::GeometryID,
    AnyIDType::LightID,
    AnyIDType::TextureID,
    AnyIDType::BufferID
  };
  return values;
}

inline const char * const *EnumNamesAnyIDType() {
  static const char * const names[11] = {
    "NONE",
    "ObjectID",
    "TableID",
    "SignalID",
    "MethodID",
    "MaterialID",
    "GeometryID",
    "LightID",
    "TextureID",
    "BufferID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyIDType(AnyIDType e) {
  if (flatbuffers::IsOutRange(e, AnyIDType::NONE, AnyIDType::BufferID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyIDType()[index];
}

template<typename T> struct AnyIDTypeTraits {
  static const AnyIDType enum_value = AnyIDType::NONE;
};

template<> struct AnyIDTypeTraits<noodles::ObjectID> {
  static const AnyIDType enum_value = AnyIDType::ObjectID;
};

template<> struct AnyIDTypeTraits<noodles::TableID> {
  static const AnyIDType enum_value = AnyIDType::TableID;
};

template<> struct AnyIDTypeTraits<noodles::SignalID> {
  static const AnyIDType enum_value = AnyIDType::SignalID;
};

template<> struct AnyIDTypeTraits<noodles::MethodID> {
  static const AnyIDType enum_value = AnyIDType::MethodID;
};

template<> struct AnyIDTypeTraits<noodles::MaterialID> {
  static const AnyIDType enum_value = AnyIDType::MaterialID;
};

template<> struct AnyIDTypeTraits<noodles::GeometryID> {
  static const AnyIDType enum_value = AnyIDType::GeometryID;
};

template<> struct AnyIDTypeTraits<noodles::LightID> {
  static const AnyIDType enum_value = AnyIDType::LightID;
};

template<> struct AnyIDTypeTraits<noodles::TextureID> {
  static const AnyIDType enum_value = AnyIDType::TextureID;
};

template<> struct AnyIDTypeTraits<noodles::BufferID> {
  static const AnyIDType enum_value = AnyIDType::BufferID;
};

bool VerifyAnyIDType(flatbuffers::Verifier &verifier, const void *obj, AnyIDType type);
bool VerifyAnyIDTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AnyType : uint8_t {
  NONE = 0,
  Text = 1,
  Integer = 2,
  IntegerList = 3,
  Real = 4,
  RealList = 5,
  Data = 6,
  AnyList = 7,
  AnyMap = 8,
  AnyID = 9,
  MIN = NONE,
  MAX = AnyID
};

inline const AnyType (&EnumValuesAnyType())[10] {
  static const AnyType values[] = {
    AnyType::NONE,
    AnyType::Text,
    AnyType::Integer,
    AnyType::IntegerList,
    AnyType::Real,
    AnyType::RealList,
    AnyType::Data,
    AnyType::AnyList,
    AnyType::AnyMap,
    AnyType::AnyID
  };
  return values;
}

inline const char * const *EnumNamesAnyType() {
  static const char * const names[11] = {
    "NONE",
    "Text",
    "Integer",
    "IntegerList",
    "Real",
    "RealList",
    "Data",
    "AnyList",
    "AnyMap",
    "AnyID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyType(AnyType e) {
  if (flatbuffers::IsOutRange(e, AnyType::NONE, AnyType::AnyID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyType()[index];
}

template<typename T> struct AnyTypeTraits {
  static const AnyType enum_value = AnyType::NONE;
};

template<> struct AnyTypeTraits<noodles::Text> {
  static const AnyType enum_value = AnyType::Text;
};

template<> struct AnyTypeTraits<noodles::Integer> {
  static const AnyType enum_value = AnyType::Integer;
};

template<> struct AnyTypeTraits<noodles::IntegerList> {
  static const AnyType enum_value = AnyType::IntegerList;
};

template<> struct AnyTypeTraits<noodles::Real> {
  static const AnyType enum_value = AnyType::Real;
};

template<> struct AnyTypeTraits<noodles::RealList> {
  static const AnyType enum_value = AnyType::RealList;
};

template<> struct AnyTypeTraits<noodles::Data> {
  static const AnyType enum_value = AnyType::Data;
};

template<> struct AnyTypeTraits<noodles::AnyList> {
  static const AnyType enum_value = AnyType::AnyList;
};

template<> struct AnyTypeTraits<noodles::AnyMap> {
  static const AnyType enum_value = AnyType::AnyMap;
};

template<> struct AnyTypeTraits<noodles::AnyID> {
  static const AnyType enum_value = AnyType::AnyID;
};

bool VerifyAnyType(flatbuffers::Verifier &verifier, const void *obj, AnyType type);
bool VerifyAnyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2TypeTable();
  }
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec3TypeTable();
  }
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec4TypeTable();
  }
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  noodles::Vec4 c1_;
  noodles::Vec4 c2_;
  noodles::Vec4 c3_;
  noodles::Vec4 c4_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Mat4TypeTable();
  }
  Mat4() {
    memset(static_cast<void *>(this), 0, sizeof(Mat4));
  }
  Mat4(const noodles::Vec4 &_c1, const noodles::Vec4 &_c2, const noodles::Vec4 &_c3, const noodles::Vec4 &_c4)
      : c1_(_c1),
        c2_(_c2),
        c3_(_c3),
        c4_(_c4) {
  }
  const noodles::Vec4 &c1() const {
    return c1_;
  }
  noodles::Vec4 &mutable_c1() {
    return c1_;
  }
  const noodles::Vec4 &c2() const {
    return c2_;
  }
  noodles::Vec4 &mutable_c2() {
    return c2_;
  }
  const noodles::Vec4 &c3() const {
    return c3_;
  }
  noodles::Vec4 &mutable_c3() {
    return c3_;
  }
  const noodles::Vec4 &c4() const {
    return c4_;
  }
  noodles::Vec4 &mutable_c4() {
    return c4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4, 64);

struct ObjectID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct ObjectIDBuilder {
  typedef ObjectID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(ObjectID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(ObjectID::VT_ID_GEN, id_gen, 0);
  }
  explicit ObjectIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectIDBuilder &operator=(const ObjectIDBuilder &);
  flatbuffers::Offset<ObjectID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectID>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectID> CreateObjectID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  ObjectIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct TableID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct TableIDBuilder {
  typedef TableID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(TableID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(TableID::VT_ID_GEN, id_gen, 0);
  }
  explicit TableIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableIDBuilder &operator=(const TableIDBuilder &);
  flatbuffers::Offset<TableID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableID>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableID> CreateTableID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  TableIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct SignalID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct SignalIDBuilder {
  typedef SignalID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(SignalID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(SignalID::VT_ID_GEN, id_gen, 0);
  }
  explicit SignalIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalIDBuilder &operator=(const SignalIDBuilder &);
  flatbuffers::Offset<SignalID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalID>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalID> CreateSignalID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  SignalIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct MethodID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct MethodIDBuilder {
  typedef MethodID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(MethodID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(MethodID::VT_ID_GEN, id_gen, 0);
  }
  explicit MethodIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MethodIDBuilder &operator=(const MethodIDBuilder &);
  flatbuffers::Offset<MethodID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodID>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodID> CreateMethodID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  MethodIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct MaterialID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct MaterialIDBuilder {
  typedef MaterialID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(MaterialID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(MaterialID::VT_ID_GEN, id_gen, 0);
  }
  explicit MaterialIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialIDBuilder &operator=(const MaterialIDBuilder &);
  flatbuffers::Offset<MaterialID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialID>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialID> CreateMaterialID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  MaterialIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct GeometryID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct GeometryIDBuilder {
  typedef GeometryID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(GeometryID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(GeometryID::VT_ID_GEN, id_gen, 0);
  }
  explicit GeometryIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryIDBuilder &operator=(const GeometryIDBuilder &);
  flatbuffers::Offset<GeometryID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryID>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryID> CreateGeometryID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  GeometryIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct LightID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct LightIDBuilder {
  typedef LightID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(LightID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(LightID::VT_ID_GEN, id_gen, 0);
  }
  explicit LightIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightIDBuilder &operator=(const LightIDBuilder &);
  flatbuffers::Offset<LightID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightID>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightID> CreateLightID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  LightIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct TextureID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct TextureIDBuilder {
  typedef TextureID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(TextureID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(TextureID::VT_ID_GEN, id_gen, 0);
  }
  explicit TextureIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureIDBuilder &operator=(const TextureIDBuilder &);
  flatbuffers::Offset<TextureID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureID>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureID> CreateTextureID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  TextureIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct BufferID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct BufferIDBuilder {
  typedef BufferID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(BufferID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(BufferID::VT_ID_GEN, id_gen, 0);
  }
  explicit BufferIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferIDBuilder &operator=(const BufferIDBuilder &);
  flatbuffers::Offset<BufferID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferID>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferID> CreateBufferID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  BufferIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct AnyID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_TYPE = 4,
    VT_ID = 6
  };
  noodles::AnyIDType id_type() const {
    return static_cast<noodles::AnyIDType>(GetField<uint8_t>(VT_ID_TYPE, 0));
  }
  const void *id() const {
    return GetPointer<const void *>(VT_ID);
  }
  template<typename T> const T *id_as() const;
  const noodles::ObjectID *id_as_ObjectID() const {
    return id_type() == noodles::AnyIDType::ObjectID ? static_cast<const noodles::ObjectID *>(id()) : nullptr;
  }
  const noodles::TableID *id_as_TableID() const {
    return id_type() == noodles::AnyIDType::TableID ? static_cast<const noodles::TableID *>(id()) : nullptr;
  }
  const noodles::SignalID *id_as_SignalID() const {
    return id_type() == noodles::AnyIDType::SignalID ? static_cast<const noodles::SignalID *>(id()) : nullptr;
  }
  const noodles::MethodID *id_as_MethodID() const {
    return id_type() == noodles::AnyIDType::MethodID ? static_cast<const noodles::MethodID *>(id()) : nullptr;
  }
  const noodles::MaterialID *id_as_MaterialID() const {
    return id_type() == noodles::AnyIDType::MaterialID ? static_cast<const noodles::MaterialID *>(id()) : nullptr;
  }
  const noodles::GeometryID *id_as_GeometryID() const {
    return id_type() == noodles::AnyIDType::GeometryID ? static_cast<const noodles::GeometryID *>(id()) : nullptr;
  }
  const noodles::LightID *id_as_LightID() const {
    return id_type() == noodles::AnyIDType::LightID ? static_cast<const noodles::LightID *>(id()) : nullptr;
  }
  const noodles::TextureID *id_as_TextureID() const {
    return id_type() == noodles::AnyIDType::TextureID ? static_cast<const noodles::TextureID *>(id()) : nullptr;
  }
  const noodles::BufferID *id_as_BufferID() const {
    return id_type() == noodles::AnyIDType::BufferID ? static_cast<const noodles::BufferID *>(id()) : nullptr;
  }
  void *mutable_id() {
    return GetPointer<void *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID_TYPE) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           VerifyAnyIDType(verifier, id(), id_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::ObjectID *AnyID::id_as<noodles::ObjectID>() const {
  return id_as_ObjectID();
}

template<> inline const noodles::TableID *AnyID::id_as<noodles::TableID>() const {
  return id_as_TableID();
}

template<> inline const noodles::SignalID *AnyID::id_as<noodles::SignalID>() const {
  return id_as_SignalID();
}

template<> inline const noodles::MethodID *AnyID::id_as<noodles::MethodID>() const {
  return id_as_MethodID();
}

template<> inline const noodles::MaterialID *AnyID::id_as<noodles::MaterialID>() const {
  return id_as_MaterialID();
}

template<> inline const noodles::GeometryID *AnyID::id_as<noodles::GeometryID>() const {
  return id_as_GeometryID();
}

template<> inline const noodles::LightID *AnyID::id_as<noodles::LightID>() const {
  return id_as_LightID();
}

template<> inline const noodles::TextureID *AnyID::id_as<noodles::TextureID>() const {
  return id_as_TextureID();
}

template<> inline const noodles::BufferID *AnyID::id_as<noodles::BufferID>() const {
  return id_as_BufferID();
}

struct AnyIDBuilder {
  typedef AnyID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_type(noodles::AnyIDType id_type) {
    fbb_.AddElement<uint8_t>(AnyID::VT_ID_TYPE, static_cast<uint8_t>(id_type), 0);
  }
  void add_id(flatbuffers::Offset<void> id) {
    fbb_.AddOffset(AnyID::VT_ID, id);
  }
  explicit AnyIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnyIDBuilder &operator=(const AnyIDBuilder &);
  flatbuffers::Offset<AnyID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyID>(end);
    fbb_.Required(o, AnyID::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<AnyID> CreateAnyID(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::AnyIDType id_type = noodles::AnyIDType::NONE,
    flatbuffers::Offset<void> id = 0) {
  AnyIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_id_type(id_type);
  return builder_.Finish();
}

struct MapEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapEntryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapEntryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const MapEntry *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const noodles::Any *value() const {
    return GetPointer<const noodles::Any *>(VT_VALUE);
  }
  noodles::Any *mutable_value() {
    return GetPointer<noodles::Any *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MapEntryBuilder {
  typedef MapEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MapEntry::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<noodles::Any> value) {
    fbb_.AddOffset(MapEntry::VT_VALUE, value);
  }
  explicit MapEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapEntryBuilder &operator=(const MapEntryBuilder &);
  flatbuffers::Offset<MapEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapEntry>(end);
    fbb_.Required(o, MapEntry::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<MapEntry> CreateMapEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<noodles::Any> value = 0) {
  MapEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapEntry> CreateMapEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<noodles::Any> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return noodles::CreateMapEntry(
      _fbb,
      name__,
      value);
}

struct Text FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct TextBuilder {
  typedef Text Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Text::VT_TEXT, text);
  }
  explicit TextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextBuilder &operator=(const TextBuilder &);
  flatbuffers::Offset<Text> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Text>(end);
    return o;
  }
};

inline flatbuffers::Offset<Text> CreateText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  TextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<Text> CreateTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return noodles::CreateText(
      _fbb,
      text__);
}

struct Integer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGER = 4
  };
  int64_t integer() const {
    return GetField<int64_t>(VT_INTEGER, 0);
  }
  bool mutate_integer(int64_t _integer) {
    return SetField<int64_t>(VT_INTEGER, _integer, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_INTEGER) &&
           verifier.EndTable();
  }
};

struct IntegerBuilder {
  typedef Integer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_integer(int64_t integer) {
    fbb_.AddElement<int64_t>(Integer::VT_INTEGER, integer, 0);
  }
  explicit IntegerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntegerBuilder &operator=(const IntegerBuilder &);
  flatbuffers::Offset<Integer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Integer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Integer> CreateInteger(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t integer = 0) {
  IntegerBuilder builder_(_fbb);
  builder_.add_integer(integer);
  return builder_.Finish();
}

struct IntegerList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGERS = 4
  };
  const flatbuffers::Vector<int64_t> *integers() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INTEGERS);
  }
  flatbuffers::Vector<int64_t> *mutable_integers() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_INTEGERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTEGERS) &&
           verifier.VerifyVector(integers()) &&
           verifier.EndTable();
  }
};

struct IntegerListBuilder {
  typedef IntegerList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_integers(flatbuffers::Offset<flatbuffers::Vector<int64_t>> integers) {
    fbb_.AddOffset(IntegerList::VT_INTEGERS, integers);
  }
  explicit IntegerListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntegerListBuilder &operator=(const IntegerListBuilder &);
  flatbuffers::Offset<IntegerList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntegerList>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntegerList> CreateIntegerList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> integers = 0) {
  IntegerListBuilder builder_(_fbb);
  builder_.add_integers(integers);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntegerList> CreateIntegerListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *integers = nullptr) {
  auto integers__ = integers ? _fbb.CreateVector<int64_t>(*integers) : 0;
  return noodles::CreateIntegerList(
      _fbb,
      integers__);
}

struct Real FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REAL = 4
  };
  double real() const {
    return GetField<double>(VT_REAL, 0.0);
  }
  bool mutate_real(double _real) {
    return SetField<double>(VT_REAL, _real, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_REAL) &&
           verifier.EndTable();
  }
};

struct RealBuilder {
  typedef Real Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_real(double real) {
    fbb_.AddElement<double>(Real::VT_REAL, real, 0.0);
  }
  explicit RealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RealBuilder &operator=(const RealBuilder &);
  flatbuffers::Offset<Real> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Real>(end);
    return o;
  }
};

inline flatbuffers::Offset<Real> CreateReal(
    flatbuffers::FlatBufferBuilder &_fbb,
    double real = 0.0) {
  RealBuilder builder_(_fbb);
  builder_.add_real(real);
  return builder_.Finish();
}

struct RealList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REALS = 4
  };
  const flatbuffers::Vector<double> *reals() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_REALS);
  }
  flatbuffers::Vector<double> *mutable_reals() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_REALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REALS) &&
           verifier.VerifyVector(reals()) &&
           verifier.EndTable();
  }
};

struct RealListBuilder {
  typedef RealList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reals(flatbuffers::Offset<flatbuffers::Vector<double>> reals) {
    fbb_.AddOffset(RealList::VT_REALS, reals);
  }
  explicit RealListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RealListBuilder &operator=(const RealListBuilder &);
  flatbuffers::Offset<RealList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealList>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealList> CreateRealList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> reals = 0) {
  RealListBuilder builder_(_fbb);
  builder_.add_reals(reals);
  return builder_.Finish();
}

inline flatbuffers::Offset<RealList> CreateRealListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *reals = nullptr) {
  auto reals__ = reals ? _fbb.CreateVector<double>(*reals) : 0;
  return noodles::CreateRealList(
      _fbb,
      reals__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<int8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Data::VT_DATA, data);
  }
  explicit DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBuilder &operator=(const DataBuilder &);
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Data> CreateDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return noodles::CreateData(
      _fbb,
      data__);
}

struct AnyList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct AnyListBuilder {
  typedef AnyList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>>> list) {
    fbb_.AddOffset(AnyList::VT_LIST, list);
  }
  explicit AnyListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnyListBuilder &operator=(const AnyListBuilder &);
  flatbuffers::Offset<AnyList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyList>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnyList> CreateAnyList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>>> list = 0) {
  AnyListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnyList> CreateAnyListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::Any>> *list = nullptr) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<noodles::Any>>(*list) : 0;
  return noodles::CreateAnyList(
      _fbb,
      list__);
}

struct AnyMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyMapBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyMapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *>(VT_ENTRIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *mutable_entries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct AnyMapBuilder {
  typedef AnyMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>>> entries) {
    fbb_.AddOffset(AnyMap::VT_ENTRIES, entries);
  }
  explicit AnyMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnyMapBuilder &operator=(const AnyMapBuilder &);
  flatbuffers::Offset<AnyMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnyMap> CreateAnyMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>>> entries = 0) {
  AnyMapBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnyMap> CreateAnyMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<noodles::MapEntry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfSortedTables<noodles::MapEntry>(entries) : 0;
  return noodles::CreateAnyMap(
      _fbb,
      entries__);
}

struct Any FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_TYPE = 4,
    VT_ANY = 6
  };
  noodles::AnyType any_type() const {
    return static_cast<noodles::AnyType>(GetField<uint8_t>(VT_ANY_TYPE, 0));
  }
  const void *any() const {
    return GetPointer<const void *>(VT_ANY);
  }
  template<typename T> const T *any_as() const;
  const noodles::Text *any_as_Text() const {
    return any_type() == noodles::AnyType::Text ? static_cast<const noodles::Text *>(any()) : nullptr;
  }
  const noodles::Integer *any_as_Integer() const {
    return any_type() == noodles::AnyType::Integer ? static_cast<const noodles::Integer *>(any()) : nullptr;
  }
  const noodles::IntegerList *any_as_IntegerList() const {
    return any_type() == noodles::AnyType::IntegerList ? static_cast<const noodles::IntegerList *>(any()) : nullptr;
  }
  const noodles::Real *any_as_Real() const {
    return any_type() == noodles::AnyType::Real ? static_cast<const noodles::Real *>(any()) : nullptr;
  }
  const noodles::RealList *any_as_RealList() const {
    return any_type() == noodles::AnyType::RealList ? static_cast<const noodles::RealList *>(any()) : nullptr;
  }
  const noodles::Data *any_as_Data() const {
    return any_type() == noodles::AnyType::Data ? static_cast<const noodles::Data *>(any()) : nullptr;
  }
  const noodles::AnyList *any_as_AnyList() const {
    return any_type() == noodles::AnyType::AnyList ? static_cast<const noodles::AnyList *>(any()) : nullptr;
  }
  const noodles::AnyMap *any_as_AnyMap() const {
    return any_type() == noodles::AnyType::AnyMap ? static_cast<const noodles::AnyMap *>(any()) : nullptr;
  }
  const noodles::AnyID *any_as_AnyID() const {
    return any_type() == noodles::AnyType::AnyID ? static_cast<const noodles::AnyID *>(any()) : nullptr;
  }
  void *mutable_any() {
    return GetPointer<void *>(VT_ANY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_TYPE) &&
           VerifyOffsetRequired(verifier, VT_ANY) &&
           VerifyAnyType(verifier, any(), any_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::Text *Any::any_as<noodles::Text>() const {
  return any_as_Text();
}

template<> inline const noodles::Integer *Any::any_as<noodles::Integer>() const {
  return any_as_Integer();
}

template<> inline const noodles::IntegerList *Any::any_as<noodles::IntegerList>() const {
  return any_as_IntegerList();
}

template<> inline const noodles::Real *Any::any_as<noodles::Real>() const {
  return any_as_Real();
}

template<> inline const noodles::RealList *Any::any_as<noodles::RealList>() const {
  return any_as_RealList();
}

template<> inline const noodles::Data *Any::any_as<noodles::Data>() const {
  return any_as_Data();
}

template<> inline const noodles::AnyList *Any::any_as<noodles::AnyList>() const {
  return any_as_AnyList();
}

template<> inline const noodles::AnyMap *Any::any_as<noodles::AnyMap>() const {
  return any_as_AnyMap();
}

template<> inline const noodles::AnyID *Any::any_as<noodles::AnyID>() const {
  return any_as_AnyID();
}

struct AnyBuilder {
  typedef Any Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_type(noodles::AnyType any_type) {
    fbb_.AddElement<uint8_t>(Any::VT_ANY_TYPE, static_cast<uint8_t>(any_type), 0);
  }
  void add_any(flatbuffers::Offset<void> any) {
    fbb_.AddOffset(Any::VT_ANY, any);
  }
  explicit AnyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnyBuilder &operator=(const AnyBuilder &);
  flatbuffers::Offset<Any> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Any>(end);
    fbb_.Required(o, Any::VT_ANY);
    return o;
  }
};

inline flatbuffers::Offset<Any> CreateAny(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::AnyType any_type = noodles::AnyType::NONE,
    flatbuffers::Offset<void> any = 0) {
  AnyBuilder builder_(_fbb);
  builder_.add_any(any);
  builder_.add_any_type(any_type);
  return builder_.Finish();
}

struct BufferRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferRefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_START = 6,
    VT_SIZE = 8
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint64_t>(verifier, VT_START) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct BufferRefBuilder {
  typedef BufferRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferRef::VT_ID, id);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(BufferRef::VT_START, start, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(BufferRef::VT_SIZE, size, 0);
  }
  explicit BufferRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferRefBuilder &operator=(const BufferRefBuilder &);
  flatbuffers::Offset<BufferRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferRef> CreateBufferRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    uint64_t start = 0,
    uint64_t size = 0) {
  BufferRefBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_start(start);
  builder_.add_id(id);
  return builder_.Finish();
}

inline bool VerifyAnyIDType(flatbuffers::Verifier &verifier, const void *obj, AnyIDType type) {
  switch (type) {
    case AnyIDType::NONE: {
      return true;
    }
    case AnyIDType::ObjectID: {
      auto ptr = reinterpret_cast<const noodles::ObjectID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::TableID: {
      auto ptr = reinterpret_cast<const noodles::TableID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::SignalID: {
      auto ptr = reinterpret_cast<const noodles::SignalID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::MethodID: {
      auto ptr = reinterpret_cast<const noodles::MethodID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::MaterialID: {
      auto ptr = reinterpret_cast<const noodles::MaterialID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::GeometryID: {
      auto ptr = reinterpret_cast<const noodles::GeometryID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::LightID: {
      auto ptr = reinterpret_cast<const noodles::LightID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::TextureID: {
      auto ptr = reinterpret_cast<const noodles::TextureID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::BufferID: {
      auto ptr = reinterpret_cast<const noodles::BufferID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyIDTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyIDType(
        verifier,  values->Get(i), types->GetEnum<AnyIDType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyType(flatbuffers::Verifier &verifier, const void *obj, AnyType type) {
  switch (type) {
    case AnyType::NONE: {
      return true;
    }
    case AnyType::Text: {
      auto ptr = reinterpret_cast<const noodles::Text *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Integer: {
      auto ptr = reinterpret_cast<const noodles::Integer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::IntegerList: {
      auto ptr = reinterpret_cast<const noodles::IntegerList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Real: {
      auto ptr = reinterpret_cast<const noodles::Real *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::RealList: {
      auto ptr = reinterpret_cast<const noodles::RealList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Data: {
      auto ptr = reinterpret_cast<const noodles::Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyList: {
      auto ptr = reinterpret_cast<const noodles::AnyList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyMap: {
      auto ptr = reinterpret_cast<const noodles::AnyMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyID: {
      auto ptr = reinterpret_cast<const noodles::AnyID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyType(
        verifier,  values->Get(i), types->GetEnum<AnyType>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *AnyIDTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::SignalIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::MaterialIDTypeTable,
    noodles::GeometryIDTypeTable,
    noodles::LightIDTypeTable,
    noodles::TextureIDTypeTable,
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "ObjectID",
    "TableID",
    "SignalID",
    "MethodID",
    "MaterialID",
    "GeometryID",
    "LightID",
    "TextureID",
    "BufferID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 10, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextTypeTable,
    noodles::IntegerTypeTable,
    noodles::IntegerListTypeTable,
    noodles::RealTypeTable,
    noodles::RealListTypeTable,
    noodles::DataTypeTable,
    noodles::AnyListTypeTable,
    noodles::AnyMapTypeTable,
    noodles::AnyIDTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Text",
    "Integer",
    "IntegerList",
    "Real",
    "RealList",
    "Data",
    "AnyList",
    "AnyMap",
    "AnyID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 10, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyIDTypeTypeTable
  };
  static const char * const names[] = {
    "id_type",
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapEntryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "name",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "text"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "integer"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "integers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "real"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const char * const names[] = {
    "reals"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyMapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MapEntryTypeTable
  };
  static const char * const names[] = {
    "entries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTypeTable
  };
  static const char * const names[] = {
    "any_type",
    "any"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Mat4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::Vec4TypeTable
  };
  static const int64_t values[] = { 0, 16, 32, 48, 64 };
  static const char * const names[] = {
    "c1",
    "c2",
    "c3",
    "c4"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace noodles

#endif  // FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_
