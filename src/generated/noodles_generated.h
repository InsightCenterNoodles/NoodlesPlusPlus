// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_
#define FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_

#include "flatbuffers/flatbuffers.h"

namespace noodles {

struct ObjectID;
struct ObjectIDBuilder;

struct PlotID;
struct PlotIDBuilder;

struct TableID;
struct TableIDBuilder;

struct SignalID;
struct SignalIDBuilder;

struct MethodID;
struct MethodIDBuilder;

struct MaterialID;
struct MaterialIDBuilder;

struct GeometryID;
struct GeometryIDBuilder;

struct LightID;
struct LightIDBuilder;

struct TextureID;
struct TextureIDBuilder;

struct BufferID;
struct BufferIDBuilder;

struct AnyID;
struct AnyIDBuilder;

struct MapEntry;
struct MapEntryBuilder;

struct Text;
struct TextBuilder;

struct Integer;
struct IntegerBuilder;

struct IntegerList;
struct IntegerListBuilder;

struct Real;
struct RealBuilder;

struct RealList;
struct RealListBuilder;

struct Data;
struct DataBuilder;

struct AnyList;
struct AnyListBuilder;

struct AnyMap;
struct AnyMapBuilder;

struct Any;
struct AnyBuilder;

struct Vec2;

struct Vec3;

struct Vec4;

struct Mat4;

struct BoundingBox;

struct BufferRef;
struct BufferRefBuilder;

struct RGB;

struct MethodArg;
struct MethodArgBuilder;

struct MethodCreate;
struct MethodCreateBuilder;

struct MethodDelete;
struct MethodDeleteBuilder;

struct SignalCreate;
struct SignalCreateBuilder;

struct SignalDelete;
struct SignalDeleteBuilder;

struct EmptyDefinition;
struct EmptyDefinitionBuilder;

struct TextDefinition;
struct TextDefinitionBuilder;

struct WebpageDefinition;
struct WebpageDefinitionBuilder;

struct RenderableDefinition;
struct RenderableDefinitionBuilder;

struct ObjectVisibility;

struct ObjectCreateUpdate;
struct ObjectCreateUpdateBuilder;

struct ObjectDelete;
struct ObjectDeleteBuilder;

struct SimplePlot;
struct SimplePlotBuilder;

struct URLPlot;
struct URLPlotBuilder;

struct PlotCreateUpdate;
struct PlotCreateUpdateBuilder;

struct PlotDelete;
struct PlotDeleteBuilder;

struct BufferCreate;
struct BufferCreateBuilder;

struct BufferDelete;
struct BufferDeleteBuilder;

struct MaterialCreateUpdate;
struct MaterialCreateUpdateBuilder;

struct MaterialDelete;
struct MaterialDeleteBuilder;

struct TextureCreateUpdate;
struct TextureCreateUpdateBuilder;

struct TextureDelete;
struct TextureDeleteBuilder;

struct LightCreateUpdate;
struct LightCreateUpdateBuilder;

struct LightDelete;
struct LightDeleteBuilder;

struct ComponentRef;
struct ComponentRefBuilder;

struct GeometryCreate;
struct GeometryCreateBuilder;

struct GeometryDelete;
struct GeometryDeleteBuilder;

struct TableCreateUpdate;
struct TableCreateUpdateBuilder;

struct TableDelete;
struct TableDeleteBuilder;

struct DocumentUpdate;
struct DocumentUpdateBuilder;

struct DocumentReset;
struct DocumentResetBuilder;

struct SignalInvoke;
struct SignalInvokeBuilder;

struct MethodException;
struct MethodExceptionBuilder;

struct MethodReply;
struct MethodReplyBuilder;

struct ServerMessage;
struct ServerMessageBuilder;

struct ServerMessages;
struct ServerMessagesBuilder;

struct IntroductionMessage;
struct IntroductionMessageBuilder;

struct MethodInvokeMessage;
struct MethodInvokeMessageBuilder;

struct AssetRefreshMessage;
struct AssetRefreshMessageBuilder;

struct ClientMessage;
struct ClientMessageBuilder;

struct ClientMessages;
struct ClientMessagesBuilder;

inline const flatbuffers::TypeTable *ObjectIDTypeTable();

inline const flatbuffers::TypeTable *PlotIDTypeTable();

inline const flatbuffers::TypeTable *TableIDTypeTable();

inline const flatbuffers::TypeTable *SignalIDTypeTable();

inline const flatbuffers::TypeTable *MethodIDTypeTable();

inline const flatbuffers::TypeTable *MaterialIDTypeTable();

inline const flatbuffers::TypeTable *GeometryIDTypeTable();

inline const flatbuffers::TypeTable *LightIDTypeTable();

inline const flatbuffers::TypeTable *TextureIDTypeTable();

inline const flatbuffers::TypeTable *BufferIDTypeTable();

inline const flatbuffers::TypeTable *AnyIDTypeTable();

inline const flatbuffers::TypeTable *MapEntryTypeTable();

inline const flatbuffers::TypeTable *TextTypeTable();

inline const flatbuffers::TypeTable *IntegerTypeTable();

inline const flatbuffers::TypeTable *IntegerListTypeTable();

inline const flatbuffers::TypeTable *RealTypeTable();

inline const flatbuffers::TypeTable *RealListTypeTable();

inline const flatbuffers::TypeTable *DataTypeTable();

inline const flatbuffers::TypeTable *AnyListTypeTable();

inline const flatbuffers::TypeTable *AnyMapTypeTable();

inline const flatbuffers::TypeTable *AnyTypeTable();

inline const flatbuffers::TypeTable *Vec2TypeTable();

inline const flatbuffers::TypeTable *Vec3TypeTable();

inline const flatbuffers::TypeTable *Vec4TypeTable();

inline const flatbuffers::TypeTable *Mat4TypeTable();

inline const flatbuffers::TypeTable *BoundingBoxTypeTable();

inline const flatbuffers::TypeTable *BufferRefTypeTable();

inline const flatbuffers::TypeTable *RGBTypeTable();

inline const flatbuffers::TypeTable *MethodArgTypeTable();

inline const flatbuffers::TypeTable *MethodCreateTypeTable();

inline const flatbuffers::TypeTable *MethodDeleteTypeTable();

inline const flatbuffers::TypeTable *SignalCreateTypeTable();

inline const flatbuffers::TypeTable *SignalDeleteTypeTable();

inline const flatbuffers::TypeTable *EmptyDefinitionTypeTable();

inline const flatbuffers::TypeTable *TextDefinitionTypeTable();

inline const flatbuffers::TypeTable *WebpageDefinitionTypeTable();

inline const flatbuffers::TypeTable *RenderableDefinitionTypeTable();

inline const flatbuffers::TypeTable *ObjectVisibilityTypeTable();

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable();

inline const flatbuffers::TypeTable *SimplePlotTypeTable();

inline const flatbuffers::TypeTable *URLPlotTypeTable();

inline const flatbuffers::TypeTable *PlotCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *PlotDeleteTypeTable();

inline const flatbuffers::TypeTable *BufferCreateTypeTable();

inline const flatbuffers::TypeTable *BufferDeleteTypeTable();

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable();

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TextureDeleteTypeTable();

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *LightDeleteTypeTable();

inline const flatbuffers::TypeTable *ComponentRefTypeTable();

inline const flatbuffers::TypeTable *GeometryCreateTypeTable();

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable();

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TableDeleteTypeTable();

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable();

inline const flatbuffers::TypeTable *DocumentResetTypeTable();

inline const flatbuffers::TypeTable *SignalInvokeTypeTable();

inline const flatbuffers::TypeTable *MethodExceptionTypeTable();

inline const flatbuffers::TypeTable *MethodReplyTypeTable();

inline const flatbuffers::TypeTable *ServerMessageTypeTable();

inline const flatbuffers::TypeTable *ServerMessagesTypeTable();

inline const flatbuffers::TypeTable *IntroductionMessageTypeTable();

inline const flatbuffers::TypeTable *MethodInvokeMessageTypeTable();

inline const flatbuffers::TypeTable *AssetRefreshMessageTypeTable();

inline const flatbuffers::TypeTable *ClientMessageTypeTable();

inline const flatbuffers::TypeTable *ClientMessagesTypeTable();

enum class AnyIDType : uint8_t {
  NONE = 0,
  ObjectID = 1,
  TableID = 2,
  SignalID = 3,
  MethodID = 4,
  MaterialID = 5,
  GeometryID = 6,
  LightID = 7,
  TextureID = 8,
  BufferID = 9,
  PlotID = 10,
  MIN = NONE,
  MAX = PlotID
};

inline const AnyIDType (&EnumValuesAnyIDType())[11] {
  static const AnyIDType values[] = {
    AnyIDType::NONE,
    AnyIDType::ObjectID,
    AnyIDType::TableID,
    AnyIDType::SignalID,
    AnyIDType::MethodID,
    AnyIDType::MaterialID,
    AnyIDType::GeometryID,
    AnyIDType::LightID,
    AnyIDType::TextureID,
    AnyIDType::BufferID,
    AnyIDType::PlotID
  };
  return values;
}

inline const char * const *EnumNamesAnyIDType() {
  static const char * const names[12] = {
    "NONE",
    "ObjectID",
    "TableID",
    "SignalID",
    "MethodID",
    "MaterialID",
    "GeometryID",
    "LightID",
    "TextureID",
    "BufferID",
    "PlotID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyIDType(AnyIDType e) {
  if (flatbuffers::IsOutRange(e, AnyIDType::NONE, AnyIDType::PlotID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyIDType()[index];
}

template<typename T> struct AnyIDTypeTraits {
  static const AnyIDType enum_value = AnyIDType::NONE;
};

template<> struct AnyIDTypeTraits<noodles::ObjectID> {
  static const AnyIDType enum_value = AnyIDType::ObjectID;
};

template<> struct AnyIDTypeTraits<noodles::TableID> {
  static const AnyIDType enum_value = AnyIDType::TableID;
};

template<> struct AnyIDTypeTraits<noodles::SignalID> {
  static const AnyIDType enum_value = AnyIDType::SignalID;
};

template<> struct AnyIDTypeTraits<noodles::MethodID> {
  static const AnyIDType enum_value = AnyIDType::MethodID;
};

template<> struct AnyIDTypeTraits<noodles::MaterialID> {
  static const AnyIDType enum_value = AnyIDType::MaterialID;
};

template<> struct AnyIDTypeTraits<noodles::GeometryID> {
  static const AnyIDType enum_value = AnyIDType::GeometryID;
};

template<> struct AnyIDTypeTraits<noodles::LightID> {
  static const AnyIDType enum_value = AnyIDType::LightID;
};

template<> struct AnyIDTypeTraits<noodles::TextureID> {
  static const AnyIDType enum_value = AnyIDType::TextureID;
};

template<> struct AnyIDTypeTraits<noodles::BufferID> {
  static const AnyIDType enum_value = AnyIDType::BufferID;
};

template<> struct AnyIDTypeTraits<noodles::PlotID> {
  static const AnyIDType enum_value = AnyIDType::PlotID;
};

bool VerifyAnyIDType(flatbuffers::Verifier &verifier, const void *obj, AnyIDType type);
bool VerifyAnyIDTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AnyType : uint8_t {
  NONE = 0,
  Text = 1,
  Integer = 2,
  IntegerList = 3,
  Real = 4,
  RealList = 5,
  Data = 6,
  AnyList = 7,
  AnyMap = 8,
  AnyID = 9,
  MIN = NONE,
  MAX = AnyID
};

inline const AnyType (&EnumValuesAnyType())[10] {
  static const AnyType values[] = {
    AnyType::NONE,
    AnyType::Text,
    AnyType::Integer,
    AnyType::IntegerList,
    AnyType::Real,
    AnyType::RealList,
    AnyType::Data,
    AnyType::AnyList,
    AnyType::AnyMap,
    AnyType::AnyID
  };
  return values;
}

inline const char * const *EnumNamesAnyType() {
  static const char * const names[11] = {
    "NONE",
    "Text",
    "Integer",
    "IntegerList",
    "Real",
    "RealList",
    "Data",
    "AnyList",
    "AnyMap",
    "AnyID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyType(AnyType e) {
  if (flatbuffers::IsOutRange(e, AnyType::NONE, AnyType::AnyID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyType()[index];
}

template<typename T> struct AnyTypeTraits {
  static const AnyType enum_value = AnyType::NONE;
};

template<> struct AnyTypeTraits<noodles::Text> {
  static const AnyType enum_value = AnyType::Text;
};

template<> struct AnyTypeTraits<noodles::Integer> {
  static const AnyType enum_value = AnyType::Integer;
};

template<> struct AnyTypeTraits<noodles::IntegerList> {
  static const AnyType enum_value = AnyType::IntegerList;
};

template<> struct AnyTypeTraits<noodles::Real> {
  static const AnyType enum_value = AnyType::Real;
};

template<> struct AnyTypeTraits<noodles::RealList> {
  static const AnyType enum_value = AnyType::RealList;
};

template<> struct AnyTypeTraits<noodles::Data> {
  static const AnyType enum_value = AnyType::Data;
};

template<> struct AnyTypeTraits<noodles::AnyList> {
  static const AnyType enum_value = AnyType::AnyList;
};

template<> struct AnyTypeTraits<noodles::AnyMap> {
  static const AnyType enum_value = AnyType::AnyMap;
};

template<> struct AnyTypeTraits<noodles::AnyID> {
  static const AnyType enum_value = AnyType::AnyID;
};

bool VerifyAnyType(flatbuffers::Verifier &verifier, const void *obj, AnyType type);
bool VerifyAnyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ObjectDefinition : uint8_t {
  NONE = 0,
  EmptyDefinition = 1,
  TextDefinition = 2,
  WebpageDefinition = 3,
  RenderableDefinition = 4,
  MIN = NONE,
  MAX = RenderableDefinition
};

inline const ObjectDefinition (&EnumValuesObjectDefinition())[5] {
  static const ObjectDefinition values[] = {
    ObjectDefinition::NONE,
    ObjectDefinition::EmptyDefinition,
    ObjectDefinition::TextDefinition,
    ObjectDefinition::WebpageDefinition,
    ObjectDefinition::RenderableDefinition
  };
  return values;
}

inline const char * const *EnumNamesObjectDefinition() {
  static const char * const names[6] = {
    "NONE",
    "EmptyDefinition",
    "TextDefinition",
    "WebpageDefinition",
    "RenderableDefinition",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectDefinition(ObjectDefinition e) {
  if (flatbuffers::IsOutRange(e, ObjectDefinition::NONE, ObjectDefinition::RenderableDefinition)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectDefinition()[index];
}

template<typename T> struct ObjectDefinitionTraits {
  static const ObjectDefinition enum_value = ObjectDefinition::NONE;
};

template<> struct ObjectDefinitionTraits<noodles::EmptyDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::EmptyDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::TextDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::TextDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::WebpageDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::WebpageDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::RenderableDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::RenderableDefinition;
};

bool VerifyObjectDefinition(flatbuffers::Verifier &verifier, const void *obj, ObjectDefinition type);
bool VerifyObjectDefinitionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class PlotType : uint8_t {
  NONE = 0,
  SimplePlot = 1,
  URLPlot = 2,
  MIN = NONE,
  MAX = URLPlot
};

inline const PlotType (&EnumValuesPlotType())[3] {
  static const PlotType values[] = {
    PlotType::NONE,
    PlotType::SimplePlot,
    PlotType::URLPlot
  };
  return values;
}

inline const char * const *EnumNamesPlotType() {
  static const char * const names[4] = {
    "NONE",
    "SimplePlot",
    "URLPlot",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlotType(PlotType e) {
  if (flatbuffers::IsOutRange(e, PlotType::NONE, PlotType::URLPlot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlotType()[index];
}

template<typename T> struct PlotTypeTraits {
  static const PlotType enum_value = PlotType::NONE;
};

template<> struct PlotTypeTraits<noodles::SimplePlot> {
  static const PlotType enum_value = PlotType::SimplePlot;
};

template<> struct PlotTypeTraits<noodles::URLPlot> {
  static const PlotType enum_value = PlotType::URLPlot;
};

bool VerifyPlotType(flatbuffers::Verifier &verifier, const void *obj, PlotType type);
bool VerifyPlotTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class LightType : int8_t {
  POINT = 0,
  SUN = 1,
  MIN = POINT,
  MAX = SUN
};

inline const LightType (&EnumValuesLightType())[2] {
  static const LightType values[] = {
    LightType::POINT,
    LightType::SUN
  };
  return values;
}

inline const char * const *EnumNamesLightType() {
  static const char * const names[3] = {
    "POINT",
    "SUN",
    nullptr
  };
  return names;
}

inline const char *EnumNameLightType(LightType e) {
  if (flatbuffers::IsOutRange(e, LightType::POINT, LightType::SUN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLightType()[index];
}

enum class ServerMessageType : uint8_t {
  NONE = 0,
  MethodCreate = 1,
  MethodDelete = 2,
  SignalCreate = 3,
  SignalDelete = 4,
  ObjectCreateUpdate = 5,
  ObjectDelete = 6,
  BufferCreate = 7,
  BufferDelete = 8,
  MaterialCreateUpdate = 9,
  MaterialDelete = 10,
  TextureCreateUpdate = 11,
  TextureDelete = 12,
  LightCreateUpdate = 13,
  LightDelete = 14,
  GeometryCreate = 15,
  GeometryDelete = 16,
  TableCreateUpdate = 17,
  TableDelete = 18,
  DocumentUpdate = 19,
  DocumentReset = 20,
  SignalInvoke = 21,
  MethodReply = 22,
  MIN = NONE,
  MAX = MethodReply
};

inline const ServerMessageType (&EnumValuesServerMessageType())[23] {
  static const ServerMessageType values[] = {
    ServerMessageType::NONE,
    ServerMessageType::MethodCreate,
    ServerMessageType::MethodDelete,
    ServerMessageType::SignalCreate,
    ServerMessageType::SignalDelete,
    ServerMessageType::ObjectCreateUpdate,
    ServerMessageType::ObjectDelete,
    ServerMessageType::BufferCreate,
    ServerMessageType::BufferDelete,
    ServerMessageType::MaterialCreateUpdate,
    ServerMessageType::MaterialDelete,
    ServerMessageType::TextureCreateUpdate,
    ServerMessageType::TextureDelete,
    ServerMessageType::LightCreateUpdate,
    ServerMessageType::LightDelete,
    ServerMessageType::GeometryCreate,
    ServerMessageType::GeometryDelete,
    ServerMessageType::TableCreateUpdate,
    ServerMessageType::TableDelete,
    ServerMessageType::DocumentUpdate,
    ServerMessageType::DocumentReset,
    ServerMessageType::SignalInvoke,
    ServerMessageType::MethodReply
  };
  return values;
}

inline const char * const *EnumNamesServerMessageType() {
  static const char * const names[24] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerMessageType(ServerMessageType e) {
  if (flatbuffers::IsOutRange(e, ServerMessageType::NONE, ServerMessageType::MethodReply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerMessageType()[index];
}

template<typename T> struct ServerMessageTypeTraits {
  static const ServerMessageType enum_value = ServerMessageType::NONE;
};

template<> struct ServerMessageTypeTraits<noodles::MethodCreate> {
  static const ServerMessageType enum_value = ServerMessageType::MethodCreate;
};

template<> struct ServerMessageTypeTraits<noodles::MethodDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MethodDelete;
};

template<> struct ServerMessageTypeTraits<noodles::SignalCreate> {
  static const ServerMessageType enum_value = ServerMessageType::SignalCreate;
};

template<> struct ServerMessageTypeTraits<noodles::SignalDelete> {
  static const ServerMessageType enum_value = ServerMessageType::SignalDelete;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectDelete> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectDelete;
};

template<> struct ServerMessageTypeTraits<noodles::BufferCreate> {
  static const ServerMessageType enum_value = ServerMessageType::BufferCreate;
};

template<> struct ServerMessageTypeTraits<noodles::BufferDelete> {
  static const ServerMessageType enum_value = ServerMessageType::BufferDelete;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TextureCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TextureCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TextureDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TextureDelete;
};

template<> struct ServerMessageTypeTraits<noodles::LightCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::LightCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::LightDelete> {
  static const ServerMessageType enum_value = ServerMessageType::LightDelete;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryCreate> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryCreate;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryDelete> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TableCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TableCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TableDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TableDelete;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentReset> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentReset;
};

template<> struct ServerMessageTypeTraits<noodles::SignalInvoke> {
  static const ServerMessageType enum_value = ServerMessageType::SignalInvoke;
};

template<> struct ServerMessageTypeTraits<noodles::MethodReply> {
  static const ServerMessageType enum_value = ServerMessageType::MethodReply;
};

bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type);
bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ClientMessageType : uint8_t {
  NONE = 0,
  IntroductionMessage = 1,
  MethodInvokeMessage = 2,
  AssetRefreshMessage = 3,
  MIN = NONE,
  MAX = AssetRefreshMessage
};

inline const ClientMessageType (&EnumValuesClientMessageType())[4] {
  static const ClientMessageType values[] = {
    ClientMessageType::NONE,
    ClientMessageType::IntroductionMessage,
    ClientMessageType::MethodInvokeMessage,
    ClientMessageType::AssetRefreshMessage
  };
  return values;
}

inline const char * const *EnumNamesClientMessageType() {
  static const char * const names[5] = {
    "NONE",
    "IntroductionMessage",
    "MethodInvokeMessage",
    "AssetRefreshMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameClientMessageType(ClientMessageType e) {
  if (flatbuffers::IsOutRange(e, ClientMessageType::NONE, ClientMessageType::AssetRefreshMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClientMessageType()[index];
}

template<typename T> struct ClientMessageTypeTraits {
  static const ClientMessageType enum_value = ClientMessageType::NONE;
};

template<> struct ClientMessageTypeTraits<noodles::IntroductionMessage> {
  static const ClientMessageType enum_value = ClientMessageType::IntroductionMessage;
};

template<> struct ClientMessageTypeTraits<noodles::MethodInvokeMessage> {
  static const ClientMessageType enum_value = ClientMessageType::MethodInvokeMessage;
};

template<> struct ClientMessageTypeTraits<noodles::AssetRefreshMessage> {
  static const ClientMessageType enum_value = ClientMessageType::AssetRefreshMessage;
};

bool VerifyClientMessageType(flatbuffers::Verifier &verifier, const void *obj, ClientMessageType type);
bool VerifyClientMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2TypeTable();
  }
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec3TypeTable();
  }
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec4TypeTable();
  }
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  noodles::Vec4 c1_;
  noodles::Vec4 c2_;
  noodles::Vec4 c3_;
  noodles::Vec4 c4_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Mat4TypeTable();
  }
  Mat4()
      : c1_(),
        c2_(),
        c3_(),
        c4_() {
  }
  Mat4(const noodles::Vec4 &_c1, const noodles::Vec4 &_c2, const noodles::Vec4 &_c3, const noodles::Vec4 &_c4)
      : c1_(_c1),
        c2_(_c2),
        c3_(_c3),
        c4_(_c4) {
  }
  const noodles::Vec4 &c1() const {
    return c1_;
  }
  noodles::Vec4 &mutable_c1() {
    return c1_;
  }
  const noodles::Vec4 &c2() const {
    return c2_;
  }
  noodles::Vec4 &mutable_c2() {
    return c2_;
  }
  const noodles::Vec4 &c3() const {
    return c3_;
  }
  noodles::Vec4 &mutable_c3() {
    return c3_;
  }
  const noodles::Vec4 &c4() const {
    return c4_;
  }
  noodles::Vec4 &mutable_c4() {
    return c4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoundingBox FLATBUFFERS_FINAL_CLASS {
 private:
  noodles::Vec3 aabb_min_;
  noodles::Vec3 aabb_max_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BoundingBoxTypeTable();
  }
  BoundingBox()
      : aabb_min_(),
        aabb_max_() {
  }
  BoundingBox(const noodles::Vec3 &_aabb_min, const noodles::Vec3 &_aabb_max)
      : aabb_min_(_aabb_min),
        aabb_max_(_aabb_max) {
  }
  const noodles::Vec3 &aabb_min() const {
    return aabb_min_;
  }
  noodles::Vec3 &mutable_aabb_min() {
    return aabb_min_;
  }
  const noodles::Vec3 &aabb_max() const {
    return aabb_max_;
  }
  noodles::Vec3 &mutable_aabb_max() {
    return aabb_max_;
  }
};
FLATBUFFERS_STRUCT_END(BoundingBox, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) RGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RGBTypeTable();
  }
  RGB()
      : r_(0),
        g_(0),
        b_(0) {
  }
  RGB(uint8_t _r, uint8_t _g, uint8_t _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  void mutate_r(uint8_t _r) {
    flatbuffers::WriteScalar(&r_, _r);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  void mutate_g(uint8_t _g) {
    flatbuffers::WriteScalar(&g_, _g);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  void mutate_b(uint8_t _b) {
    flatbuffers::WriteScalar(&b_, _b);
  }
};
FLATBUFFERS_STRUCT_END(RGB, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ObjectVisibility FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t visible_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectVisibilityTypeTable();
  }
  ObjectVisibility()
      : visible_(0) {
  }
  ObjectVisibility(bool _visible)
      : visible_(flatbuffers::EndianScalar(static_cast<uint8_t>(_visible))) {
  }
  bool visible() const {
    return flatbuffers::EndianScalar(visible_) != 0;
  }
  void mutate_visible(bool _visible) {
    flatbuffers::WriteScalar(&visible_, static_cast<uint8_t>(_visible));
  }
};
FLATBUFFERS_STRUCT_END(ObjectVisibility, 1);

struct ObjectID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct ObjectIDBuilder {
  typedef ObjectID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(ObjectID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(ObjectID::VT_ID_GEN, id_gen, 0);
  }
  explicit ObjectIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectID>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectID> CreateObjectID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  ObjectIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct PlotID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlotIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlotIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct PlotIDBuilder {
  typedef PlotID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(PlotID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(PlotID::VT_ID_GEN, id_gen, 0);
  }
  explicit PlotIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlotID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlotID>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlotID> CreatePlotID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  PlotIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct TableID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct TableIDBuilder {
  typedef TableID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(TableID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(TableID::VT_ID_GEN, id_gen, 0);
  }
  explicit TableIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableID>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableID> CreateTableID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  TableIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct SignalID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct SignalIDBuilder {
  typedef SignalID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(SignalID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(SignalID::VT_ID_GEN, id_gen, 0);
  }
  explicit SignalIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalID>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalID> CreateSignalID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  SignalIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct MethodID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct MethodIDBuilder {
  typedef MethodID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(MethodID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(MethodID::VT_ID_GEN, id_gen, 0);
  }
  explicit MethodIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodID>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodID> CreateMethodID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  MethodIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct MaterialID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct MaterialIDBuilder {
  typedef MaterialID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(MaterialID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(MaterialID::VT_ID_GEN, id_gen, 0);
  }
  explicit MaterialIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialID>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialID> CreateMaterialID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  MaterialIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct GeometryID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct GeometryIDBuilder {
  typedef GeometryID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(GeometryID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(GeometryID::VT_ID_GEN, id_gen, 0);
  }
  explicit GeometryIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryID>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryID> CreateGeometryID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  GeometryIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct LightID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct LightIDBuilder {
  typedef LightID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(LightID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(LightID::VT_ID_GEN, id_gen, 0);
  }
  explicit LightIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LightID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightID>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightID> CreateLightID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  LightIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct TextureID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct TextureIDBuilder {
  typedef TextureID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(TextureID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(TextureID::VT_ID_GEN, id_gen, 0);
  }
  explicit TextureIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureID>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureID> CreateTextureID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  TextureIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct BufferID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_SLOT = 4,
    VT_ID_GEN = 6
  };
  uint32_t id_slot() const {
    return GetField<uint32_t>(VT_ID_SLOT, 0);
  }
  bool mutate_id_slot(uint32_t _id_slot) {
    return SetField<uint32_t>(VT_ID_SLOT, _id_slot, 0);
  }
  uint32_t id_gen() const {
    return GetField<uint32_t>(VT_ID_GEN, 0);
  }
  bool mutate_id_gen(uint32_t _id_gen) {
    return SetField<uint32_t>(VT_ID_GEN, _id_gen, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_ID_GEN) &&
           verifier.EndTable();
  }
};

struct BufferIDBuilder {
  typedef BufferID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_slot(uint32_t id_slot) {
    fbb_.AddElement<uint32_t>(BufferID::VT_ID_SLOT, id_slot, 0);
  }
  void add_id_gen(uint32_t id_gen) {
    fbb_.AddElement<uint32_t>(BufferID::VT_ID_GEN, id_gen, 0);
  }
  explicit BufferIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferID>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferID> CreateBufferID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id_slot = 0,
    uint32_t id_gen = 0) {
  BufferIDBuilder builder_(_fbb);
  builder_.add_id_gen(id_gen);
  builder_.add_id_slot(id_slot);
  return builder_.Finish();
}

struct AnyID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyIDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyIDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_TYPE = 4,
    VT_ID = 6
  };
  noodles::AnyIDType id_type() const {
    return static_cast<noodles::AnyIDType>(GetField<uint8_t>(VT_ID_TYPE, 0));
  }
  const void *id() const {
    return GetPointer<const void *>(VT_ID);
  }
  template<typename T> const T *id_as() const;
  const noodles::ObjectID *id_as_ObjectID() const {
    return id_type() == noodles::AnyIDType::ObjectID ? static_cast<const noodles::ObjectID *>(id()) : nullptr;
  }
  const noodles::TableID *id_as_TableID() const {
    return id_type() == noodles::AnyIDType::TableID ? static_cast<const noodles::TableID *>(id()) : nullptr;
  }
  const noodles::SignalID *id_as_SignalID() const {
    return id_type() == noodles::AnyIDType::SignalID ? static_cast<const noodles::SignalID *>(id()) : nullptr;
  }
  const noodles::MethodID *id_as_MethodID() const {
    return id_type() == noodles::AnyIDType::MethodID ? static_cast<const noodles::MethodID *>(id()) : nullptr;
  }
  const noodles::MaterialID *id_as_MaterialID() const {
    return id_type() == noodles::AnyIDType::MaterialID ? static_cast<const noodles::MaterialID *>(id()) : nullptr;
  }
  const noodles::GeometryID *id_as_GeometryID() const {
    return id_type() == noodles::AnyIDType::GeometryID ? static_cast<const noodles::GeometryID *>(id()) : nullptr;
  }
  const noodles::LightID *id_as_LightID() const {
    return id_type() == noodles::AnyIDType::LightID ? static_cast<const noodles::LightID *>(id()) : nullptr;
  }
  const noodles::TextureID *id_as_TextureID() const {
    return id_type() == noodles::AnyIDType::TextureID ? static_cast<const noodles::TextureID *>(id()) : nullptr;
  }
  const noodles::BufferID *id_as_BufferID() const {
    return id_type() == noodles::AnyIDType::BufferID ? static_cast<const noodles::BufferID *>(id()) : nullptr;
  }
  const noodles::PlotID *id_as_PlotID() const {
    return id_type() == noodles::AnyIDType::PlotID ? static_cast<const noodles::PlotID *>(id()) : nullptr;
  }
  void *mutable_id() {
    return GetPointer<void *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID_TYPE) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           VerifyAnyIDType(verifier, id(), id_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::ObjectID *AnyID::id_as<noodles::ObjectID>() const {
  return id_as_ObjectID();
}

template<> inline const noodles::TableID *AnyID::id_as<noodles::TableID>() const {
  return id_as_TableID();
}

template<> inline const noodles::SignalID *AnyID::id_as<noodles::SignalID>() const {
  return id_as_SignalID();
}

template<> inline const noodles::MethodID *AnyID::id_as<noodles::MethodID>() const {
  return id_as_MethodID();
}

template<> inline const noodles::MaterialID *AnyID::id_as<noodles::MaterialID>() const {
  return id_as_MaterialID();
}

template<> inline const noodles::GeometryID *AnyID::id_as<noodles::GeometryID>() const {
  return id_as_GeometryID();
}

template<> inline const noodles::LightID *AnyID::id_as<noodles::LightID>() const {
  return id_as_LightID();
}

template<> inline const noodles::TextureID *AnyID::id_as<noodles::TextureID>() const {
  return id_as_TextureID();
}

template<> inline const noodles::BufferID *AnyID::id_as<noodles::BufferID>() const {
  return id_as_BufferID();
}

template<> inline const noodles::PlotID *AnyID::id_as<noodles::PlotID>() const {
  return id_as_PlotID();
}

struct AnyIDBuilder {
  typedef AnyID Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id_type(noodles::AnyIDType id_type) {
    fbb_.AddElement<uint8_t>(AnyID::VT_ID_TYPE, static_cast<uint8_t>(id_type), 0);
  }
  void add_id(flatbuffers::Offset<void> id) {
    fbb_.AddOffset(AnyID::VT_ID, id);
  }
  explicit AnyIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnyID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyID>(end);
    fbb_.Required(o, AnyID::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<AnyID> CreateAnyID(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::AnyIDType id_type = noodles::AnyIDType::NONE,
    flatbuffers::Offset<void> id = 0) {
  AnyIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_id_type(id_type);
  return builder_.Finish();
}

struct MapEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapEntryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapEntryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const MapEntry *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const noodles::Any *value() const {
    return GetPointer<const noodles::Any *>(VT_VALUE);
  }
  noodles::Any *mutable_value() {
    return GetPointer<noodles::Any *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MapEntryBuilder {
  typedef MapEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MapEntry::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<noodles::Any> value) {
    fbb_.AddOffset(MapEntry::VT_VALUE, value);
  }
  explicit MapEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapEntry>(end);
    fbb_.Required(o, MapEntry::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<MapEntry> CreateMapEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<noodles::Any> value = 0) {
  MapEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapEntry> CreateMapEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<noodles::Any> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return noodles::CreateMapEntry(
      _fbb,
      name__,
      value);
}

struct Text FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct TextBuilder {
  typedef Text Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Text::VT_TEXT, text);
  }
  explicit TextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Text> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Text>(end);
    return o;
  }
};

inline flatbuffers::Offset<Text> CreateText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  TextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<Text> CreateTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return noodles::CreateText(
      _fbb,
      text__);
}

struct Integer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGER = 4
  };
  int64_t integer() const {
    return GetField<int64_t>(VT_INTEGER, 0);
  }
  bool mutate_integer(int64_t _integer) {
    return SetField<int64_t>(VT_INTEGER, _integer, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_INTEGER) &&
           verifier.EndTable();
  }
};

struct IntegerBuilder {
  typedef Integer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_integer(int64_t integer) {
    fbb_.AddElement<int64_t>(Integer::VT_INTEGER, integer, 0);
  }
  explicit IntegerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Integer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Integer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Integer> CreateInteger(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t integer = 0) {
  IntegerBuilder builder_(_fbb);
  builder_.add_integer(integer);
  return builder_.Finish();
}

struct IntegerList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGERS = 4
  };
  const flatbuffers::Vector<int64_t> *integers() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INTEGERS);
  }
  flatbuffers::Vector<int64_t> *mutable_integers() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_INTEGERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTEGERS) &&
           verifier.VerifyVector(integers()) &&
           verifier.EndTable();
  }
};

struct IntegerListBuilder {
  typedef IntegerList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_integers(flatbuffers::Offset<flatbuffers::Vector<int64_t>> integers) {
    fbb_.AddOffset(IntegerList::VT_INTEGERS, integers);
  }
  explicit IntegerListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntegerList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntegerList>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntegerList> CreateIntegerList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> integers = 0) {
  IntegerListBuilder builder_(_fbb);
  builder_.add_integers(integers);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntegerList> CreateIntegerListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *integers = nullptr) {
  auto integers__ = integers ? _fbb.CreateVector<int64_t>(*integers) : 0;
  return noodles::CreateIntegerList(
      _fbb,
      integers__);
}

struct Real FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REAL = 4
  };
  double real() const {
    return GetField<double>(VT_REAL, 0.0);
  }
  bool mutate_real(double _real) {
    return SetField<double>(VT_REAL, _real, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_REAL) &&
           verifier.EndTable();
  }
};

struct RealBuilder {
  typedef Real Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_real(double real) {
    fbb_.AddElement<double>(Real::VT_REAL, real, 0.0);
  }
  explicit RealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Real> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Real>(end);
    return o;
  }
};

inline flatbuffers::Offset<Real> CreateReal(
    flatbuffers::FlatBufferBuilder &_fbb,
    double real = 0.0) {
  RealBuilder builder_(_fbb);
  builder_.add_real(real);
  return builder_.Finish();
}

struct RealList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REALS = 4
  };
  const flatbuffers::Vector<double> *reals() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_REALS);
  }
  flatbuffers::Vector<double> *mutable_reals() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_REALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REALS) &&
           verifier.VerifyVector(reals()) &&
           verifier.EndTable();
  }
};

struct RealListBuilder {
  typedef RealList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reals(flatbuffers::Offset<flatbuffers::Vector<double>> reals) {
    fbb_.AddOffset(RealList::VT_REALS, reals);
  }
  explicit RealListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RealList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealList>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealList> CreateRealList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> reals = 0) {
  RealListBuilder builder_(_fbb);
  builder_.add_reals(reals);
  return builder_.Finish();
}

inline flatbuffers::Offset<RealList> CreateRealListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *reals = nullptr) {
  auto reals__ = reals ? _fbb.CreateVector<double>(*reals) : 0;
  return noodles::CreateRealList(
      _fbb,
      reals__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<int8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Data::VT_DATA, data);
  }
  explicit DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Data> CreateDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return noodles::CreateData(
      _fbb,
      data__);
}

struct AnyList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyListBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct AnyListBuilder {
  typedef AnyList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>>> list) {
    fbb_.AddOffset(AnyList::VT_LIST, list);
  }
  explicit AnyListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnyList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyList>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnyList> CreateAnyList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::Any>>> list = 0) {
  AnyListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnyList> CreateAnyListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::Any>> *list = nullptr) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<noodles::Any>>(*list) : 0;
  return noodles::CreateAnyList(
      _fbb,
      list__);
}

struct AnyMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyMapBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyMapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *>(VT_ENTRIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *mutable_entries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct AnyMapBuilder {
  typedef AnyMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>>> entries) {
    fbb_.AddOffset(AnyMap::VT_ENTRIES, entries);
  }
  explicit AnyMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnyMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnyMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnyMap> CreateAnyMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MapEntry>>> entries = 0) {
  AnyMapBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnyMap> CreateAnyMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<noodles::MapEntry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfSortedTables<noodles::MapEntry>(entries) : 0;
  return noodles::CreateAnyMap(
      _fbb,
      entries__);
}

struct Any FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AnyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_TYPE = 4,
    VT_ANY = 6
  };
  noodles::AnyType any_type() const {
    return static_cast<noodles::AnyType>(GetField<uint8_t>(VT_ANY_TYPE, 0));
  }
  const void *any() const {
    return GetPointer<const void *>(VT_ANY);
  }
  template<typename T> const T *any_as() const;
  const noodles::Text *any_as_Text() const {
    return any_type() == noodles::AnyType::Text ? static_cast<const noodles::Text *>(any()) : nullptr;
  }
  const noodles::Integer *any_as_Integer() const {
    return any_type() == noodles::AnyType::Integer ? static_cast<const noodles::Integer *>(any()) : nullptr;
  }
  const noodles::IntegerList *any_as_IntegerList() const {
    return any_type() == noodles::AnyType::IntegerList ? static_cast<const noodles::IntegerList *>(any()) : nullptr;
  }
  const noodles::Real *any_as_Real() const {
    return any_type() == noodles::AnyType::Real ? static_cast<const noodles::Real *>(any()) : nullptr;
  }
  const noodles::RealList *any_as_RealList() const {
    return any_type() == noodles::AnyType::RealList ? static_cast<const noodles::RealList *>(any()) : nullptr;
  }
  const noodles::Data *any_as_Data() const {
    return any_type() == noodles::AnyType::Data ? static_cast<const noodles::Data *>(any()) : nullptr;
  }
  const noodles::AnyList *any_as_AnyList() const {
    return any_type() == noodles::AnyType::AnyList ? static_cast<const noodles::AnyList *>(any()) : nullptr;
  }
  const noodles::AnyMap *any_as_AnyMap() const {
    return any_type() == noodles::AnyType::AnyMap ? static_cast<const noodles::AnyMap *>(any()) : nullptr;
  }
  const noodles::AnyID *any_as_AnyID() const {
    return any_type() == noodles::AnyType::AnyID ? static_cast<const noodles::AnyID *>(any()) : nullptr;
  }
  void *mutable_any() {
    return GetPointer<void *>(VT_ANY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_TYPE) &&
           VerifyOffset(verifier, VT_ANY) &&
           VerifyAnyType(verifier, any(), any_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::Text *Any::any_as<noodles::Text>() const {
  return any_as_Text();
}

template<> inline const noodles::Integer *Any::any_as<noodles::Integer>() const {
  return any_as_Integer();
}

template<> inline const noodles::IntegerList *Any::any_as<noodles::IntegerList>() const {
  return any_as_IntegerList();
}

template<> inline const noodles::Real *Any::any_as<noodles::Real>() const {
  return any_as_Real();
}

template<> inline const noodles::RealList *Any::any_as<noodles::RealList>() const {
  return any_as_RealList();
}

template<> inline const noodles::Data *Any::any_as<noodles::Data>() const {
  return any_as_Data();
}

template<> inline const noodles::AnyList *Any::any_as<noodles::AnyList>() const {
  return any_as_AnyList();
}

template<> inline const noodles::AnyMap *Any::any_as<noodles::AnyMap>() const {
  return any_as_AnyMap();
}

template<> inline const noodles::AnyID *Any::any_as<noodles::AnyID>() const {
  return any_as_AnyID();
}

struct AnyBuilder {
  typedef Any Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_type(noodles::AnyType any_type) {
    fbb_.AddElement<uint8_t>(Any::VT_ANY_TYPE, static_cast<uint8_t>(any_type), 0);
  }
  void add_any(flatbuffers::Offset<void> any) {
    fbb_.AddOffset(Any::VT_ANY, any);
  }
  explicit AnyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Any> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Any>(end);
    return o;
  }
};

inline flatbuffers::Offset<Any> CreateAny(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::AnyType any_type = noodles::AnyType::NONE,
    flatbuffers::Offset<void> any = 0) {
  AnyBuilder builder_(_fbb);
  builder_.add_any(any);
  builder_.add_any_type(any_type);
  return builder_.Finish();
}

struct BufferRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferRefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_START = 6,
    VT_SIZE = 8
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint64_t>(verifier, VT_START) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct BufferRefBuilder {
  typedef BufferRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferRef::VT_ID, id);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(BufferRef::VT_START, start, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(BufferRef::VT_SIZE, size, 0);
  }
  explicit BufferRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferRef> CreateBufferRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    uint64_t start = 0,
    uint64_t size = 0) {
  BufferRefBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_start(start);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodArg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodArgBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodArgTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC = 6,
    VT_HINT = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC);
  }
  flatbuffers::String *mutable_doc() {
    return GetPointer<flatbuffers::String *>(VT_DOC);
  }
  const flatbuffers::String *hint() const {
    return GetPointer<const flatbuffers::String *>(VT_HINT);
  }
  flatbuffers::String *mutable_hint() {
    return GetPointer<flatbuffers::String *>(VT_HINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC) &&
           verifier.VerifyString(doc()) &&
           VerifyOffset(verifier, VT_HINT) &&
           verifier.VerifyString(hint()) &&
           verifier.EndTable();
  }
};

struct MethodArgBuilder {
  typedef MethodArg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodArg::VT_NAME, name);
  }
  void add_doc(flatbuffers::Offset<flatbuffers::String> doc) {
    fbb_.AddOffset(MethodArg::VT_DOC, doc);
  }
  void add_hint(flatbuffers::Offset<flatbuffers::String> hint) {
    fbb_.AddOffset(MethodArg::VT_HINT, hint);
  }
  explicit MethodArgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodArg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodArg>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodArg> CreateMethodArg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc = 0,
    flatbuffers::Offset<flatbuffers::String> hint = 0) {
  MethodArgBuilder builder_(_fbb);
  builder_.add_hint(hint);
  builder_.add_doc(doc);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodArg> CreateMethodArgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc = nullptr,
    const char *hint = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc__ = doc ? _fbb.CreateString(doc) : 0;
  auto hint__ = hint ? _fbb.CreateString(hint) : 0;
  return noodles::CreateMethodArg(
      _fbb,
      name__,
      doc__,
      hint__);
}

struct MethodCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_RETURN_DOC = 10,
    VT_ARG_DOC = 12
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::String *return_doc() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURN_DOC);
  }
  flatbuffers::String *mutable_return_doc() {
    return GetPointer<flatbuffers::String *>(VT_RETURN_DOC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_arg_doc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_RETURN_DOC) &&
           verifier.VerifyString(return_doc()) &&
           VerifyOffset(verifier, VT_ARG_DOC) &&
           verifier.VerifyVector(arg_doc()) &&
           verifier.VerifyVectorOfTables(arg_doc()) &&
           verifier.EndTable();
  }
};

struct MethodCreateBuilder {
  typedef MethodCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(MethodCreate::VT_DOCUMENTATION, documentation);
  }
  void add_return_doc(flatbuffers::Offset<flatbuffers::String> return_doc) {
    fbb_.AddOffset(MethodCreate::VT_RETURN_DOC, return_doc);
  }
  void add_arg_doc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc) {
    fbb_.AddOffset(MethodCreate::VT_ARG_DOC, arg_doc);
  }
  explicit MethodCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodCreate>(end);
    fbb_.Required(o, MethodCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodCreate> CreateMethodCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::String> return_doc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc = 0) {
  MethodCreateBuilder builder_(_fbb);
  builder_.add_arg_doc(arg_doc);
  builder_.add_return_doc(return_doc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodCreate> CreateMethodCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const char *return_doc = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto return_doc__ = return_doc ? _fbb.CreateString(return_doc) : 0;
  auto arg_doc__ = arg_doc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*arg_doc) : 0;
  return noodles::CreateMethodCreate(
      _fbb,
      id,
      name__,
      documentation__,
      return_doc__,
      arg_doc__);
}

struct MethodDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MethodDeleteBuilder {
  typedef MethodDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodDelete::VT_ID, id);
  }
  explicit MethodDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodDelete>(end);
    fbb_.Required(o, MethodDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodDelete> CreateMethodDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0) {
  MethodDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SignalCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_ARG_DOC = 10
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_arg_doc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_ARG_DOC) &&
           verifier.VerifyVector(arg_doc()) &&
           verifier.VerifyVectorOfTables(arg_doc()) &&
           verifier.EndTable();
  }
};

struct SignalCreateBuilder {
  typedef SignalCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SignalCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(SignalCreate::VT_DOCUMENTATION, documentation);
  }
  void add_arg_doc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc) {
    fbb_.AddOffset(SignalCreate::VT_ARG_DOC, arg_doc);
  }
  explicit SignalCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalCreate>(end);
    fbb_.Required(o, SignalCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalCreate> CreateSignalCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc = 0) {
  SignalCreateBuilder builder_(_fbb);
  builder_.add_arg_doc(arg_doc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalCreate> CreateSignalCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto arg_doc__ = arg_doc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*arg_doc) : 0;
  return noodles::CreateSignalCreate(
      _fbb,
      id,
      name__,
      documentation__,
      arg_doc__);
}

struct SignalDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct SignalDeleteBuilder {
  typedef SignalDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalDelete::VT_ID, id);
  }
  explicit SignalDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalDelete>(end);
    fbb_.Required(o, SignalDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalDelete> CreateSignalDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0) {
  SignalDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct EmptyDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmptyDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4
  };
  bool padding() const {
    return GetField<uint8_t>(VT_PADDING, 0) != 0;
  }
  bool mutate_padding(bool _padding) {
    return SetField<uint8_t>(VT_PADDING, static_cast<uint8_t>(_padding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PADDING) &&
           verifier.EndTable();
  }
};

struct EmptyDefinitionBuilder {
  typedef EmptyDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(bool padding) {
    fbb_.AddElement<uint8_t>(EmptyDefinition::VT_PADDING, static_cast<uint8_t>(padding), 0);
  }
  explicit EmptyDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmptyDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmptyDefinition>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmptyDefinition> CreateEmptyDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool padding = false) {
  EmptyDefinitionBuilder builder_(_fbb);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct TextDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_FONT = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *font() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT);
  }
  flatbuffers::String *mutable_font() {
    return GetPointer<flatbuffers::String *>(VT_FONT);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, .25f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, .25f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, -1.0f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, -1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_FONT) &&
           verifier.VerifyString(font()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct TextDefinitionBuilder {
  typedef TextDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextDefinition::VT_TEXT, text);
  }
  void add_font(flatbuffers::Offset<flatbuffers::String> font) {
    fbb_.AddOffset(TextDefinition::VT_FONT, font);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(TextDefinition::VT_HEIGHT, height, .25f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(TextDefinition::VT_WIDTH, width, -1.0f);
  }
  explicit TextDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextDefinition>(end);
    fbb_.Required(o, TextDefinition::VT_TEXT);
    fbb_.Required(o, TextDefinition::VT_FONT);
    return o;
  }
};

inline flatbuffers::Offset<TextDefinition> CreateTextDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> font = 0,
    float height = .25f,
    float width = -1.0f) {
  TextDefinitionBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_font(font);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextDefinition> CreateTextDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *font = nullptr,
    float height = .25f,
    float width = -1.0f) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto font__ = font ? _fbb.CreateString(font) : 0;
  return noodles::CreateTextDefinition(
      _fbb,
      text__,
      font__,
      height,
      width);
}

struct WebpageDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebpageDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebpageDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4,
    VT_HEIGHT = 6,
    VT_WIDTH = 8
  };
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, .5f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, .5f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, .5f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, .5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct WebpageDefinitionBuilder {
  typedef WebpageDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(WebpageDefinition::VT_URL, url);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(WebpageDefinition::VT_HEIGHT, height, .5f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(WebpageDefinition::VT_WIDTH, width, .5f);
  }
  explicit WebpageDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebpageDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebpageDefinition>(end);
    fbb_.Required(o, WebpageDefinition::VT_URL);
    return o;
  }
};

inline flatbuffers::Offset<WebpageDefinition> CreateWebpageDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    float height = .5f,
    float width = .5f) {
  WebpageDefinitionBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_url(url);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebpageDefinition> CreateWebpageDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr,
    float height = .5f,
    float width = .5f) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateWebpageDefinition(
      _fbb,
      url__,
      height,
      width);
}

struct RenderableDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderableDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RenderableDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4,
    VT_MESH = 6,
    VT_INSTANCES = 8,
    VT_INSTANCE_BB = 10
  };
  const noodles::MaterialID *material() const {
    return GetPointer<const noodles::MaterialID *>(VT_MATERIAL);
  }
  noodles::MaterialID *mutable_material() {
    return GetPointer<noodles::MaterialID *>(VT_MATERIAL);
  }
  const noodles::GeometryID *mesh() const {
    return GetPointer<const noodles::GeometryID *>(VT_MESH);
  }
  noodles::GeometryID *mutable_mesh() {
    return GetPointer<noodles::GeometryID *>(VT_MESH);
  }
  const flatbuffers::Vector<const noodles::Mat4 *> *instances() const {
    return GetPointer<const flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  flatbuffers::Vector<const noodles::Mat4 *> *mutable_instances() {
    return GetPointer<flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  const noodles::BoundingBox *instance_bb() const {
    return GetStruct<const noodles::BoundingBox *>(VT_INSTANCE_BB);
  }
  noodles::BoundingBox *mutable_instance_bb() {
    return GetStruct<noodles::BoundingBox *>(VT_INSTANCE_BB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           VerifyOffsetRequired(verifier, VT_MESH) &&
           verifier.VerifyTable(mesh()) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_INSTANCE_BB) &&
           verifier.EndTable();
  }
};

struct RenderableDefinitionBuilder {
  typedef RenderableDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material(flatbuffers::Offset<noodles::MaterialID> material) {
    fbb_.AddOffset(RenderableDefinition::VT_MATERIAL, material);
  }
  void add_mesh(flatbuffers::Offset<noodles::GeometryID> mesh) {
    fbb_.AddOffset(RenderableDefinition::VT_MESH, mesh);
  }
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances) {
    fbb_.AddOffset(RenderableDefinition::VT_INSTANCES, instances);
  }
  void add_instance_bb(const noodles::BoundingBox *instance_bb) {
    fbb_.AddStruct(RenderableDefinition::VT_INSTANCE_BB, instance_bb);
  }
  explicit RenderableDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderableDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderableDefinition>(end);
    fbb_.Required(o, RenderableDefinition::VT_MATERIAL);
    fbb_.Required(o, RenderableDefinition::VT_MESH);
    return o;
  }
};

inline flatbuffers::Offset<RenderableDefinition> CreateRenderableDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances = 0,
    const noodles::BoundingBox *instance_bb = 0) {
  RenderableDefinitionBuilder builder_(_fbb);
  builder_.add_instance_bb(instance_bb);
  builder_.add_instances(instances);
  builder_.add_mesh(mesh);
  builder_.add_material(material);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderableDefinition> CreateRenderableDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    const std::vector<noodles::Mat4> *instances = nullptr,
    const noodles::BoundingBox *instance_bb = 0) {
  auto instances__ = instances ? _fbb.CreateVectorOfStructs<noodles::Mat4>(*instances) : 0;
  return noodles::CreateRenderableDefinition(
      _fbb,
      material,
      mesh,
      instances__,
      instance_bb);
}

struct ObjectCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_PARENT = 8,
    VT_TRANSFORM = 10,
    VT_DEFINITION_TYPE = 12,
    VT_DEFINITION = 14,
    VT_LIGHTS = 16,
    VT_TABLES = 18,
    VT_PLOTS = 20,
    VT_TAGS = 22,
    VT_METHODS_LIST = 24,
    VT_SIGNALS_LIST = 26,
    VT_INFLUENCE = 28,
    VT_VISIBILITY = 30
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const noodles::ObjectID *parent() const {
    return GetPointer<const noodles::ObjectID *>(VT_PARENT);
  }
  noodles::ObjectID *mutable_parent() {
    return GetPointer<noodles::ObjectID *>(VT_PARENT);
  }
  const noodles::Mat4 *transform() const {
    return GetStruct<const noodles::Mat4 *>(VT_TRANSFORM);
  }
  noodles::Mat4 *mutable_transform() {
    return GetStruct<noodles::Mat4 *>(VT_TRANSFORM);
  }
  noodles::ObjectDefinition definition_type() const {
    return static_cast<noodles::ObjectDefinition>(GetField<uint8_t>(VT_DEFINITION_TYPE, 0));
  }
  const void *definition() const {
    return GetPointer<const void *>(VT_DEFINITION);
  }
  template<typename T> const T *definition_as() const;
  const noodles::EmptyDefinition *definition_as_EmptyDefinition() const {
    return definition_type() == noodles::ObjectDefinition::EmptyDefinition ? static_cast<const noodles::EmptyDefinition *>(definition()) : nullptr;
  }
  const noodles::TextDefinition *definition_as_TextDefinition() const {
    return definition_type() == noodles::ObjectDefinition::TextDefinition ? static_cast<const noodles::TextDefinition *>(definition()) : nullptr;
  }
  const noodles::WebpageDefinition *definition_as_WebpageDefinition() const {
    return definition_type() == noodles::ObjectDefinition::WebpageDefinition ? static_cast<const noodles::WebpageDefinition *>(definition()) : nullptr;
  }
  const noodles::RenderableDefinition *definition_as_RenderableDefinition() const {
    return definition_type() == noodles::ObjectDefinition::RenderableDefinition ? static_cast<const noodles::RenderableDefinition *>(definition()) : nullptr;
  }
  void *mutable_definition() {
    return GetPointer<void *>(VT_DEFINITION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *lights() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *mutable_lights() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *mutable_tables() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *plots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *>(VT_PLOTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *mutable_plots() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *>(VT_PLOTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_tags() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  const noodles::BoundingBox *influence() const {
    return GetStruct<const noodles::BoundingBox *>(VT_INFLUENCE);
  }
  noodles::BoundingBox *mutable_influence() {
    return GetStruct<noodles::BoundingBox *>(VT_INFLUENCE);
  }
  const noodles::ObjectVisibility *visibility() const {
    return GetStruct<const noodles::ObjectVisibility *>(VT_VISIBILITY);
  }
  noodles::ObjectVisibility *mutable_visibility() {
    return GetStruct<noodles::ObjectVisibility *>(VT_VISIBILITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARENT) &&
           verifier.VerifyTable(parent()) &&
           VerifyField<noodles::Mat4>(verifier, VT_TRANSFORM) &&
           VerifyField<uint8_t>(verifier, VT_DEFINITION_TYPE) &&
           VerifyOffset(verifier, VT_DEFINITION) &&
           VerifyObjectDefinition(verifier, definition(), definition_type()) &&
           VerifyOffset(verifier, VT_LIGHTS) &&
           verifier.VerifyVector(lights()) &&
           verifier.VerifyVectorOfTables(lights()) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_PLOTS) &&
           verifier.VerifyVector(plots()) &&
           verifier.VerifyVectorOfTables(plots()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_INFLUENCE) &&
           VerifyField<noodles::ObjectVisibility>(verifier, VT_VISIBILITY) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::EmptyDefinition *ObjectCreateUpdate::definition_as<noodles::EmptyDefinition>() const {
  return definition_as_EmptyDefinition();
}

template<> inline const noodles::TextDefinition *ObjectCreateUpdate::definition_as<noodles::TextDefinition>() const {
  return definition_as_TextDefinition();
}

template<> inline const noodles::WebpageDefinition *ObjectCreateUpdate::definition_as<noodles::WebpageDefinition>() const {
  return definition_as_WebpageDefinition();
}

template<> inline const noodles::RenderableDefinition *ObjectCreateUpdate::definition_as<noodles::RenderableDefinition>() const {
  return definition_as_RenderableDefinition();
}

struct ObjectCreateUpdateBuilder {
  typedef ObjectCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_NAME, name);
  }
  void add_parent(flatbuffers::Offset<noodles::ObjectID> parent) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_PARENT, parent);
  }
  void add_transform(const noodles::Mat4 *transform) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_TRANSFORM, transform);
  }
  void add_definition_type(noodles::ObjectDefinition definition_type) {
    fbb_.AddElement<uint8_t>(ObjectCreateUpdate::VT_DEFINITION_TYPE, static_cast<uint8_t>(definition_type), 0);
  }
  void add_definition(flatbuffers::Offset<void> definition) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_DEFINITION, definition);
  }
  void add_lights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_LIGHTS, lights);
  }
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TABLES, tables);
  }
  void add_plots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>>> plots) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_PLOTS, plots);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TAGS, tags);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  void add_influence(const noodles::BoundingBox *influence) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_INFLUENCE, influence);
  }
  void add_visibility(const noodles::ObjectVisibility *visibility) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_VISIBILITY, visibility);
  }
  explicit ObjectCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectCreateUpdate>(end);
    fbb_.Required(o, ObjectCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    noodles::ObjectDefinition definition_type = noodles::ObjectDefinition::NONE,
    flatbuffers::Offset<void> definition = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>>> plots = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0,
    const noodles::BoundingBox *influence = 0,
    const noodles::ObjectVisibility *visibility = 0) {
  ObjectCreateUpdateBuilder builder_(_fbb);
  builder_.add_visibility(visibility);
  builder_.add_influence(influence);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_tags(tags);
  builder_.add_plots(plots);
  builder_.add_tables(tables);
  builder_.add_lights(lights);
  builder_.add_definition(definition);
  builder_.add_transform(transform);
  builder_.add_parent(parent);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_definition_type(definition_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    const char *name = nullptr,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    noodles::ObjectDefinition definition_type = noodles::ObjectDefinition::NONE,
    flatbuffers::Offset<void> definition = 0,
    const std::vector<flatbuffers::Offset<noodles::LightID>> *lights = nullptr,
    const std::vector<flatbuffers::Offset<noodles::TableID>> *tables = nullptr,
    const std::vector<flatbuffers::Offset<noodles::PlotID>> *plots = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr,
    const noodles::BoundingBox *influence = 0,
    const noodles::ObjectVisibility *visibility = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lights__ = lights ? _fbb.CreateVector<flatbuffers::Offset<noodles::LightID>>(*lights) : 0;
  auto tables__ = tables ? _fbb.CreateVector<flatbuffers::Offset<noodles::TableID>>(*tables) : 0;
  auto plots__ = plots ? _fbb.CreateVector<flatbuffers::Offset<noodles::PlotID>>(*plots) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateObjectCreateUpdate(
      _fbb,
      id,
      name__,
      parent,
      transform,
      definition_type,
      definition,
      lights__,
      tables__,
      plots__,
      tags__,
      methods_list__,
      signals_list__,
      influence,
      visibility);
}

struct ObjectDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct ObjectDeleteBuilder {
  typedef ObjectDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectDelete::VT_ID, id);
  }
  explicit ObjectDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectDelete>(end);
    fbb_.Required(o, ObjectDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectDelete> CreateObjectDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0) {
  ObjectDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SimplePlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimplePlotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SimplePlotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFINITION = 4
  };
  const flatbuffers::String *definition() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFINITION);
  }
  flatbuffers::String *mutable_definition() {
    return GetPointer<flatbuffers::String *>(VT_DEFINITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DEFINITION) &&
           verifier.VerifyString(definition()) &&
           verifier.EndTable();
  }
};

struct SimplePlotBuilder {
  typedef SimplePlot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_definition(flatbuffers::Offset<flatbuffers::String> definition) {
    fbb_.AddOffset(SimplePlot::VT_DEFINITION, definition);
  }
  explicit SimplePlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SimplePlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimplePlot>(end);
    fbb_.Required(o, SimplePlot::VT_DEFINITION);
    return o;
  }
};

inline flatbuffers::Offset<SimplePlot> CreateSimplePlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> definition = 0) {
  SimplePlotBuilder builder_(_fbb);
  builder_.add_definition(definition);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimplePlot> CreateSimplePlotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *definition = nullptr) {
  auto definition__ = definition ? _fbb.CreateString(definition) : 0;
  return noodles::CreateSimplePlot(
      _fbb,
      definition__);
}

struct URLPlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef URLPlotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return URLPlotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4
  };
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           verifier.EndTable();
  }
};

struct URLPlotBuilder {
  typedef URLPlot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(URLPlot::VT_URL, url);
  }
  explicit URLPlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<URLPlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<URLPlot>(end);
    fbb_.Required(o, URLPlot::VT_URL);
    return o;
  }
};

inline flatbuffers::Offset<URLPlot> CreateURLPlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> url = 0) {
  URLPlotBuilder builder_(_fbb);
  builder_.add_url(url);
  return builder_.Finish();
}

inline flatbuffers::Offset<URLPlot> CreateURLPlotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateURLPlot(
      _fbb,
      url__);
}

struct PlotCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlotCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlotCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TABLE = 6,
    VT_TYPE_TYPE = 8,
    VT_TYPE = 10,
    VT_METHODS_LIST = 12,
    VT_SIGNALS_LIST = 14
  };
  const noodles::PlotID *id() const {
    return GetPointer<const noodles::PlotID *>(VT_ID);
  }
  noodles::PlotID *mutable_id() {
    return GetPointer<noodles::PlotID *>(VT_ID);
  }
  const noodles::TableID *table() const {
    return GetPointer<const noodles::TableID *>(VT_TABLE);
  }
  noodles::TableID *mutable_table() {
    return GetPointer<noodles::TableID *>(VT_TABLE);
  }
  noodles::PlotType type_type() const {
    return static_cast<noodles::PlotType>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const noodles::SimplePlot *type_as_SimplePlot() const {
    return type_type() == noodles::PlotType::SimplePlot ? static_cast<const noodles::SimplePlot *>(type()) : nullptr;
  }
  const noodles::URLPlot *type_as_URLPlot() const {
    return type_type() == noodles::PlotType::URLPlot ? static_cast<const noodles::URLPlot *>(type()) : nullptr;
  }
  void *mutable_type() {
    return GetPointer<void *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_TABLE) &&
           verifier.VerifyTable(table()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyPlotType(verifier, type(), type_type()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::SimplePlot *PlotCreateUpdate::type_as<noodles::SimplePlot>() const {
  return type_as_SimplePlot();
}

template<> inline const noodles::URLPlot *PlotCreateUpdate::type_as<noodles::URLPlot>() const {
  return type_as_URLPlot();
}

struct PlotCreateUpdateBuilder {
  typedef PlotCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::PlotID> id) {
    fbb_.AddOffset(PlotCreateUpdate::VT_ID, id);
  }
  void add_table(flatbuffers::Offset<noodles::TableID> table) {
    fbb_.AddOffset(PlotCreateUpdate::VT_TABLE, table);
  }
  void add_type_type(noodles::PlotType type_type) {
    fbb_.AddElement<uint8_t>(PlotCreateUpdate::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(PlotCreateUpdate::VT_TYPE, type);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(PlotCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(PlotCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit PlotCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlotCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlotCreateUpdate>(end);
    fbb_.Required(o, PlotCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<PlotCreateUpdate> CreatePlotCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0,
    flatbuffers::Offset<noodles::TableID> table = 0,
    noodles::PlotType type_type = noodles::PlotType::NONE,
    flatbuffers::Offset<void> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  PlotCreateUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_type(type);
  builder_.add_table(table);
  builder_.add_id(id);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlotCreateUpdate> CreatePlotCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0,
    flatbuffers::Offset<noodles::TableID> table = 0,
    noodles::PlotType type_type = noodles::PlotType::NONE,
    flatbuffers::Offset<void> type = 0,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreatePlotCreateUpdate(
      _fbb,
      id,
      table,
      type_type,
      type,
      methods_list__,
      signals_list__);
}

struct PlotDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlotDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlotDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::PlotID *id() const {
    return GetPointer<const noodles::PlotID *>(VT_ID);
  }
  noodles::PlotID *mutable_id() {
    return GetPointer<noodles::PlotID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct PlotDeleteBuilder {
  typedef PlotDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::PlotID> id) {
    fbb_.AddOffset(PlotDelete::VT_ID, id);
  }
  explicit PlotDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlotDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlotDelete>(end);
    fbb_.Required(o, PlotDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<PlotDelete> CreatePlotDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0) {
  PlotDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct BufferCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BYTES = 6,
    VT_URL = 8,
    VT_SIZE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  const flatbuffers::Vector<int8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  flatbuffers::Vector<int8_t> *mutable_bytes() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct BufferCreateBuilder {
  typedef BufferCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferCreate::VT_ID, id);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes) {
    fbb_.AddOffset(BufferCreate::VT_BYTES, bytes);
  }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(BufferCreate::VT_URL, url);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(BufferCreate::VT_SIZE, size, 0);
  }
  explicit BufferCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferCreate>(end);
    fbb_.Required(o, BufferCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferCreate> CreateBufferCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    uint64_t size = 0) {
  BufferCreateBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_url(url);
  builder_.add_bytes(bytes);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<BufferCreate> CreateBufferCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    const std::vector<int8_t> *bytes = nullptr,
    const char *url = nullptr,
    uint64_t size = 0) {
  auto bytes__ = bytes ? _fbb.CreateVector<int8_t>(*bytes) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateBufferCreate(
      _fbb,
      id,
      bytes__,
      url__,
      size);
}

struct BufferDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct BufferDeleteBuilder {
  typedef BufferDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferDelete::VT_ID, id);
  }
  explicit BufferDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferDelete>(end);
    fbb_.Required(o, BufferDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferDelete> CreateBufferDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0) {
  BufferDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MaterialCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_METALLIC = 8,
    VT_ROUGHNESS = 10,
    VT_USE_BLENDING = 12,
    VT_TEXTURE_ID = 14
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  const noodles::Vec4 *color() const {
    return GetStruct<const noodles::Vec4 *>(VT_COLOR);
  }
  noodles::Vec4 *mutable_color() {
    return GetStruct<noodles::Vec4 *>(VT_COLOR);
  }
  float metallic() const {
    return GetField<float>(VT_METALLIC, 0.0f);
  }
  bool mutate_metallic(float _metallic) {
    return SetField<float>(VT_METALLIC, _metallic, 0.0f);
  }
  float roughness() const {
    return GetField<float>(VT_ROUGHNESS, 0.0f);
  }
  bool mutate_roughness(float _roughness) {
    return SetField<float>(VT_ROUGHNESS, _roughness, 0.0f);
  }
  bool use_blending() const {
    return GetField<uint8_t>(VT_USE_BLENDING, 0) != 0;
  }
  bool mutate_use_blending(bool _use_blending) {
    return SetField<uint8_t>(VT_USE_BLENDING, static_cast<uint8_t>(_use_blending), 0);
  }
  const noodles::TextureID *texture_id() const {
    return GetPointer<const noodles::TextureID *>(VT_TEXTURE_ID);
  }
  noodles::TextureID *mutable_texture_id() {
    return GetPointer<noodles::TextureID *>(VT_TEXTURE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::Vec4>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_METALLIC) &&
           VerifyField<float>(verifier, VT_ROUGHNESS) &&
           VerifyField<uint8_t>(verifier, VT_USE_BLENDING) &&
           VerifyOffset(verifier, VT_TEXTURE_ID) &&
           verifier.VerifyTable(texture_id()) &&
           verifier.EndTable();
  }
};

struct MaterialCreateUpdateBuilder {
  typedef MaterialCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::Vec4 *color) {
    fbb_.AddStruct(MaterialCreateUpdate::VT_COLOR, color);
  }
  void add_metallic(float metallic) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_METALLIC, metallic, 0.0f);
  }
  void add_roughness(float roughness) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_ROUGHNESS, roughness, 0.0f);
  }
  void add_use_blending(bool use_blending) {
    fbb_.AddElement<uint8_t>(MaterialCreateUpdate::VT_USE_BLENDING, static_cast<uint8_t>(use_blending), 0);
  }
  void add_texture_id(flatbuffers::Offset<noodles::TextureID> texture_id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_TEXTURE_ID, texture_id);
  }
  explicit MaterialCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialCreateUpdate>(end);
    fbb_.Required(o, MaterialCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialCreateUpdate> CreateMaterialCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0,
    const noodles::Vec4 *color = 0,
    float metallic = 0.0f,
    float roughness = 0.0f,
    bool use_blending = false,
    flatbuffers::Offset<noodles::TextureID> texture_id = 0) {
  MaterialCreateUpdateBuilder builder_(_fbb);
  builder_.add_texture_id(texture_id);
  builder_.add_roughness(roughness);
  builder_.add_metallic(metallic);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_use_blending(use_blending);
  return builder_.Finish();
}

struct MaterialDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MaterialDeleteBuilder {
  typedef MaterialDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialDelete::VT_ID, id);
  }
  explicit MaterialDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialDelete>(end);
    fbb_.Required(o, MaterialDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialDelete> CreateMaterialDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0) {
  MaterialDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REFERENCE = 6
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  const noodles::BufferRef *reference() const {
    return GetPointer<const noodles::BufferRef *>(VT_REFERENCE);
  }
  noodles::BufferRef *mutable_reference() {
    return GetPointer<noodles::BufferRef *>(VT_REFERENCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE) &&
           verifier.VerifyTable(reference()) &&
           verifier.EndTable();
  }
};

struct TextureCreateUpdateBuilder {
  typedef TextureCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureCreateUpdate::VT_ID, id);
  }
  void add_reference(flatbuffers::Offset<noodles::BufferRef> reference) {
    fbb_.AddOffset(TextureCreateUpdate::VT_REFERENCE, reference);
  }
  explicit TextureCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureCreateUpdate>(end);
    fbb_.Required(o, TextureCreateUpdate::VT_ID);
    fbb_.Required(o, TextureCreateUpdate::VT_REFERENCE);
    return o;
  }
};

inline flatbuffers::Offset<TextureCreateUpdate> CreateTextureCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0,
    flatbuffers::Offset<noodles::BufferRef> reference = 0) {
  TextureCreateUpdateBuilder builder_(_fbb);
  builder_.add_reference(reference);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TextureDeleteBuilder {
  typedef TextureDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureDelete::VT_ID, id);
  }
  explicit TextureDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureDelete>(end);
    fbb_.Required(o, TextureDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TextureDelete> CreateTextureDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0) {
  TextureDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct LightCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_INTENSITY = 8,
    VT_SPATIAL = 10,
    VT_LIGHT_TYPE = 12
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  const noodles::RGB *color() const {
    return GetStruct<const noodles::RGB *>(VT_COLOR);
  }
  noodles::RGB *mutable_color() {
    return GetStruct<noodles::RGB *>(VT_COLOR);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool mutate_intensity(float _intensity) {
    return SetField<float>(VT_INTENSITY, _intensity, 0.0f);
  }
  const noodles::Vec4 *spatial() const {
    return GetStruct<const noodles::Vec4 *>(VT_SPATIAL);
  }
  noodles::Vec4 *mutable_spatial() {
    return GetStruct<noodles::Vec4 *>(VT_SPATIAL);
  }
  noodles::LightType light_type() const {
    return static_cast<noodles::LightType>(GetField<int8_t>(VT_LIGHT_TYPE, 0));
  }
  bool mutate_light_type(noodles::LightType _light_type) {
    return SetField<int8_t>(VT_LIGHT_TYPE, static_cast<int8_t>(_light_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::RGB>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           VerifyField<noodles::Vec4>(verifier, VT_SPATIAL) &&
           VerifyField<int8_t>(verifier, VT_LIGHT_TYPE) &&
           verifier.EndTable();
  }
};

struct LightCreateUpdateBuilder {
  typedef LightCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::RGB *color) {
    fbb_.AddStruct(LightCreateUpdate::VT_COLOR, color);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightCreateUpdate::VT_INTENSITY, intensity, 0.0f);
  }
  void add_spatial(const noodles::Vec4 *spatial) {
    fbb_.AddStruct(LightCreateUpdate::VT_SPATIAL, spatial);
  }
  void add_light_type(noodles::LightType light_type) {
    fbb_.AddElement<int8_t>(LightCreateUpdate::VT_LIGHT_TYPE, static_cast<int8_t>(light_type), 0);
  }
  explicit LightCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LightCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightCreateUpdate>(end);
    fbb_.Required(o, LightCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightCreateUpdate> CreateLightCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0,
    const noodles::RGB *color = 0,
    float intensity = 0.0f,
    const noodles::Vec4 *spatial = 0,
    noodles::LightType light_type = noodles::LightType::POINT) {
  LightCreateUpdateBuilder builder_(_fbb);
  builder_.add_spatial(spatial);
  builder_.add_intensity(intensity);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_light_type(light_type);
  return builder_.Finish();
}

struct LightDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct LightDeleteBuilder {
  typedef LightDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightDelete::VT_ID, id);
  }
  explicit LightDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LightDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightDelete>(end);
    fbb_.Required(o, LightDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightDelete> CreateLightDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0) {
  LightDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ComponentRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ComponentRefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ComponentRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_START = 6,
    VT_SIZE = 8,
    VT_STRIDE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  uint64_t stride() const {
    return GetField<uint64_t>(VT_STRIDE, 0);
  }
  bool mutate_stride(uint64_t _stride) {
    return SetField<uint64_t>(VT_STRIDE, _stride, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint64_t>(verifier, VT_START) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_STRIDE) &&
           verifier.EndTable();
  }
};

struct ComponentRefBuilder {
  typedef ComponentRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(ComponentRef::VT_ID, id);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_START, start, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_SIZE, size, 0);
  }
  void add_stride(uint64_t stride) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_STRIDE, stride, 0);
  }
  explicit ComponentRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ComponentRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComponentRef>(end);
    fbb_.Required(o, ComponentRef::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ComponentRef> CreateComponentRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    uint64_t start = 0,
    uint64_t size = 0,
    uint64_t stride = 0) {
  ComponentRefBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_size(size);
  builder_.add_start(start);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_EXTENT = 6,
    VT_POSITIONS = 8,
    VT_NORMALS = 10,
    VT_TEX_COORDS = 12,
    VT_COLORS = 14,
    VT_LINES = 16,
    VT_TRIANGLES = 18
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  const noodles::BoundingBox *extent() const {
    return GetStruct<const noodles::BoundingBox *>(VT_EXTENT);
  }
  noodles::BoundingBox *mutable_extent() {
    return GetStruct<noodles::BoundingBox *>(VT_EXTENT);
  }
  const noodles::ComponentRef *positions() const {
    return GetPointer<const noodles::ComponentRef *>(VT_POSITIONS);
  }
  noodles::ComponentRef *mutable_positions() {
    return GetPointer<noodles::ComponentRef *>(VT_POSITIONS);
  }
  const noodles::ComponentRef *normals() const {
    return GetPointer<const noodles::ComponentRef *>(VT_NORMALS);
  }
  noodles::ComponentRef *mutable_normals() {
    return GetPointer<noodles::ComponentRef *>(VT_NORMALS);
  }
  const noodles::ComponentRef *tex_coords() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TEX_COORDS);
  }
  noodles::ComponentRef *mutable_tex_coords() {
    return GetPointer<noodles::ComponentRef *>(VT_TEX_COORDS);
  }
  const noodles::ComponentRef *colors() const {
    return GetPointer<const noodles::ComponentRef *>(VT_COLORS);
  }
  noodles::ComponentRef *mutable_colors() {
    return GetPointer<noodles::ComponentRef *>(VT_COLORS);
  }
  const noodles::ComponentRef *lines() const {
    return GetPointer<const noodles::ComponentRef *>(VT_LINES);
  }
  noodles::ComponentRef *mutable_lines() {
    return GetPointer<noodles::ComponentRef *>(VT_LINES);
  }
  const noodles::ComponentRef *triangles() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TRIANGLES);
  }
  noodles::ComponentRef *mutable_triangles() {
    return GetPointer<noodles::ComponentRef *>(VT_TRIANGLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_EXTENT) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyTable(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyTable(normals()) &&
           VerifyOffset(verifier, VT_TEX_COORDS) &&
           verifier.VerifyTable(tex_coords()) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyTable(colors()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyTable(lines()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyTable(triangles()) &&
           verifier.EndTable();
  }
};

struct GeometryCreateBuilder {
  typedef GeometryCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryCreate::VT_ID, id);
  }
  void add_extent(const noodles::BoundingBox *extent) {
    fbb_.AddStruct(GeometryCreate::VT_EXTENT, extent);
  }
  void add_positions(flatbuffers::Offset<noodles::ComponentRef> positions) {
    fbb_.AddOffset(GeometryCreate::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<noodles::ComponentRef> normals) {
    fbb_.AddOffset(GeometryCreate::VT_NORMALS, normals);
  }
  void add_tex_coords(flatbuffers::Offset<noodles::ComponentRef> tex_coords) {
    fbb_.AddOffset(GeometryCreate::VT_TEX_COORDS, tex_coords);
  }
  void add_colors(flatbuffers::Offset<noodles::ComponentRef> colors) {
    fbb_.AddOffset(GeometryCreate::VT_COLORS, colors);
  }
  void add_lines(flatbuffers::Offset<noodles::ComponentRef> lines) {
    fbb_.AddOffset(GeometryCreate::VT_LINES, lines);
  }
  void add_triangles(flatbuffers::Offset<noodles::ComponentRef> triangles) {
    fbb_.AddOffset(GeometryCreate::VT_TRIANGLES, triangles);
  }
  explicit GeometryCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryCreate>(end);
    fbb_.Required(o, GeometryCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryCreate> CreateGeometryCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0,
    const noodles::BoundingBox *extent = 0,
    flatbuffers::Offset<noodles::ComponentRef> positions = 0,
    flatbuffers::Offset<noodles::ComponentRef> normals = 0,
    flatbuffers::Offset<noodles::ComponentRef> tex_coords = 0,
    flatbuffers::Offset<noodles::ComponentRef> colors = 0,
    flatbuffers::Offset<noodles::ComponentRef> lines = 0,
    flatbuffers::Offset<noodles::ComponentRef> triangles = 0) {
  GeometryCreateBuilder builder_(_fbb);
  builder_.add_triangles(triangles);
  builder_.add_lines(lines);
  builder_.add_colors(colors);
  builder_.add_tex_coords(tex_coords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  builder_.add_extent(extent);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct GeometryDeleteBuilder {
  typedef GeometryDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryDelete::VT_ID, id);
  }
  explicit GeometryDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDelete>(end);
    fbb_.Required(o, GeometryDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDelete> CreateGeometryDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0) {
  GeometryDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TableCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_META = 8,
    VT_METHODS_LIST = 10,
    VT_SIGNALS_LIST = 12
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *meta() const {
    return GetPointer<const flatbuffers::String *>(VT_META);
  }
  flatbuffers::String *mutable_meta() {
    return GetPointer<flatbuffers::String *>(VT_META);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyString(meta()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct TableCreateUpdateBuilder {
  typedef TableCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableCreateUpdate::VT_NAME, name);
  }
  void add_meta(flatbuffers::Offset<flatbuffers::String> meta) {
    fbb_.AddOffset(TableCreateUpdate::VT_META, meta);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit TableCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableCreateUpdate>(end);
    fbb_.Required(o, TableCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> meta = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  TableCreateUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_meta(meta);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    const char *name = nullptr,
    const char *meta = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto meta__ = meta ? _fbb.CreateString(meta) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateTableCreateUpdate(
      _fbb,
      id,
      name__,
      meta__,
      methods_list__,
      signals_list__);
}

struct TableDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TableDeleteBuilder {
  typedef TableDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableDelete::VT_ID, id);
  }
  explicit TableDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableDelete>(end);
    fbb_.Required(o, TableDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableDelete> CreateTableDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0) {
  TableDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct DocumentUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS_LIST = 4,
    VT_SIGNALS_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct DocumentUpdateBuilder {
  typedef DocumentUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(DocumentUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(DocumentUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit DocumentUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DocumentUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  DocumentUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateDocumentUpdate(
      _fbb,
      methods_list__,
      signals_list__);
}

struct DocumentReset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentResetBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentResetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4
  };
  bool padding() const {
    return GetField<uint8_t>(VT_PADDING, 0) != 0;
  }
  bool mutate_padding(bool _padding) {
    return SetField<uint8_t>(VT_PADDING, static_cast<uint8_t>(_padding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PADDING) &&
           verifier.EndTable();
  }
};

struct DocumentResetBuilder {
  typedef DocumentReset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(bool padding) {
    fbb_.AddElement<uint8_t>(DocumentReset::VT_PADDING, static_cast<uint8_t>(padding), 0);
  }
  explicit DocumentResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DocumentReset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentReset>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentReset> CreateDocumentReset(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool padding = false) {
  DocumentResetBuilder builder_(_fbb);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct SignalInvoke FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalInvokeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalInvokeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ON_OBJECT = 6,
    VT_ON_TABLE = 8,
    VT_ON_PLOT = 10,
    VT_SIGNAL_DATA = 12
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const noodles::ObjectID *on_object() const {
    return GetPointer<const noodles::ObjectID *>(VT_ON_OBJECT);
  }
  noodles::ObjectID *mutable_on_object() {
    return GetPointer<noodles::ObjectID *>(VT_ON_OBJECT);
  }
  const noodles::TableID *on_table() const {
    return GetPointer<const noodles::TableID *>(VT_ON_TABLE);
  }
  noodles::TableID *mutable_on_table() {
    return GetPointer<noodles::TableID *>(VT_ON_TABLE);
  }
  const noodles::PlotID *on_plot() const {
    return GetPointer<const noodles::PlotID *>(VT_ON_PLOT);
  }
  noodles::PlotID *mutable_on_plot() {
    return GetPointer<noodles::PlotID *>(VT_ON_PLOT);
  }
  const noodles::AnyList *signal_data() const {
    return GetPointer<const noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  noodles::AnyList *mutable_signal_data() {
    return GetPointer<noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_ON_OBJECT) &&
           verifier.VerifyTable(on_object()) &&
           VerifyOffset(verifier, VT_ON_TABLE) &&
           verifier.VerifyTable(on_table()) &&
           VerifyOffset(verifier, VT_ON_PLOT) &&
           verifier.VerifyTable(on_plot()) &&
           VerifyOffset(verifier, VT_SIGNAL_DATA) &&
           verifier.VerifyTable(signal_data()) &&
           verifier.EndTable();
  }
};

struct SignalInvokeBuilder {
  typedef SignalInvoke Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalInvoke::VT_ID, id);
  }
  void add_on_object(flatbuffers::Offset<noodles::ObjectID> on_object) {
    fbb_.AddOffset(SignalInvoke::VT_ON_OBJECT, on_object);
  }
  void add_on_table(flatbuffers::Offset<noodles::TableID> on_table) {
    fbb_.AddOffset(SignalInvoke::VT_ON_TABLE, on_table);
  }
  void add_on_plot(flatbuffers::Offset<noodles::PlotID> on_plot) {
    fbb_.AddOffset(SignalInvoke::VT_ON_PLOT, on_plot);
  }
  void add_signal_data(flatbuffers::Offset<noodles::AnyList> signal_data) {
    fbb_.AddOffset(SignalInvoke::VT_SIGNAL_DATA, signal_data);
  }
  explicit SignalInvokeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalInvoke> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalInvoke>(end);
    fbb_.Required(o, SignalInvoke::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalInvoke> CreateSignalInvoke(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    flatbuffers::Offset<noodles::AnyList> signal_data = 0) {
  SignalInvokeBuilder builder_(_fbb);
  builder_.add_signal_data(signal_data);
  builder_.add_on_plot(on_plot);
  builder_.add_on_table(on_table);
  builder_.add_on_object(on_object);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodExceptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodExceptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  int64_t code() const {
    return GetField<int64_t>(VT_CODE, 0);
  }
  bool mutate_code(int64_t _code) {
    return SetField<int64_t>(VT_CODE, _code, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  const noodles::Any *data() const {
    return GetPointer<const noodles::Any *>(VT_DATA);
  }
  noodles::Any *mutable_data() {
    return GetPointer<noodles::Any *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct MethodExceptionBuilder {
  typedef MethodException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int64_t code) {
    fbb_.AddElement<int64_t>(MethodException::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(MethodException::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<noodles::Any> data) {
    fbb_.AddOffset(MethodException::VT_DATA, data);
  }
  explicit MethodExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodException>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodException> CreateMethodException(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<noodles::Any> data = 0) {
  MethodExceptionBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodException> CreateMethodExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    const char *message = nullptr,
    flatbuffers::Offset<noodles::Any> data = 0) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return noodles::CreateMethodException(
      _fbb,
      code,
      message__,
      data);
}

struct MethodReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodReplyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodReplyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVOKE_IDENT = 4,
    VT_METHOD_DATA = 6,
    VT_METHOD_EXCEPTION = 8
  };
  const flatbuffers::String *invoke_ident() const {
    return GetPointer<const flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  flatbuffers::String *mutable_invoke_ident() {
    return GetPointer<flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  const noodles::Any *method_data() const {
    return GetPointer<const noodles::Any *>(VT_METHOD_DATA);
  }
  noodles::Any *mutable_method_data() {
    return GetPointer<noodles::Any *>(VT_METHOD_DATA);
  }
  const noodles::MethodException *method_exception() const {
    return GetPointer<const noodles::MethodException *>(VT_METHOD_EXCEPTION);
  }
  noodles::MethodException *mutable_method_exception() {
    return GetPointer<noodles::MethodException *>(VT_METHOD_EXCEPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INVOKE_IDENT) &&
           verifier.VerifyString(invoke_ident()) &&
           VerifyOffset(verifier, VT_METHOD_DATA) &&
           verifier.VerifyTable(method_data()) &&
           VerifyOffset(verifier, VT_METHOD_EXCEPTION) &&
           verifier.VerifyTable(method_exception()) &&
           verifier.EndTable();
  }
};

struct MethodReplyBuilder {
  typedef MethodReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_invoke_ident(flatbuffers::Offset<flatbuffers::String> invoke_ident) {
    fbb_.AddOffset(MethodReply::VT_INVOKE_IDENT, invoke_ident);
  }
  void add_method_data(flatbuffers::Offset<noodles::Any> method_data) {
    fbb_.AddOffset(MethodReply::VT_METHOD_DATA, method_data);
  }
  void add_method_exception(flatbuffers::Offset<noodles::MethodException> method_exception) {
    fbb_.AddOffset(MethodReply::VT_METHOD_EXCEPTION, method_exception);
  }
  explicit MethodReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodReply>(end);
    fbb_.Required(o, MethodReply::VT_INVOKE_IDENT);
    return o;
  }
};

inline flatbuffers::Offset<MethodReply> CreateMethodReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> invoke_ident = 0,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    flatbuffers::Offset<noodles::MethodException> method_exception = 0) {
  MethodReplyBuilder builder_(_fbb);
  builder_.add_method_exception(method_exception);
  builder_.add_method_data(method_data);
  builder_.add_invoke_ident(invoke_ident);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodReply> CreateMethodReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *invoke_ident = nullptr,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    flatbuffers::Offset<noodles::MethodException> method_exception = 0) {
  auto invoke_ident__ = invoke_ident ? _fbb.CreateString(invoke_ident) : 0;
  return noodles::CreateMethodReply(
      _fbb,
      invoke_ident__,
      method_data,
      method_exception);
}

struct ServerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  noodles::ServerMessageType message_type() const {
    return static_cast<noodles::ServerMessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const noodles::MethodCreate *message_as_MethodCreate() const {
    return message_type() == noodles::ServerMessageType::MethodCreate ? static_cast<const noodles::MethodCreate *>(message()) : nullptr;
  }
  const noodles::MethodDelete *message_as_MethodDelete() const {
    return message_type() == noodles::ServerMessageType::MethodDelete ? static_cast<const noodles::MethodDelete *>(message()) : nullptr;
  }
  const noodles::SignalCreate *message_as_SignalCreate() const {
    return message_type() == noodles::ServerMessageType::SignalCreate ? static_cast<const noodles::SignalCreate *>(message()) : nullptr;
  }
  const noodles::SignalDelete *message_as_SignalDelete() const {
    return message_type() == noodles::ServerMessageType::SignalDelete ? static_cast<const noodles::SignalDelete *>(message()) : nullptr;
  }
  const noodles::ObjectCreateUpdate *message_as_ObjectCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::ObjectCreateUpdate ? static_cast<const noodles::ObjectCreateUpdate *>(message()) : nullptr;
  }
  const noodles::ObjectDelete *message_as_ObjectDelete() const {
    return message_type() == noodles::ServerMessageType::ObjectDelete ? static_cast<const noodles::ObjectDelete *>(message()) : nullptr;
  }
  const noodles::BufferCreate *message_as_BufferCreate() const {
    return message_type() == noodles::ServerMessageType::BufferCreate ? static_cast<const noodles::BufferCreate *>(message()) : nullptr;
  }
  const noodles::BufferDelete *message_as_BufferDelete() const {
    return message_type() == noodles::ServerMessageType::BufferDelete ? static_cast<const noodles::BufferDelete *>(message()) : nullptr;
  }
  const noodles::MaterialCreateUpdate *message_as_MaterialCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::MaterialCreateUpdate ? static_cast<const noodles::MaterialCreateUpdate *>(message()) : nullptr;
  }
  const noodles::MaterialDelete *message_as_MaterialDelete() const {
    return message_type() == noodles::ServerMessageType::MaterialDelete ? static_cast<const noodles::MaterialDelete *>(message()) : nullptr;
  }
  const noodles::TextureCreateUpdate *message_as_TextureCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TextureCreateUpdate ? static_cast<const noodles::TextureCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TextureDelete *message_as_TextureDelete() const {
    return message_type() == noodles::ServerMessageType::TextureDelete ? static_cast<const noodles::TextureDelete *>(message()) : nullptr;
  }
  const noodles::LightCreateUpdate *message_as_LightCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::LightCreateUpdate ? static_cast<const noodles::LightCreateUpdate *>(message()) : nullptr;
  }
  const noodles::LightDelete *message_as_LightDelete() const {
    return message_type() == noodles::ServerMessageType::LightDelete ? static_cast<const noodles::LightDelete *>(message()) : nullptr;
  }
  const noodles::GeometryCreate *message_as_GeometryCreate() const {
    return message_type() == noodles::ServerMessageType::GeometryCreate ? static_cast<const noodles::GeometryCreate *>(message()) : nullptr;
  }
  const noodles::GeometryDelete *message_as_GeometryDelete() const {
    return message_type() == noodles::ServerMessageType::GeometryDelete ? static_cast<const noodles::GeometryDelete *>(message()) : nullptr;
  }
  const noodles::TableCreateUpdate *message_as_TableCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TableCreateUpdate ? static_cast<const noodles::TableCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TableDelete *message_as_TableDelete() const {
    return message_type() == noodles::ServerMessageType::TableDelete ? static_cast<const noodles::TableDelete *>(message()) : nullptr;
  }
  const noodles::DocumentUpdate *message_as_DocumentUpdate() const {
    return message_type() == noodles::ServerMessageType::DocumentUpdate ? static_cast<const noodles::DocumentUpdate *>(message()) : nullptr;
  }
  const noodles::DocumentReset *message_as_DocumentReset() const {
    return message_type() == noodles::ServerMessageType::DocumentReset ? static_cast<const noodles::DocumentReset *>(message()) : nullptr;
  }
  const noodles::SignalInvoke *message_as_SignalInvoke() const {
    return message_type() == noodles::ServerMessageType::SignalInvoke ? static_cast<const noodles::SignalInvoke *>(message()) : nullptr;
  }
  const noodles::MethodReply *message_as_MethodReply() const {
    return message_type() == noodles::ServerMessageType::MethodReply ? static_cast<const noodles::MethodReply *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyServerMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::MethodCreate *ServerMessage::message_as<noodles::MethodCreate>() const {
  return message_as_MethodCreate();
}

template<> inline const noodles::MethodDelete *ServerMessage::message_as<noodles::MethodDelete>() const {
  return message_as_MethodDelete();
}

template<> inline const noodles::SignalCreate *ServerMessage::message_as<noodles::SignalCreate>() const {
  return message_as_SignalCreate();
}

template<> inline const noodles::SignalDelete *ServerMessage::message_as<noodles::SignalDelete>() const {
  return message_as_SignalDelete();
}

template<> inline const noodles::ObjectCreateUpdate *ServerMessage::message_as<noodles::ObjectCreateUpdate>() const {
  return message_as_ObjectCreateUpdate();
}

template<> inline const noodles::ObjectDelete *ServerMessage::message_as<noodles::ObjectDelete>() const {
  return message_as_ObjectDelete();
}

template<> inline const noodles::BufferCreate *ServerMessage::message_as<noodles::BufferCreate>() const {
  return message_as_BufferCreate();
}

template<> inline const noodles::BufferDelete *ServerMessage::message_as<noodles::BufferDelete>() const {
  return message_as_BufferDelete();
}

template<> inline const noodles::MaterialCreateUpdate *ServerMessage::message_as<noodles::MaterialCreateUpdate>() const {
  return message_as_MaterialCreateUpdate();
}

template<> inline const noodles::MaterialDelete *ServerMessage::message_as<noodles::MaterialDelete>() const {
  return message_as_MaterialDelete();
}

template<> inline const noodles::TextureCreateUpdate *ServerMessage::message_as<noodles::TextureCreateUpdate>() const {
  return message_as_TextureCreateUpdate();
}

template<> inline const noodles::TextureDelete *ServerMessage::message_as<noodles::TextureDelete>() const {
  return message_as_TextureDelete();
}

template<> inline const noodles::LightCreateUpdate *ServerMessage::message_as<noodles::LightCreateUpdate>() const {
  return message_as_LightCreateUpdate();
}

template<> inline const noodles::LightDelete *ServerMessage::message_as<noodles::LightDelete>() const {
  return message_as_LightDelete();
}

template<> inline const noodles::GeometryCreate *ServerMessage::message_as<noodles::GeometryCreate>() const {
  return message_as_GeometryCreate();
}

template<> inline const noodles::GeometryDelete *ServerMessage::message_as<noodles::GeometryDelete>() const {
  return message_as_GeometryDelete();
}

template<> inline const noodles::TableCreateUpdate *ServerMessage::message_as<noodles::TableCreateUpdate>() const {
  return message_as_TableCreateUpdate();
}

template<> inline const noodles::TableDelete *ServerMessage::message_as<noodles::TableDelete>() const {
  return message_as_TableDelete();
}

template<> inline const noodles::DocumentUpdate *ServerMessage::message_as<noodles::DocumentUpdate>() const {
  return message_as_DocumentUpdate();
}

template<> inline const noodles::DocumentReset *ServerMessage::message_as<noodles::DocumentReset>() const {
  return message_as_DocumentReset();
}

template<> inline const noodles::SignalInvoke *ServerMessage::message_as<noodles::SignalInvoke>() const {
  return message_as_SignalInvoke();
}

template<> inline const noodles::MethodReply *ServerMessage::message_as<noodles::MethodReply>() const {
  return message_as_MethodReply();
}

struct ServerMessageBuilder {
  typedef ServerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(noodles::ServerMessageType message_type) {
    fbb_.AddElement<uint8_t>(ServerMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ServerMessage::VT_MESSAGE, message);
  }
  explicit ServerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessage> CreateServerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::ServerMessageType message_type = noodles::ServerMessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  ServerMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct ServerMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessagesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessagesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ServerMessagesBuilder {
  typedef ServerMessages Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages) {
    fbb_.AddOffset(ServerMessages::VT_MESSAGES, messages);
  }
  explicit ServerMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerMessages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessages>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessages> CreateServerMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages = 0) {
  ServerMessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerMessages> CreateServerMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::ServerMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<noodles::ServerMessage>>(*messages) : 0;
  return noodles::CreateServerMessages(
      _fbb,
      messages__);
}

struct IntroductionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntroductionMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntroductionMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_NAME = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *client_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_NAME);
  }
  flatbuffers::String *mutable_client_name() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_NAME);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENT_NAME) &&
           verifier.VerifyString(client_name()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct IntroductionMessageBuilder {
  typedef IntroductionMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_client_name(flatbuffers::Offset<flatbuffers::String> client_name) {
    fbb_.AddOffset(IntroductionMessage::VT_CLIENT_NAME, client_name);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(IntroductionMessage::VT_VERSION, version, 0);
  }
  explicit IntroductionMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntroductionMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntroductionMessage>(end);
    fbb_.Required(o, IntroductionMessage::VT_CLIENT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<IntroductionMessage> CreateIntroductionMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> client_name = 0,
    uint32_t version = 0) {
  IntroductionMessageBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_client_name(client_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntroductionMessage> CreateIntroductionMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_name = nullptr,
    uint32_t version = 0) {
  auto client_name__ = client_name ? _fbb.CreateString(client_name) : 0;
  return noodles::CreateIntroductionMessage(
      _fbb,
      client_name__,
      version);
}

struct MethodInvokeMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodInvokeMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodInvokeMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_ID = 4,
    VT_ON_OBJECT = 6,
    VT_ON_TABLE = 8,
    VT_ON_PLOT = 10,
    VT_INVOKE_IDENT = 12,
    VT_METHOD_ARGS = 14
  };
  const noodles::MethodID *method_id() const {
    return GetPointer<const noodles::MethodID *>(VT_METHOD_ID);
  }
  noodles::MethodID *mutable_method_id() {
    return GetPointer<noodles::MethodID *>(VT_METHOD_ID);
  }
  const noodles::ObjectID *on_object() const {
    return GetPointer<const noodles::ObjectID *>(VT_ON_OBJECT);
  }
  noodles::ObjectID *mutable_on_object() {
    return GetPointer<noodles::ObjectID *>(VT_ON_OBJECT);
  }
  const noodles::TableID *on_table() const {
    return GetPointer<const noodles::TableID *>(VT_ON_TABLE);
  }
  noodles::TableID *mutable_on_table() {
    return GetPointer<noodles::TableID *>(VT_ON_TABLE);
  }
  const noodles::PlotID *on_plot() const {
    return GetPointer<const noodles::PlotID *>(VT_ON_PLOT);
  }
  noodles::PlotID *mutable_on_plot() {
    return GetPointer<noodles::PlotID *>(VT_ON_PLOT);
  }
  const flatbuffers::String *invoke_ident() const {
    return GetPointer<const flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  flatbuffers::String *mutable_invoke_ident() {
    return GetPointer<flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  const noodles::AnyList *method_args() const {
    return GetPointer<const noodles::AnyList *>(VT_METHOD_ARGS);
  }
  noodles::AnyList *mutable_method_args() {
    return GetPointer<noodles::AnyList *>(VT_METHOD_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_METHOD_ID) &&
           verifier.VerifyTable(method_id()) &&
           VerifyOffset(verifier, VT_ON_OBJECT) &&
           verifier.VerifyTable(on_object()) &&
           VerifyOffset(verifier, VT_ON_TABLE) &&
           verifier.VerifyTable(on_table()) &&
           VerifyOffset(verifier, VT_ON_PLOT) &&
           verifier.VerifyTable(on_plot()) &&
           VerifyOffsetRequired(verifier, VT_INVOKE_IDENT) &&
           verifier.VerifyString(invoke_ident()) &&
           VerifyOffset(verifier, VT_METHOD_ARGS) &&
           verifier.VerifyTable(method_args()) &&
           verifier.EndTable();
  }
};

struct MethodInvokeMessageBuilder {
  typedef MethodInvokeMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method_id(flatbuffers::Offset<noodles::MethodID> method_id) {
    fbb_.AddOffset(MethodInvokeMessage::VT_METHOD_ID, method_id);
  }
  void add_on_object(flatbuffers::Offset<noodles::ObjectID> on_object) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_OBJECT, on_object);
  }
  void add_on_table(flatbuffers::Offset<noodles::TableID> on_table) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_TABLE, on_table);
  }
  void add_on_plot(flatbuffers::Offset<noodles::PlotID> on_plot) {
    fbb_.AddOffset(MethodInvokeMessage::VT_ON_PLOT, on_plot);
  }
  void add_invoke_ident(flatbuffers::Offset<flatbuffers::String> invoke_ident) {
    fbb_.AddOffset(MethodInvokeMessage::VT_INVOKE_IDENT, invoke_ident);
  }
  void add_method_args(flatbuffers::Offset<noodles::AnyList> method_args) {
    fbb_.AddOffset(MethodInvokeMessage::VT_METHOD_ARGS, method_args);
  }
  explicit MethodInvokeMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodInvokeMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodInvokeMessage>(end);
    fbb_.Required(o, MethodInvokeMessage::VT_METHOD_ID);
    fbb_.Required(o, MethodInvokeMessage::VT_INVOKE_IDENT);
    return o;
  }
};

inline flatbuffers::Offset<MethodInvokeMessage> CreateMethodInvokeMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> method_id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    flatbuffers::Offset<flatbuffers::String> invoke_ident = 0,
    flatbuffers::Offset<noodles::AnyList> method_args = 0) {
  MethodInvokeMessageBuilder builder_(_fbb);
  builder_.add_method_args(method_args);
  builder_.add_invoke_ident(invoke_ident);
  builder_.add_on_plot(on_plot);
  builder_.add_on_table(on_table);
  builder_.add_on_object(on_object);
  builder_.add_method_id(method_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodInvokeMessage> CreateMethodInvokeMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> method_id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    const char *invoke_ident = nullptr,
    flatbuffers::Offset<noodles::AnyList> method_args = 0) {
  auto invoke_ident__ = invoke_ident ? _fbb.CreateString(invoke_ident) : 0;
  return noodles::CreateMethodInvokeMessage(
      _fbb,
      method_id,
      on_object,
      on_table,
      on_plot,
      invoke_ident__,
      method_args);
}

struct AssetRefreshMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetRefreshMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssetRefreshMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOR_BUFFERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *for_buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *>(VT_FOR_BUFFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *mutable_for_buffers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>> *>(VT_FOR_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FOR_BUFFERS) &&
           verifier.VerifyVector(for_buffers()) &&
           verifier.VerifyVectorOfTables(for_buffers()) &&
           verifier.EndTable();
  }
};

struct AssetRefreshMessageBuilder {
  typedef AssetRefreshMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_for_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>>> for_buffers) {
    fbb_.AddOffset(AssetRefreshMessage::VT_FOR_BUFFERS, for_buffers);
  }
  explicit AssetRefreshMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssetRefreshMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetRefreshMessage>(end);
    fbb_.Required(o, AssetRefreshMessage::VT_FOR_BUFFERS);
    return o;
  }
};

inline flatbuffers::Offset<AssetRefreshMessage> CreateAssetRefreshMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::BufferID>>> for_buffers = 0) {
  AssetRefreshMessageBuilder builder_(_fbb);
  builder_.add_for_buffers(for_buffers);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetRefreshMessage> CreateAssetRefreshMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::BufferID>> *for_buffers = nullptr) {
  auto for_buffers__ = for_buffers ? _fbb.CreateVector<flatbuffers::Offset<noodles::BufferID>>(*for_buffers) : 0;
  return noodles::CreateAssetRefreshMessage(
      _fbb,
      for_buffers__);
}

struct ClientMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClientMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  noodles::ClientMessageType content_type() const {
    return static_cast<noodles::ClientMessageType>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const noodles::IntroductionMessage *content_as_IntroductionMessage() const {
    return content_type() == noodles::ClientMessageType::IntroductionMessage ? static_cast<const noodles::IntroductionMessage *>(content()) : nullptr;
  }
  const noodles::MethodInvokeMessage *content_as_MethodInvokeMessage() const {
    return content_type() == noodles::ClientMessageType::MethodInvokeMessage ? static_cast<const noodles::MethodInvokeMessage *>(content()) : nullptr;
  }
  const noodles::AssetRefreshMessage *content_as_AssetRefreshMessage() const {
    return content_type() == noodles::ClientMessageType::AssetRefreshMessage ? static_cast<const noodles::AssetRefreshMessage *>(content()) : nullptr;
  }
  void *mutable_content() {
    return GetPointer<void *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           VerifyClientMessageType(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::IntroductionMessage *ClientMessage::content_as<noodles::IntroductionMessage>() const {
  return content_as_IntroductionMessage();
}

template<> inline const noodles::MethodInvokeMessage *ClientMessage::content_as<noodles::MethodInvokeMessage>() const {
  return content_as_MethodInvokeMessage();
}

template<> inline const noodles::AssetRefreshMessage *ClientMessage::content_as<noodles::AssetRefreshMessage>() const {
  return content_as_AssetRefreshMessage();
}

struct ClientMessageBuilder {
  typedef ClientMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content_type(noodles::ClientMessageType content_type) {
    fbb_.AddElement<uint8_t>(ClientMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(ClientMessage::VT_CONTENT, content);
  }
  explicit ClientMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientMessage>(end);
    fbb_.Required(o, ClientMessage::VT_CONTENT);
    return o;
  }
};

inline flatbuffers::Offset<ClientMessage> CreateClientMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::ClientMessageType content_type = noodles::ClientMessageType::NONE,
    flatbuffers::Offset<void> content = 0) {
  ClientMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct ClientMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientMessagesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClientMessagesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ClientMessagesBuilder {
  typedef ClientMessages Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>>> messages) {
    fbb_.AddOffset(ClientMessages::VT_MESSAGES, messages);
  }
  explicit ClientMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientMessages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientMessages>(end);
    fbb_.Required(o, ClientMessages::VT_MESSAGES);
    return o;
  }
};

inline flatbuffers::Offset<ClientMessages> CreateClientMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ClientMessage>>> messages = 0) {
  ClientMessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientMessages> CreateClientMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::ClientMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<noodles::ClientMessage>>(*messages) : 0;
  return noodles::CreateClientMessages(
      _fbb,
      messages__);
}

inline bool VerifyAnyIDType(flatbuffers::Verifier &verifier, const void *obj, AnyIDType type) {
  switch (type) {
    case AnyIDType::NONE: {
      return true;
    }
    case AnyIDType::ObjectID: {
      auto ptr = reinterpret_cast<const noodles::ObjectID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::TableID: {
      auto ptr = reinterpret_cast<const noodles::TableID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::SignalID: {
      auto ptr = reinterpret_cast<const noodles::SignalID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::MethodID: {
      auto ptr = reinterpret_cast<const noodles::MethodID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::MaterialID: {
      auto ptr = reinterpret_cast<const noodles::MaterialID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::GeometryID: {
      auto ptr = reinterpret_cast<const noodles::GeometryID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::LightID: {
      auto ptr = reinterpret_cast<const noodles::LightID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::TextureID: {
      auto ptr = reinterpret_cast<const noodles::TextureID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::BufferID: {
      auto ptr = reinterpret_cast<const noodles::BufferID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyIDType::PlotID: {
      auto ptr = reinterpret_cast<const noodles::PlotID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyIDTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyIDType(
        verifier,  values->Get(i), types->GetEnum<AnyIDType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyType(flatbuffers::Verifier &verifier, const void *obj, AnyType type) {
  switch (type) {
    case AnyType::NONE: {
      return true;
    }
    case AnyType::Text: {
      auto ptr = reinterpret_cast<const noodles::Text *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Integer: {
      auto ptr = reinterpret_cast<const noodles::Integer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::IntegerList: {
      auto ptr = reinterpret_cast<const noodles::IntegerList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Real: {
      auto ptr = reinterpret_cast<const noodles::Real *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::RealList: {
      auto ptr = reinterpret_cast<const noodles::RealList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::Data: {
      auto ptr = reinterpret_cast<const noodles::Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyList: {
      auto ptr = reinterpret_cast<const noodles::AnyList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyMap: {
      auto ptr = reinterpret_cast<const noodles::AnyMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyType::AnyID: {
      auto ptr = reinterpret_cast<const noodles::AnyID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyType(
        verifier,  values->Get(i), types->GetEnum<AnyType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyObjectDefinition(flatbuffers::Verifier &verifier, const void *obj, ObjectDefinition type) {
  switch (type) {
    case ObjectDefinition::NONE: {
      return true;
    }
    case ObjectDefinition::EmptyDefinition: {
      auto ptr = reinterpret_cast<const noodles::EmptyDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::TextDefinition: {
      auto ptr = reinterpret_cast<const noodles::TextDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::WebpageDefinition: {
      auto ptr = reinterpret_cast<const noodles::WebpageDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::RenderableDefinition: {
      auto ptr = reinterpret_cast<const noodles::RenderableDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectDefinitionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectDefinition(
        verifier,  values->Get(i), types->GetEnum<ObjectDefinition>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPlotType(flatbuffers::Verifier &verifier, const void *obj, PlotType type) {
  switch (type) {
    case PlotType::NONE: {
      return true;
    }
    case PlotType::SimplePlot: {
      auto ptr = reinterpret_cast<const noodles::SimplePlot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PlotType::URLPlot: {
      auto ptr = reinterpret_cast<const noodles::URLPlot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPlotTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPlotType(
        verifier,  values->Get(i), types->GetEnum<PlotType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type) {
  switch (type) {
    case ServerMessageType::NONE: {
      return true;
    }
    case ServerMessageType::MethodCreate: {
      auto ptr = reinterpret_cast<const noodles::MethodCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodDelete: {
      auto ptr = reinterpret_cast<const noodles::MethodDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalCreate: {
      auto ptr = reinterpret_cast<const noodles::SignalCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalDelete: {
      auto ptr = reinterpret_cast<const noodles::SignalDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::ObjectCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectDelete: {
      auto ptr = reinterpret_cast<const noodles::ObjectDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferCreate: {
      auto ptr = reinterpret_cast<const noodles::BufferCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferDelete: {
      auto ptr = reinterpret_cast<const noodles::BufferDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::MaterialCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialDelete: {
      auto ptr = reinterpret_cast<const noodles::MaterialDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TextureCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureDelete: {
      auto ptr = reinterpret_cast<const noodles::TextureDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::LightCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightDelete: {
      auto ptr = reinterpret_cast<const noodles::LightDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryCreate: {
      auto ptr = reinterpret_cast<const noodles::GeometryCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryDelete: {
      auto ptr = reinterpret_cast<const noodles::GeometryDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TableCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableDelete: {
      auto ptr = reinterpret_cast<const noodles::TableDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentUpdate: {
      auto ptr = reinterpret_cast<const noodles::DocumentUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentReset: {
      auto ptr = reinterpret_cast<const noodles::DocumentReset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalInvoke: {
      auto ptr = reinterpret_cast<const noodles::SignalInvoke *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodReply: {
      auto ptr = reinterpret_cast<const noodles::MethodReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerMessageType(
        verifier,  values->Get(i), types->GetEnum<ServerMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyClientMessageType(flatbuffers::Verifier &verifier, const void *obj, ClientMessageType type) {
  switch (type) {
    case ClientMessageType::NONE: {
      return true;
    }
    case ClientMessageType::IntroductionMessage: {
      auto ptr = reinterpret_cast<const noodles::IntroductionMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientMessageType::MethodInvokeMessage: {
      auto ptr = reinterpret_cast<const noodles::MethodInvokeMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientMessageType::AssetRefreshMessage: {
      auto ptr = reinterpret_cast<const noodles::AssetRefreshMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyClientMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClientMessageType(
        verifier,  values->Get(i), types->GetEnum<ClientMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *AnyIDTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::SignalIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::MaterialIDTypeTable,
    noodles::GeometryIDTypeTable,
    noodles::LightIDTypeTable,
    noodles::TextureIDTypeTable,
    noodles::BufferIDTypeTable,
    noodles::PlotIDTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "ObjectID",
    "TableID",
    "SignalID",
    "MethodID",
    "MaterialID",
    "GeometryID",
    "LightID",
    "TextureID",
    "BufferID",
    "PlotID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextTypeTable,
    noodles::IntegerTypeTable,
    noodles::IntegerListTypeTable,
    noodles::RealTypeTable,
    noodles::RealListTypeTable,
    noodles::DataTypeTable,
    noodles::AnyListTypeTable,
    noodles::AnyMapTypeTable,
    noodles::AnyIDTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Text",
    "Integer",
    "IntegerList",
    "Real",
    "RealList",
    "Data",
    "AnyList",
    "AnyMap",
    "AnyID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::EmptyDefinitionTypeTable,
    noodles::TextDefinitionTypeTable,
    noodles::WebpageDefinitionTypeTable,
    noodles::RenderableDefinitionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EmptyDefinition",
    "TextDefinition",
    "WebpageDefinition",
    "RenderableDefinition"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SimplePlotTypeTable,
    noodles::URLPlotTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "SimplePlot",
    "URLPlot"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightTypeTypeTable
  };
  static const char * const names[] = {
    "POINT",
    "SUN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodCreateTypeTable,
    noodles::MethodDeleteTypeTable,
    noodles::SignalCreateTypeTable,
    noodles::SignalDeleteTypeTable,
    noodles::ObjectCreateUpdateTypeTable,
    noodles::ObjectDeleteTypeTable,
    noodles::BufferCreateTypeTable,
    noodles::BufferDeleteTypeTable,
    noodles::MaterialCreateUpdateTypeTable,
    noodles::MaterialDeleteTypeTable,
    noodles::TextureCreateUpdateTypeTable,
    noodles::TextureDeleteTypeTable,
    noodles::LightCreateUpdateTypeTable,
    noodles::LightDeleteTypeTable,
    noodles::GeometryCreateTypeTable,
    noodles::GeometryDeleteTypeTable,
    noodles::TableCreateUpdateTypeTable,
    noodles::TableDeleteTypeTable,
    noodles::DocumentUpdateTypeTable,
    noodles::DocumentResetTypeTable,
    noodles::SignalInvokeTypeTable,
    noodles::MethodReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 23, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClientMessageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::IntroductionMessageTypeTable,
    noodles::MethodInvokeMessageTypeTable,
    noodles::AssetRefreshMessageTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "IntroductionMessage",
    "MethodInvokeMessage",
    "AssetRefreshMessage"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "id_slot",
    "id_gen"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyIDTypeTypeTable
  };
  static const char * const names[] = {
    "id_type",
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapEntryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "name",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "text"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "integer"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "integers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "real"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const char * const names[] = {
    "reals"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyListTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyMapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MapEntryTypeTable
  };
  static const char * const names[] = {
    "entries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AnyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTypeTable
  };
  static const char * const names[] = {
    "any_type",
    "any"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Mat4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::Vec4TypeTable
  };
  static const int64_t values[] = { 0, 16, 32, 48, 64 };
  static const char * const names[] = {
    "c1",
    "c2",
    "c3",
    "c4"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BoundingBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::Vec3TypeTable
  };
  static const int64_t values[] = { 0, 12, 24 };
  static const char * const names[] = {
    "aabb_min",
    "aabb_max"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RGBTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const int64_t values[] = { 0, 1, 2, 3 };
  static const char * const names[] = {
    "r",
    "g",
    "b"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodArgTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "doc",
    "hint"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "return_doc",
    "arg_doc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "arg_doc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmptyDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "text",
    "font",
    "height",
    "width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebpageDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "url",
    "height",
    "width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RenderableDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable,
    noodles::GeometryIDTypeTable,
    noodles::Mat4TypeTable,
    noodles::BoundingBoxTypeTable
  };
  static const char * const names[] = {
    "material",
    "mesh",
    "instances",
    "instance_bb"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectVisibilityTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const int64_t values[] = { 0, 1 };
  static const char * const names[] = {
    "visible"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UTYPE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_SEQUENCE, 1, 5 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_SEQUENCE, 1, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable,
    noodles::Mat4TypeTable,
    noodles::ObjectDefinitionTypeTable,
    noodles::LightIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable,
    noodles::BoundingBoxTypeTable,
    noodles::ObjectVisibilityTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "parent",
    "transform",
    "definition_type",
    "definition",
    "lights",
    "tables",
    "plots",
    "tags",
    "methods_list",
    "signals_list",
    "influence",
    "visibility"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SimplePlotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "definition"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *URLPlotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "url"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UTYPE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::PlotIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotTypeTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "table",
    "type_type",
    "type",
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::PlotIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "bytes",
    "url",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable,
    noodles::Vec4TypeTable,
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "metallic",
    "roughness",
    "use_blending",
    "texture_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable,
    noodles::BufferRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "reference"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable,
    noodles::RGBTypeTable,
    noodles::Vec4TypeTable,
    noodles::LightTypeTypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "intensity",
    "spatial",
    "light_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ComponentRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "size",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable,
    noodles::BoundingBoxTypeTable,
    noodles::ComponentRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "extent",
    "positions",
    "normals",
    "tex_coords",
    "colors",
    "lines",
    "triangles"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "meta",
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentResetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalInvokeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::AnyListTypeTable
  };
  static const char * const names[] = {
    "id",
    "on_object",
    "on_table",
    "on_plot",
    "signal_data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodExceptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "code",
    "message",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable,
    noodles::MethodExceptionTypeTable
  };
  static const char * const names[] = {
    "invoke_ident",
    "method_data",
    "method_exception"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTypeTable
  };
  static const char * const names[] = {
    "message_type",
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessagesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTable
  };
  static const char * const names[] = {
    "messages"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntroductionMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "client_name",
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodInvokeMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::AnyListTypeTable
  };
  static const char * const names[] = {
    "method_id",
    "on_object",
    "on_table",
    "on_plot",
    "invoke_ident",
    "method_args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssetRefreshMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "for_buffers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClientMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ClientMessageTypeTypeTable
  };
  static const char * const names[] = {
    "content_type",
    "content"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClientMessagesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ClientMessageTypeTable
  };
  static const char * const names[] = {
    "messages"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace noodles

#endif  // FLATBUFFERS_GENERATED_NOODLES_NOODLES_H_
