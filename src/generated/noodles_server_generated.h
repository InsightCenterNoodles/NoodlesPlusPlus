// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_
#define FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_

#include "flatbuffers/flatbuffers.h"

#include "noodles_generated.h"

namespace noodles {

struct MethodArg;
struct MethodArgBuilder;

struct MethodCreate;
struct MethodCreateBuilder;

struct MethodDelete;
struct MethodDeleteBuilder;

struct SignalCreate;
struct SignalCreateBuilder;

struct SignalDelete;
struct SignalDeleteBuilder;

struct EmptyDefinition;
struct EmptyDefinitionBuilder;

struct TextDefinition;
struct TextDefinitionBuilder;

struct WebpageDefinition;
struct WebpageDefinitionBuilder;

struct RenderableDefinition;
struct RenderableDefinitionBuilder;

struct ObjectVisibility;

struct ObjectCreateUpdate;
struct ObjectCreateUpdateBuilder;

struct ObjectDelete;
struct ObjectDeleteBuilder;

struct SimplePlot;
struct SimplePlotBuilder;

struct URLPlot;
struct URLPlotBuilder;

struct PlotCreateUpdate;
struct PlotCreateUpdateBuilder;

struct PlotDelete;
struct PlotDeleteBuilder;

struct BufferCreate;
struct BufferCreateBuilder;

struct BufferDelete;
struct BufferDeleteBuilder;

struct MaterialCreateUpdate;
struct MaterialCreateUpdateBuilder;

struct MaterialDelete;
struct MaterialDeleteBuilder;

struct TextureCreateUpdate;
struct TextureCreateUpdateBuilder;

struct TextureDelete;
struct TextureDeleteBuilder;

struct LightCreateUpdate;
struct LightCreateUpdateBuilder;

struct LightDelete;
struct LightDeleteBuilder;

struct ComponentRef;
struct ComponentRefBuilder;

struct GeometryCreate;
struct GeometryCreateBuilder;

struct GeometryDelete;
struct GeometryDeleteBuilder;

struct TableCreateUpdate;
struct TableCreateUpdateBuilder;

struct TableDelete;
struct TableDeleteBuilder;

struct DocumentUpdate;
struct DocumentUpdateBuilder;

struct DocumentReset;
struct DocumentResetBuilder;

struct SignalInvoke;
struct SignalInvokeBuilder;

struct MethodException;
struct MethodExceptionBuilder;

struct MethodReply;
struct MethodReplyBuilder;

struct ServerMessage;
struct ServerMessageBuilder;

struct ServerMessages;
struct ServerMessagesBuilder;

inline const flatbuffers::TypeTable *MethodArgTypeTable();

inline const flatbuffers::TypeTable *MethodCreateTypeTable();

inline const flatbuffers::TypeTable *MethodDeleteTypeTable();

inline const flatbuffers::TypeTable *SignalCreateTypeTable();

inline const flatbuffers::TypeTable *SignalDeleteTypeTable();

inline const flatbuffers::TypeTable *EmptyDefinitionTypeTable();

inline const flatbuffers::TypeTable *TextDefinitionTypeTable();

inline const flatbuffers::TypeTable *WebpageDefinitionTypeTable();

inline const flatbuffers::TypeTable *RenderableDefinitionTypeTable();

inline const flatbuffers::TypeTable *ObjectVisibilityTypeTable();

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable();

inline const flatbuffers::TypeTable *SimplePlotTypeTable();

inline const flatbuffers::TypeTable *URLPlotTypeTable();

inline const flatbuffers::TypeTable *PlotCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *PlotDeleteTypeTable();

inline const flatbuffers::TypeTable *BufferCreateTypeTable();

inline const flatbuffers::TypeTable *BufferDeleteTypeTable();

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable();

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TextureDeleteTypeTable();

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *LightDeleteTypeTable();

inline const flatbuffers::TypeTable *ComponentRefTypeTable();

inline const flatbuffers::TypeTable *GeometryCreateTypeTable();

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable();

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TableDeleteTypeTable();

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable();

inline const flatbuffers::TypeTable *DocumentResetTypeTable();

inline const flatbuffers::TypeTable *SignalInvokeTypeTable();

inline const flatbuffers::TypeTable *MethodExceptionTypeTable();

inline const flatbuffers::TypeTable *MethodReplyTypeTable();

inline const flatbuffers::TypeTable *ServerMessageTypeTable();

inline const flatbuffers::TypeTable *ServerMessagesTypeTable();

enum class ObjectDefinition : uint8_t {
  NONE = 0,
  EmptyDefinition = 1,
  TextDefinition = 2,
  WebpageDefinition = 3,
  RenderableDefinition = 4,
  MIN = NONE,
  MAX = RenderableDefinition
};

inline const ObjectDefinition (&EnumValuesObjectDefinition())[5] {
  static const ObjectDefinition values[] = {
    ObjectDefinition::NONE,
    ObjectDefinition::EmptyDefinition,
    ObjectDefinition::TextDefinition,
    ObjectDefinition::WebpageDefinition,
    ObjectDefinition::RenderableDefinition
  };
  return values;
}

inline const char * const *EnumNamesObjectDefinition() {
  static const char * const names[6] = {
    "NONE",
    "EmptyDefinition",
    "TextDefinition",
    "WebpageDefinition",
    "RenderableDefinition",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectDefinition(ObjectDefinition e) {
  if (flatbuffers::IsOutRange(e, ObjectDefinition::NONE, ObjectDefinition::RenderableDefinition)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectDefinition()[index];
}

template<typename T> struct ObjectDefinitionTraits {
  static const ObjectDefinition enum_value = ObjectDefinition::NONE;
};

template<> struct ObjectDefinitionTraits<noodles::EmptyDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::EmptyDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::TextDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::TextDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::WebpageDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::WebpageDefinition;
};

template<> struct ObjectDefinitionTraits<noodles::RenderableDefinition> {
  static const ObjectDefinition enum_value = ObjectDefinition::RenderableDefinition;
};

bool VerifyObjectDefinition(flatbuffers::Verifier &verifier, const void *obj, ObjectDefinition type);
bool VerifyObjectDefinitionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class PlotType : uint8_t {
  NONE = 0,
  SimplePlot = 1,
  URLPlot = 2,
  MIN = NONE,
  MAX = URLPlot
};

inline const PlotType (&EnumValuesPlotType())[3] {
  static const PlotType values[] = {
    PlotType::NONE,
    PlotType::SimplePlot,
    PlotType::URLPlot
  };
  return values;
}

inline const char * const *EnumNamesPlotType() {
  static const char * const names[4] = {
    "NONE",
    "SimplePlot",
    "URLPlot",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlotType(PlotType e) {
  if (flatbuffers::IsOutRange(e, PlotType::NONE, PlotType::URLPlot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlotType()[index];
}

template<typename T> struct PlotTypeTraits {
  static const PlotType enum_value = PlotType::NONE;
};

template<> struct PlotTypeTraits<noodles::SimplePlot> {
  static const PlotType enum_value = PlotType::SimplePlot;
};

template<> struct PlotTypeTraits<noodles::URLPlot> {
  static const PlotType enum_value = PlotType::URLPlot;
};

bool VerifyPlotType(flatbuffers::Verifier &verifier, const void *obj, PlotType type);
bool VerifyPlotTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class LightType : int8_t {
  POINT = 0,
  SUN = 1,
  MIN = POINT,
  MAX = SUN
};

inline const LightType (&EnumValuesLightType())[2] {
  static const LightType values[] = {
    LightType::POINT,
    LightType::SUN
  };
  return values;
}

inline const char * const *EnumNamesLightType() {
  static const char * const names[3] = {
    "POINT",
    "SUN",
    nullptr
  };
  return names;
}

inline const char *EnumNameLightType(LightType e) {
  if (flatbuffers::IsOutRange(e, LightType::POINT, LightType::SUN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLightType()[index];
}

enum class ServerMessageType : uint8_t {
  NONE = 0,
  MethodCreate = 1,
  MethodDelete = 2,
  SignalCreate = 3,
  SignalDelete = 4,
  ObjectCreateUpdate = 5,
  ObjectDelete = 6,
  BufferCreate = 7,
  BufferDelete = 8,
  MaterialCreateUpdate = 9,
  MaterialDelete = 10,
  TextureCreateUpdate = 11,
  TextureDelete = 12,
  LightCreateUpdate = 13,
  LightDelete = 14,
  GeometryCreate = 15,
  GeometryDelete = 16,
  TableCreateUpdate = 17,
  TableDelete = 18,
  DocumentUpdate = 19,
  DocumentReset = 20,
  SignalInvoke = 21,
  MethodReply = 22,
  MIN = NONE,
  MAX = MethodReply
};

inline const ServerMessageType (&EnumValuesServerMessageType())[23] {
  static const ServerMessageType values[] = {
    ServerMessageType::NONE,
    ServerMessageType::MethodCreate,
    ServerMessageType::MethodDelete,
    ServerMessageType::SignalCreate,
    ServerMessageType::SignalDelete,
    ServerMessageType::ObjectCreateUpdate,
    ServerMessageType::ObjectDelete,
    ServerMessageType::BufferCreate,
    ServerMessageType::BufferDelete,
    ServerMessageType::MaterialCreateUpdate,
    ServerMessageType::MaterialDelete,
    ServerMessageType::TextureCreateUpdate,
    ServerMessageType::TextureDelete,
    ServerMessageType::LightCreateUpdate,
    ServerMessageType::LightDelete,
    ServerMessageType::GeometryCreate,
    ServerMessageType::GeometryDelete,
    ServerMessageType::TableCreateUpdate,
    ServerMessageType::TableDelete,
    ServerMessageType::DocumentUpdate,
    ServerMessageType::DocumentReset,
    ServerMessageType::SignalInvoke,
    ServerMessageType::MethodReply
  };
  return values;
}

inline const char * const *EnumNamesServerMessageType() {
  static const char * const names[24] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerMessageType(ServerMessageType e) {
  if (flatbuffers::IsOutRange(e, ServerMessageType::NONE, ServerMessageType::MethodReply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerMessageType()[index];
}

template<typename T> struct ServerMessageTypeTraits {
  static const ServerMessageType enum_value = ServerMessageType::NONE;
};

template<> struct ServerMessageTypeTraits<noodles::MethodCreate> {
  static const ServerMessageType enum_value = ServerMessageType::MethodCreate;
};

template<> struct ServerMessageTypeTraits<noodles::MethodDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MethodDelete;
};

template<> struct ServerMessageTypeTraits<noodles::SignalCreate> {
  static const ServerMessageType enum_value = ServerMessageType::SignalCreate;
};

template<> struct ServerMessageTypeTraits<noodles::SignalDelete> {
  static const ServerMessageType enum_value = ServerMessageType::SignalDelete;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectDelete> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectDelete;
};

template<> struct ServerMessageTypeTraits<noodles::BufferCreate> {
  static const ServerMessageType enum_value = ServerMessageType::BufferCreate;
};

template<> struct ServerMessageTypeTraits<noodles::BufferDelete> {
  static const ServerMessageType enum_value = ServerMessageType::BufferDelete;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TextureCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TextureCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TextureDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TextureDelete;
};

template<> struct ServerMessageTypeTraits<noodles::LightCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::LightCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::LightDelete> {
  static const ServerMessageType enum_value = ServerMessageType::LightDelete;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryCreate> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryCreate;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryDelete> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TableCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TableCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TableDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TableDelete;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentReset> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentReset;
};

template<> struct ServerMessageTypeTraits<noodles::SignalInvoke> {
  static const ServerMessageType enum_value = ServerMessageType::SignalInvoke;
};

template<> struct ServerMessageTypeTraits<noodles::MethodReply> {
  static const ServerMessageType enum_value = ServerMessageType::MethodReply;
};

bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type);
bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ObjectVisibility FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t visible_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectVisibilityTypeTable();
  }
  ObjectVisibility()
      : visible_(0) {
  }
  ObjectVisibility(bool _visible)
      : visible_(flatbuffers::EndianScalar(static_cast<uint8_t>(_visible))) {
  }
  bool visible() const {
    return flatbuffers::EndianScalar(visible_) != 0;
  }
  void mutate_visible(bool _visible) {
    flatbuffers::WriteScalar(&visible_, static_cast<uint8_t>(_visible));
  }
};
FLATBUFFERS_STRUCT_END(ObjectVisibility, 1);

struct MethodArg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodArgBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodArgTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC = 6,
    VT_HINT = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC);
  }
  flatbuffers::String *mutable_doc() {
    return GetPointer<flatbuffers::String *>(VT_DOC);
  }
  const flatbuffers::String *hint() const {
    return GetPointer<const flatbuffers::String *>(VT_HINT);
  }
  flatbuffers::String *mutable_hint() {
    return GetPointer<flatbuffers::String *>(VT_HINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC) &&
           verifier.VerifyString(doc()) &&
           VerifyOffset(verifier, VT_HINT) &&
           verifier.VerifyString(hint()) &&
           verifier.EndTable();
  }
};

struct MethodArgBuilder {
  typedef MethodArg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodArg::VT_NAME, name);
  }
  void add_doc(flatbuffers::Offset<flatbuffers::String> doc) {
    fbb_.AddOffset(MethodArg::VT_DOC, doc);
  }
  void add_hint(flatbuffers::Offset<flatbuffers::String> hint) {
    fbb_.AddOffset(MethodArg::VT_HINT, hint);
  }
  explicit MethodArgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodArg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodArg>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodArg> CreateMethodArg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc = 0,
    flatbuffers::Offset<flatbuffers::String> hint = 0) {
  MethodArgBuilder builder_(_fbb);
  builder_.add_hint(hint);
  builder_.add_doc(doc);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodArg> CreateMethodArgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc = nullptr,
    const char *hint = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc__ = doc ? _fbb.CreateString(doc) : 0;
  auto hint__ = hint ? _fbb.CreateString(hint) : 0;
  return noodles::CreateMethodArg(
      _fbb,
      name__,
      doc__,
      hint__);
}

struct MethodCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_RETURN_DOC = 10,
    VT_ARG_DOC = 12
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::String *return_doc() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURN_DOC);
  }
  flatbuffers::String *mutable_return_doc() {
    return GetPointer<flatbuffers::String *>(VT_RETURN_DOC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_arg_doc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_RETURN_DOC) &&
           verifier.VerifyString(return_doc()) &&
           VerifyOffset(verifier, VT_ARG_DOC) &&
           verifier.VerifyVector(arg_doc()) &&
           verifier.VerifyVectorOfTables(arg_doc()) &&
           verifier.EndTable();
  }
};

struct MethodCreateBuilder {
  typedef MethodCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(MethodCreate::VT_DOCUMENTATION, documentation);
  }
  void add_return_doc(flatbuffers::Offset<flatbuffers::String> return_doc) {
    fbb_.AddOffset(MethodCreate::VT_RETURN_DOC, return_doc);
  }
  void add_arg_doc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc) {
    fbb_.AddOffset(MethodCreate::VT_ARG_DOC, arg_doc);
  }
  explicit MethodCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodCreate>(end);
    fbb_.Required(o, MethodCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodCreate> CreateMethodCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::String> return_doc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc = 0) {
  MethodCreateBuilder builder_(_fbb);
  builder_.add_arg_doc(arg_doc);
  builder_.add_return_doc(return_doc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodCreate> CreateMethodCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const char *return_doc = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto return_doc__ = return_doc ? _fbb.CreateString(return_doc) : 0;
  auto arg_doc__ = arg_doc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*arg_doc) : 0;
  return noodles::CreateMethodCreate(
      _fbb,
      id,
      name__,
      documentation__,
      return_doc__,
      arg_doc__);
}

struct MethodDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MethodDeleteBuilder {
  typedef MethodDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodDelete::VT_ID, id);
  }
  explicit MethodDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodDelete>(end);
    fbb_.Required(o, MethodDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodDelete> CreateMethodDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0) {
  MethodDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SignalCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_ARG_DOC = 10
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_arg_doc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARG_DOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_ARG_DOC) &&
           verifier.VerifyVector(arg_doc()) &&
           verifier.VerifyVectorOfTables(arg_doc()) &&
           verifier.EndTable();
  }
};

struct SignalCreateBuilder {
  typedef SignalCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SignalCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(SignalCreate::VT_DOCUMENTATION, documentation);
  }
  void add_arg_doc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc) {
    fbb_.AddOffset(SignalCreate::VT_ARG_DOC, arg_doc);
  }
  explicit SignalCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalCreate>(end);
    fbb_.Required(o, SignalCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalCreate> CreateSignalCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> arg_doc = 0) {
  SignalCreateBuilder builder_(_fbb);
  builder_.add_arg_doc(arg_doc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalCreate> CreateSignalCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *arg_doc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto arg_doc__ = arg_doc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*arg_doc) : 0;
  return noodles::CreateSignalCreate(
      _fbb,
      id,
      name__,
      documentation__,
      arg_doc__);
}

struct SignalDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct SignalDeleteBuilder {
  typedef SignalDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalDelete::VT_ID, id);
  }
  explicit SignalDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalDelete>(end);
    fbb_.Required(o, SignalDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalDelete> CreateSignalDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0) {
  SignalDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct EmptyDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmptyDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4
  };
  bool padding() const {
    return GetField<uint8_t>(VT_PADDING, 0) != 0;
  }
  bool mutate_padding(bool _padding) {
    return SetField<uint8_t>(VT_PADDING, static_cast<uint8_t>(_padding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PADDING) &&
           verifier.EndTable();
  }
};

struct EmptyDefinitionBuilder {
  typedef EmptyDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(bool padding) {
    fbb_.AddElement<uint8_t>(EmptyDefinition::VT_PADDING, static_cast<uint8_t>(padding), 0);
  }
  explicit EmptyDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmptyDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmptyDefinition>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmptyDefinition> CreateEmptyDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool padding = false) {
  EmptyDefinitionBuilder builder_(_fbb);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct TextDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_FONT = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *font() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT);
  }
  flatbuffers::String *mutable_font() {
    return GetPointer<flatbuffers::String *>(VT_FONT);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, 0.0f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, -1.0f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, -1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_FONT) &&
           verifier.VerifyString(font()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct TextDefinitionBuilder {
  typedef TextDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextDefinition::VT_TEXT, text);
  }
  void add_font(flatbuffers::Offset<flatbuffers::String> font) {
    fbb_.AddOffset(TextDefinition::VT_FONT, font);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(TextDefinition::VT_HEIGHT, height, 0.0f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(TextDefinition::VT_WIDTH, width, -1.0f);
  }
  explicit TextDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextDefinition>(end);
    fbb_.Required(o, TextDefinition::VT_TEXT);
    fbb_.Required(o, TextDefinition::VT_FONT);
    return o;
  }
};

inline flatbuffers::Offset<TextDefinition> CreateTextDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> font = 0,
    float height = 0.0f,
    float width = -1.0f) {
  TextDefinitionBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_font(font);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextDefinition> CreateTextDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *font = nullptr,
    float height = 0.0f,
    float width = -1.0f) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto font__ = font ? _fbb.CreateString(font) : 0;
  return noodles::CreateTextDefinition(
      _fbb,
      text__,
      font__,
      height,
      width);
}

struct WebpageDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebpageDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebpageDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4,
    VT_HEIGHT = 6,
    VT_WIDTH = 8
  };
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, .5f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, .5f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, .5f);
  }
  bool mutate_width(float _width) {
    return SetField<float>(VT_WIDTH, _width, .5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct WebpageDefinitionBuilder {
  typedef WebpageDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(WebpageDefinition::VT_URL, url);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(WebpageDefinition::VT_HEIGHT, height, .5f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(WebpageDefinition::VT_WIDTH, width, .5f);
  }
  explicit WebpageDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebpageDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebpageDefinition>(end);
    fbb_.Required(o, WebpageDefinition::VT_URL);
    return o;
  }
};

inline flatbuffers::Offset<WebpageDefinition> CreateWebpageDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    float height = .5f,
    float width = .5f) {
  WebpageDefinitionBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_url(url);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebpageDefinition> CreateWebpageDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr,
    float height = .5f,
    float width = .5f) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateWebpageDefinition(
      _fbb,
      url__,
      height,
      width);
}

struct RenderableDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderableDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RenderableDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4,
    VT_MESH = 6,
    VT_INSTANCES = 8,
    VT_INSTANCE_BB = 10
  };
  const noodles::MaterialID *material() const {
    return GetPointer<const noodles::MaterialID *>(VT_MATERIAL);
  }
  noodles::MaterialID *mutable_material() {
    return GetPointer<noodles::MaterialID *>(VT_MATERIAL);
  }
  const noodles::GeometryID *mesh() const {
    return GetPointer<const noodles::GeometryID *>(VT_MESH);
  }
  noodles::GeometryID *mutable_mesh() {
    return GetPointer<noodles::GeometryID *>(VT_MESH);
  }
  const flatbuffers::Vector<const noodles::Mat4 *> *instances() const {
    return GetPointer<const flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  flatbuffers::Vector<const noodles::Mat4 *> *mutable_instances() {
    return GetPointer<flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  const noodles::BoundingBox *instance_bb() const {
    return GetStruct<const noodles::BoundingBox *>(VT_INSTANCE_BB);
  }
  noodles::BoundingBox *mutable_instance_bb() {
    return GetStruct<noodles::BoundingBox *>(VT_INSTANCE_BB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           VerifyOffsetRequired(verifier, VT_MESH) &&
           verifier.VerifyTable(mesh()) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_INSTANCE_BB) &&
           verifier.EndTable();
  }
};

struct RenderableDefinitionBuilder {
  typedef RenderableDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material(flatbuffers::Offset<noodles::MaterialID> material) {
    fbb_.AddOffset(RenderableDefinition::VT_MATERIAL, material);
  }
  void add_mesh(flatbuffers::Offset<noodles::GeometryID> mesh) {
    fbb_.AddOffset(RenderableDefinition::VT_MESH, mesh);
  }
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances) {
    fbb_.AddOffset(RenderableDefinition::VT_INSTANCES, instances);
  }
  void add_instance_bb(const noodles::BoundingBox *instance_bb) {
    fbb_.AddStruct(RenderableDefinition::VT_INSTANCE_BB, instance_bb);
  }
  explicit RenderableDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderableDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderableDefinition>(end);
    fbb_.Required(o, RenderableDefinition::VT_MATERIAL);
    fbb_.Required(o, RenderableDefinition::VT_MESH);
    return o;
  }
};

inline flatbuffers::Offset<RenderableDefinition> CreateRenderableDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances = 0,
    const noodles::BoundingBox *instance_bb = 0) {
  RenderableDefinitionBuilder builder_(_fbb);
  builder_.add_instance_bb(instance_bb);
  builder_.add_instances(instances);
  builder_.add_mesh(mesh);
  builder_.add_material(material);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderableDefinition> CreateRenderableDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    const std::vector<noodles::Mat4> *instances = nullptr,
    const noodles::BoundingBox *instance_bb = 0) {
  auto instances__ = instances ? _fbb.CreateVectorOfStructs<noodles::Mat4>(*instances) : 0;
  return noodles::CreateRenderableDefinition(
      _fbb,
      material,
      mesh,
      instances__,
      instance_bb);
}

struct ObjectCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_PARENT = 8,
    VT_TRANSFORM = 10,
    VT_DEFINITION_TYPE = 12,
    VT_DEFINITION = 14,
    VT_LIGHTS = 16,
    VT_TABLES = 18,
    VT_PLOTS = 20,
    VT_TAGS = 22,
    VT_METHODS_LIST = 24,
    VT_SIGNALS_LIST = 26,
    VT_INFLUENCE = 28,
    VT_VISIBILITY = 30
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const noodles::ObjectID *parent() const {
    return GetPointer<const noodles::ObjectID *>(VT_PARENT);
  }
  noodles::ObjectID *mutable_parent() {
    return GetPointer<noodles::ObjectID *>(VT_PARENT);
  }
  const noodles::Mat4 *transform() const {
    return GetStruct<const noodles::Mat4 *>(VT_TRANSFORM);
  }
  noodles::Mat4 *mutable_transform() {
    return GetStruct<noodles::Mat4 *>(VT_TRANSFORM);
  }
  noodles::ObjectDefinition definition_type() const {
    return static_cast<noodles::ObjectDefinition>(GetField<uint8_t>(VT_DEFINITION_TYPE, 0));
  }
  const void *definition() const {
    return GetPointer<const void *>(VT_DEFINITION);
  }
  template<typename T> const T *definition_as() const;
  const noodles::EmptyDefinition *definition_as_EmptyDefinition() const {
    return definition_type() == noodles::ObjectDefinition::EmptyDefinition ? static_cast<const noodles::EmptyDefinition *>(definition()) : nullptr;
  }
  const noodles::TextDefinition *definition_as_TextDefinition() const {
    return definition_type() == noodles::ObjectDefinition::TextDefinition ? static_cast<const noodles::TextDefinition *>(definition()) : nullptr;
  }
  const noodles::WebpageDefinition *definition_as_WebpageDefinition() const {
    return definition_type() == noodles::ObjectDefinition::WebpageDefinition ? static_cast<const noodles::WebpageDefinition *>(definition()) : nullptr;
  }
  const noodles::RenderableDefinition *definition_as_RenderableDefinition() const {
    return definition_type() == noodles::ObjectDefinition::RenderableDefinition ? static_cast<const noodles::RenderableDefinition *>(definition()) : nullptr;
  }
  void *mutable_definition() {
    return GetPointer<void *>(VT_DEFINITION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *lights() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *mutable_lights() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *mutable_tables() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *plots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *>(VT_PLOTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *mutable_plots() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>> *>(VT_PLOTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_tags() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  const noodles::BoundingBox *influence() const {
    return GetStruct<const noodles::BoundingBox *>(VT_INFLUENCE);
  }
  noodles::BoundingBox *mutable_influence() {
    return GetStruct<noodles::BoundingBox *>(VT_INFLUENCE);
  }
  const noodles::ObjectVisibility *visibility() const {
    return GetStruct<const noodles::ObjectVisibility *>(VT_VISIBILITY);
  }
  noodles::ObjectVisibility *mutable_visibility() {
    return GetStruct<noodles::ObjectVisibility *>(VT_VISIBILITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARENT) &&
           verifier.VerifyTable(parent()) &&
           VerifyField<noodles::Mat4>(verifier, VT_TRANSFORM) &&
           VerifyField<uint8_t>(verifier, VT_DEFINITION_TYPE) &&
           VerifyOffset(verifier, VT_DEFINITION) &&
           VerifyObjectDefinition(verifier, definition(), definition_type()) &&
           VerifyOffset(verifier, VT_LIGHTS) &&
           verifier.VerifyVector(lights()) &&
           verifier.VerifyVectorOfTables(lights()) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_PLOTS) &&
           verifier.VerifyVector(plots()) &&
           verifier.VerifyVectorOfTables(plots()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_INFLUENCE) &&
           VerifyField<noodles::ObjectVisibility>(verifier, VT_VISIBILITY) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::EmptyDefinition *ObjectCreateUpdate::definition_as<noodles::EmptyDefinition>() const {
  return definition_as_EmptyDefinition();
}

template<> inline const noodles::TextDefinition *ObjectCreateUpdate::definition_as<noodles::TextDefinition>() const {
  return definition_as_TextDefinition();
}

template<> inline const noodles::WebpageDefinition *ObjectCreateUpdate::definition_as<noodles::WebpageDefinition>() const {
  return definition_as_WebpageDefinition();
}

template<> inline const noodles::RenderableDefinition *ObjectCreateUpdate::definition_as<noodles::RenderableDefinition>() const {
  return definition_as_RenderableDefinition();
}

struct ObjectCreateUpdateBuilder {
  typedef ObjectCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_NAME, name);
  }
  void add_parent(flatbuffers::Offset<noodles::ObjectID> parent) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_PARENT, parent);
  }
  void add_transform(const noodles::Mat4 *transform) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_TRANSFORM, transform);
  }
  void add_definition_type(noodles::ObjectDefinition definition_type) {
    fbb_.AddElement<uint8_t>(ObjectCreateUpdate::VT_DEFINITION_TYPE, static_cast<uint8_t>(definition_type), 0);
  }
  void add_definition(flatbuffers::Offset<void> definition) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_DEFINITION, definition);
  }
  void add_lights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_LIGHTS, lights);
  }
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TABLES, tables);
  }
  void add_plots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>>> plots) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_PLOTS, plots);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TAGS, tags);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  void add_influence(const noodles::BoundingBox *influence) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_INFLUENCE, influence);
  }
  void add_visibility(const noodles::ObjectVisibility *visibility) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_VISIBILITY, visibility);
  }
  explicit ObjectCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectCreateUpdate>(end);
    fbb_.Required(o, ObjectCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    noodles::ObjectDefinition definition_type = noodles::ObjectDefinition::NONE,
    flatbuffers::Offset<void> definition = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::PlotID>>> plots = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0,
    const noodles::BoundingBox *influence = 0,
    const noodles::ObjectVisibility *visibility = 0) {
  ObjectCreateUpdateBuilder builder_(_fbb);
  builder_.add_visibility(visibility);
  builder_.add_influence(influence);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_tags(tags);
  builder_.add_plots(plots);
  builder_.add_tables(tables);
  builder_.add_lights(lights);
  builder_.add_definition(definition);
  builder_.add_transform(transform);
  builder_.add_parent(parent);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_definition_type(definition_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    const char *name = nullptr,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    noodles::ObjectDefinition definition_type = noodles::ObjectDefinition::NONE,
    flatbuffers::Offset<void> definition = 0,
    const std::vector<flatbuffers::Offset<noodles::LightID>> *lights = nullptr,
    const std::vector<flatbuffers::Offset<noodles::TableID>> *tables = nullptr,
    const std::vector<flatbuffers::Offset<noodles::PlotID>> *plots = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr,
    const noodles::BoundingBox *influence = 0,
    const noodles::ObjectVisibility *visibility = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lights__ = lights ? _fbb.CreateVector<flatbuffers::Offset<noodles::LightID>>(*lights) : 0;
  auto tables__ = tables ? _fbb.CreateVector<flatbuffers::Offset<noodles::TableID>>(*tables) : 0;
  auto plots__ = plots ? _fbb.CreateVector<flatbuffers::Offset<noodles::PlotID>>(*plots) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateObjectCreateUpdate(
      _fbb,
      id,
      name__,
      parent,
      transform,
      definition_type,
      definition,
      lights__,
      tables__,
      plots__,
      tags__,
      methods_list__,
      signals_list__,
      influence,
      visibility);
}

struct ObjectDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct ObjectDeleteBuilder {
  typedef ObjectDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectDelete::VT_ID, id);
  }
  explicit ObjectDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectDelete>(end);
    fbb_.Required(o, ObjectDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectDelete> CreateObjectDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0) {
  ObjectDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SimplePlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimplePlotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SimplePlotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFINITION = 4
  };
  const flatbuffers::String *definition() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFINITION);
  }
  flatbuffers::String *mutable_definition() {
    return GetPointer<flatbuffers::String *>(VT_DEFINITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DEFINITION) &&
           verifier.VerifyString(definition()) &&
           verifier.EndTable();
  }
};

struct SimplePlotBuilder {
  typedef SimplePlot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_definition(flatbuffers::Offset<flatbuffers::String> definition) {
    fbb_.AddOffset(SimplePlot::VT_DEFINITION, definition);
  }
  explicit SimplePlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SimplePlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimplePlot>(end);
    fbb_.Required(o, SimplePlot::VT_DEFINITION);
    return o;
  }
};

inline flatbuffers::Offset<SimplePlot> CreateSimplePlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> definition = 0) {
  SimplePlotBuilder builder_(_fbb);
  builder_.add_definition(definition);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimplePlot> CreateSimplePlotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *definition = nullptr) {
  auto definition__ = definition ? _fbb.CreateString(definition) : 0;
  return noodles::CreateSimplePlot(
      _fbb,
      definition__);
}

struct URLPlot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef URLPlotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return URLPlotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4
  };
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           verifier.EndTable();
  }
};

struct URLPlotBuilder {
  typedef URLPlot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(URLPlot::VT_URL, url);
  }
  explicit URLPlotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<URLPlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<URLPlot>(end);
    fbb_.Required(o, URLPlot::VT_URL);
    return o;
  }
};

inline flatbuffers::Offset<URLPlot> CreateURLPlot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> url = 0) {
  URLPlotBuilder builder_(_fbb);
  builder_.add_url(url);
  return builder_.Finish();
}

inline flatbuffers::Offset<URLPlot> CreateURLPlotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateURLPlot(
      _fbb,
      url__);
}

struct PlotCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlotCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlotCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TABLE = 6,
    VT_TYPE_TYPE = 8,
    VT_TYPE = 10,
    VT_METHODS_LIST = 12,
    VT_SIGNALS_LIST = 14
  };
  const noodles::PlotID *id() const {
    return GetPointer<const noodles::PlotID *>(VT_ID);
  }
  noodles::PlotID *mutable_id() {
    return GetPointer<noodles::PlotID *>(VT_ID);
  }
  const noodles::TableID *table() const {
    return GetPointer<const noodles::TableID *>(VT_TABLE);
  }
  noodles::TableID *mutable_table() {
    return GetPointer<noodles::TableID *>(VT_TABLE);
  }
  noodles::PlotType type_type() const {
    return static_cast<noodles::PlotType>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const noodles::SimplePlot *type_as_SimplePlot() const {
    return type_type() == noodles::PlotType::SimplePlot ? static_cast<const noodles::SimplePlot *>(type()) : nullptr;
  }
  const noodles::URLPlot *type_as_URLPlot() const {
    return type_type() == noodles::PlotType::URLPlot ? static_cast<const noodles::URLPlot *>(type()) : nullptr;
  }
  void *mutable_type() {
    return GetPointer<void *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_TABLE) &&
           verifier.VerifyTable(table()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyPlotType(verifier, type(), type_type()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::SimplePlot *PlotCreateUpdate::type_as<noodles::SimplePlot>() const {
  return type_as_SimplePlot();
}

template<> inline const noodles::URLPlot *PlotCreateUpdate::type_as<noodles::URLPlot>() const {
  return type_as_URLPlot();
}

struct PlotCreateUpdateBuilder {
  typedef PlotCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::PlotID> id) {
    fbb_.AddOffset(PlotCreateUpdate::VT_ID, id);
  }
  void add_table(flatbuffers::Offset<noodles::TableID> table) {
    fbb_.AddOffset(PlotCreateUpdate::VT_TABLE, table);
  }
  void add_type_type(noodles::PlotType type_type) {
    fbb_.AddElement<uint8_t>(PlotCreateUpdate::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(PlotCreateUpdate::VT_TYPE, type);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(PlotCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(PlotCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit PlotCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlotCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlotCreateUpdate>(end);
    fbb_.Required(o, PlotCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<PlotCreateUpdate> CreatePlotCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0,
    flatbuffers::Offset<noodles::TableID> table = 0,
    noodles::PlotType type_type = noodles::PlotType::NONE,
    flatbuffers::Offset<void> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  PlotCreateUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_type(type);
  builder_.add_table(table);
  builder_.add_id(id);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlotCreateUpdate> CreatePlotCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0,
    flatbuffers::Offset<noodles::TableID> table = 0,
    noodles::PlotType type_type = noodles::PlotType::NONE,
    flatbuffers::Offset<void> type = 0,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreatePlotCreateUpdate(
      _fbb,
      id,
      table,
      type_type,
      type,
      methods_list__,
      signals_list__);
}

struct PlotDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlotDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlotDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::PlotID *id() const {
    return GetPointer<const noodles::PlotID *>(VT_ID);
  }
  noodles::PlotID *mutable_id() {
    return GetPointer<noodles::PlotID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct PlotDeleteBuilder {
  typedef PlotDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::PlotID> id) {
    fbb_.AddOffset(PlotDelete::VT_ID, id);
  }
  explicit PlotDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlotDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlotDelete>(end);
    fbb_.Required(o, PlotDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<PlotDelete> CreatePlotDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::PlotID> id = 0) {
  PlotDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct BufferCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BYTES = 6,
    VT_URL = 8,
    VT_SIZE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  const flatbuffers::Vector<int8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  flatbuffers::Vector<int8_t> *mutable_bytes() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct BufferCreateBuilder {
  typedef BufferCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferCreate::VT_ID, id);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes) {
    fbb_.AddOffset(BufferCreate::VT_BYTES, bytes);
  }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(BufferCreate::VT_URL, url);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(BufferCreate::VT_SIZE, size, 0);
  }
  explicit BufferCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferCreate>(end);
    fbb_.Required(o, BufferCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferCreate> CreateBufferCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    uint64_t size = 0) {
  BufferCreateBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_url(url);
  builder_.add_bytes(bytes);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<BufferCreate> CreateBufferCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    const std::vector<int8_t> *bytes = nullptr,
    const char *url = nullptr,
    uint64_t size = 0) {
  auto bytes__ = bytes ? _fbb.CreateVector<int8_t>(*bytes) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateBufferCreate(
      _fbb,
      id,
      bytes__,
      url__,
      size);
}

struct BufferDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct BufferDeleteBuilder {
  typedef BufferDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferDelete::VT_ID, id);
  }
  explicit BufferDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferDelete>(end);
    fbb_.Required(o, BufferDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferDelete> CreateBufferDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0) {
  BufferDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MaterialCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_METALLIC = 8,
    VT_ROUGHNESS = 10,
    VT_USE_BLENDING = 12,
    VT_TEXTURE_ID = 14
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  const noodles::Vec4 *color() const {
    return GetStruct<const noodles::Vec4 *>(VT_COLOR);
  }
  noodles::Vec4 *mutable_color() {
    return GetStruct<noodles::Vec4 *>(VT_COLOR);
  }
  float metallic() const {
    return GetField<float>(VT_METALLIC, 0.0f);
  }
  bool mutate_metallic(float _metallic) {
    return SetField<float>(VT_METALLIC, _metallic, 0.0f);
  }
  float roughness() const {
    return GetField<float>(VT_ROUGHNESS, 0.0f);
  }
  bool mutate_roughness(float _roughness) {
    return SetField<float>(VT_ROUGHNESS, _roughness, 0.0f);
  }
  bool use_blending() const {
    return GetField<uint8_t>(VT_USE_BLENDING, 0) != 0;
  }
  bool mutate_use_blending(bool _use_blending) {
    return SetField<uint8_t>(VT_USE_BLENDING, static_cast<uint8_t>(_use_blending), 0);
  }
  const noodles::TextureID *texture_id() const {
    return GetPointer<const noodles::TextureID *>(VT_TEXTURE_ID);
  }
  noodles::TextureID *mutable_texture_id() {
    return GetPointer<noodles::TextureID *>(VT_TEXTURE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::Vec4>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_METALLIC) &&
           VerifyField<float>(verifier, VT_ROUGHNESS) &&
           VerifyField<uint8_t>(verifier, VT_USE_BLENDING) &&
           VerifyOffset(verifier, VT_TEXTURE_ID) &&
           verifier.VerifyTable(texture_id()) &&
           verifier.EndTable();
  }
};

struct MaterialCreateUpdateBuilder {
  typedef MaterialCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::Vec4 *color) {
    fbb_.AddStruct(MaterialCreateUpdate::VT_COLOR, color);
  }
  void add_metallic(float metallic) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_METALLIC, metallic, 0.0f);
  }
  void add_roughness(float roughness) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_ROUGHNESS, roughness, 0.0f);
  }
  void add_use_blending(bool use_blending) {
    fbb_.AddElement<uint8_t>(MaterialCreateUpdate::VT_USE_BLENDING, static_cast<uint8_t>(use_blending), 0);
  }
  void add_texture_id(flatbuffers::Offset<noodles::TextureID> texture_id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_TEXTURE_ID, texture_id);
  }
  explicit MaterialCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialCreateUpdate>(end);
    fbb_.Required(o, MaterialCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialCreateUpdate> CreateMaterialCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0,
    const noodles::Vec4 *color = 0,
    float metallic = 0.0f,
    float roughness = 0.0f,
    bool use_blending = false,
    flatbuffers::Offset<noodles::TextureID> texture_id = 0) {
  MaterialCreateUpdateBuilder builder_(_fbb);
  builder_.add_texture_id(texture_id);
  builder_.add_roughness(roughness);
  builder_.add_metallic(metallic);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_use_blending(use_blending);
  return builder_.Finish();
}

struct MaterialDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MaterialDeleteBuilder {
  typedef MaterialDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialDelete::VT_ID, id);
  }
  explicit MaterialDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaterialDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialDelete>(end);
    fbb_.Required(o, MaterialDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialDelete> CreateMaterialDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0) {
  MaterialDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REFERENCE = 6
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  const noodles::BufferRef *reference() const {
    return GetPointer<const noodles::BufferRef *>(VT_REFERENCE);
  }
  noodles::BufferRef *mutable_reference() {
    return GetPointer<noodles::BufferRef *>(VT_REFERENCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE) &&
           verifier.VerifyTable(reference()) &&
           verifier.EndTable();
  }
};

struct TextureCreateUpdateBuilder {
  typedef TextureCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureCreateUpdate::VT_ID, id);
  }
  void add_reference(flatbuffers::Offset<noodles::BufferRef> reference) {
    fbb_.AddOffset(TextureCreateUpdate::VT_REFERENCE, reference);
  }
  explicit TextureCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureCreateUpdate>(end);
    fbb_.Required(o, TextureCreateUpdate::VT_ID);
    fbb_.Required(o, TextureCreateUpdate::VT_REFERENCE);
    return o;
  }
};

inline flatbuffers::Offset<TextureCreateUpdate> CreateTextureCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0,
    flatbuffers::Offset<noodles::BufferRef> reference = 0) {
  TextureCreateUpdateBuilder builder_(_fbb);
  builder_.add_reference(reference);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TextureDeleteBuilder {
  typedef TextureDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureDelete::VT_ID, id);
  }
  explicit TextureDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureDelete>(end);
    fbb_.Required(o, TextureDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TextureDelete> CreateTextureDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0) {
  TextureDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct LightCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_INTENSITY = 8,
    VT_SPATIAL = 10,
    VT_LIGHT_TYPE = 12
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  const noodles::RGB *color() const {
    return GetStruct<const noodles::RGB *>(VT_COLOR);
  }
  noodles::RGB *mutable_color() {
    return GetStruct<noodles::RGB *>(VT_COLOR);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool mutate_intensity(float _intensity) {
    return SetField<float>(VT_INTENSITY, _intensity, 0.0f);
  }
  const noodles::Vec4 *spatial() const {
    return GetStruct<const noodles::Vec4 *>(VT_SPATIAL);
  }
  noodles::Vec4 *mutable_spatial() {
    return GetStruct<noodles::Vec4 *>(VT_SPATIAL);
  }
  noodles::LightType light_type() const {
    return static_cast<noodles::LightType>(GetField<int8_t>(VT_LIGHT_TYPE, 0));
  }
  bool mutate_light_type(noodles::LightType _light_type) {
    return SetField<int8_t>(VT_LIGHT_TYPE, static_cast<int8_t>(_light_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::RGB>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           VerifyField<noodles::Vec4>(verifier, VT_SPATIAL) &&
           VerifyField<int8_t>(verifier, VT_LIGHT_TYPE) &&
           verifier.EndTable();
  }
};

struct LightCreateUpdateBuilder {
  typedef LightCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::RGB *color) {
    fbb_.AddStruct(LightCreateUpdate::VT_COLOR, color);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightCreateUpdate::VT_INTENSITY, intensity, 0.0f);
  }
  void add_spatial(const noodles::Vec4 *spatial) {
    fbb_.AddStruct(LightCreateUpdate::VT_SPATIAL, spatial);
  }
  void add_light_type(noodles::LightType light_type) {
    fbb_.AddElement<int8_t>(LightCreateUpdate::VT_LIGHT_TYPE, static_cast<int8_t>(light_type), 0);
  }
  explicit LightCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LightCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightCreateUpdate>(end);
    fbb_.Required(o, LightCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightCreateUpdate> CreateLightCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0,
    const noodles::RGB *color = 0,
    float intensity = 0.0f,
    const noodles::Vec4 *spatial = 0,
    noodles::LightType light_type = noodles::LightType::POINT) {
  LightCreateUpdateBuilder builder_(_fbb);
  builder_.add_spatial(spatial);
  builder_.add_intensity(intensity);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_light_type(light_type);
  return builder_.Finish();
}

struct LightDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct LightDeleteBuilder {
  typedef LightDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightDelete::VT_ID, id);
  }
  explicit LightDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LightDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightDelete>(end);
    fbb_.Required(o, LightDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightDelete> CreateLightDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0) {
  LightDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ComponentRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ComponentRefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ComponentRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_START = 6,
    VT_SIZE = 8,
    VT_STRIDE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  uint64_t stride() const {
    return GetField<uint64_t>(VT_STRIDE, 0);
  }
  bool mutate_stride(uint64_t _stride) {
    return SetField<uint64_t>(VT_STRIDE, _stride, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint64_t>(verifier, VT_START) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_STRIDE) &&
           verifier.EndTable();
  }
};

struct ComponentRefBuilder {
  typedef ComponentRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(ComponentRef::VT_ID, id);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_START, start, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_SIZE, size, 0);
  }
  void add_stride(uint64_t stride) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_STRIDE, stride, 0);
  }
  explicit ComponentRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ComponentRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComponentRef>(end);
    fbb_.Required(o, ComponentRef::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ComponentRef> CreateComponentRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    uint64_t start = 0,
    uint64_t size = 0,
    uint64_t stride = 0) {
  ComponentRefBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_size(size);
  builder_.add_start(start);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_EXTENT = 6,
    VT_POSITIONS = 8,
    VT_NORMALS = 10,
    VT_TEX_COORDS = 12,
    VT_COLORS = 14,
    VT_LINES = 16,
    VT_TRIANGLES = 18
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  const noodles::BoundingBox *extent() const {
    return GetStruct<const noodles::BoundingBox *>(VT_EXTENT);
  }
  noodles::BoundingBox *mutable_extent() {
    return GetStruct<noodles::BoundingBox *>(VT_EXTENT);
  }
  const noodles::ComponentRef *positions() const {
    return GetPointer<const noodles::ComponentRef *>(VT_POSITIONS);
  }
  noodles::ComponentRef *mutable_positions() {
    return GetPointer<noodles::ComponentRef *>(VT_POSITIONS);
  }
  const noodles::ComponentRef *normals() const {
    return GetPointer<const noodles::ComponentRef *>(VT_NORMALS);
  }
  noodles::ComponentRef *mutable_normals() {
    return GetPointer<noodles::ComponentRef *>(VT_NORMALS);
  }
  const noodles::ComponentRef *tex_coords() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TEX_COORDS);
  }
  noodles::ComponentRef *mutable_tex_coords() {
    return GetPointer<noodles::ComponentRef *>(VT_TEX_COORDS);
  }
  const noodles::ComponentRef *colors() const {
    return GetPointer<const noodles::ComponentRef *>(VT_COLORS);
  }
  noodles::ComponentRef *mutable_colors() {
    return GetPointer<noodles::ComponentRef *>(VT_COLORS);
  }
  const noodles::ComponentRef *lines() const {
    return GetPointer<const noodles::ComponentRef *>(VT_LINES);
  }
  noodles::ComponentRef *mutable_lines() {
    return GetPointer<noodles::ComponentRef *>(VT_LINES);
  }
  const noodles::ComponentRef *triangles() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TRIANGLES);
  }
  noodles::ComponentRef *mutable_triangles() {
    return GetPointer<noodles::ComponentRef *>(VT_TRIANGLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::BoundingBox>(verifier, VT_EXTENT) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyTable(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyTable(normals()) &&
           VerifyOffset(verifier, VT_TEX_COORDS) &&
           verifier.VerifyTable(tex_coords()) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyTable(colors()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyTable(lines()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyTable(triangles()) &&
           verifier.EndTable();
  }
};

struct GeometryCreateBuilder {
  typedef GeometryCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryCreate::VT_ID, id);
  }
  void add_extent(const noodles::BoundingBox *extent) {
    fbb_.AddStruct(GeometryCreate::VT_EXTENT, extent);
  }
  void add_positions(flatbuffers::Offset<noodles::ComponentRef> positions) {
    fbb_.AddOffset(GeometryCreate::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<noodles::ComponentRef> normals) {
    fbb_.AddOffset(GeometryCreate::VT_NORMALS, normals);
  }
  void add_tex_coords(flatbuffers::Offset<noodles::ComponentRef> tex_coords) {
    fbb_.AddOffset(GeometryCreate::VT_TEX_COORDS, tex_coords);
  }
  void add_colors(flatbuffers::Offset<noodles::ComponentRef> colors) {
    fbb_.AddOffset(GeometryCreate::VT_COLORS, colors);
  }
  void add_lines(flatbuffers::Offset<noodles::ComponentRef> lines) {
    fbb_.AddOffset(GeometryCreate::VT_LINES, lines);
  }
  void add_triangles(flatbuffers::Offset<noodles::ComponentRef> triangles) {
    fbb_.AddOffset(GeometryCreate::VT_TRIANGLES, triangles);
  }
  explicit GeometryCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryCreate>(end);
    fbb_.Required(o, GeometryCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryCreate> CreateGeometryCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0,
    const noodles::BoundingBox *extent = 0,
    flatbuffers::Offset<noodles::ComponentRef> positions = 0,
    flatbuffers::Offset<noodles::ComponentRef> normals = 0,
    flatbuffers::Offset<noodles::ComponentRef> tex_coords = 0,
    flatbuffers::Offset<noodles::ComponentRef> colors = 0,
    flatbuffers::Offset<noodles::ComponentRef> lines = 0,
    flatbuffers::Offset<noodles::ComponentRef> triangles = 0) {
  GeometryCreateBuilder builder_(_fbb);
  builder_.add_triangles(triangles);
  builder_.add_lines(lines);
  builder_.add_colors(colors);
  builder_.add_tex_coords(tex_coords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  builder_.add_extent(extent);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct GeometryDeleteBuilder {
  typedef GeometryDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryDelete::VT_ID, id);
  }
  explicit GeometryDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeometryDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDelete>(end);
    fbb_.Required(o, GeometryDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDelete> CreateGeometryDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0) {
  GeometryDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TableCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_META = 8,
    VT_METHODS_LIST = 10,
    VT_SIGNALS_LIST = 12
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *meta() const {
    return GetPointer<const flatbuffers::String *>(VT_META);
  }
  flatbuffers::String *mutable_meta() {
    return GetPointer<flatbuffers::String *>(VT_META);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyString(meta()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct TableCreateUpdateBuilder {
  typedef TableCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableCreateUpdate::VT_NAME, name);
  }
  void add_meta(flatbuffers::Offset<flatbuffers::String> meta) {
    fbb_.AddOffset(TableCreateUpdate::VT_META, meta);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit TableCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableCreateUpdate>(end);
    fbb_.Required(o, TableCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> meta = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  TableCreateUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_meta(meta);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    const char *name = nullptr,
    const char *meta = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto meta__ = meta ? _fbb.CreateString(meta) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateTableCreateUpdate(
      _fbb,
      id,
      name__,
      meta__,
      methods_list__,
      signals_list__);
}

struct TableDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TableDeleteBuilder {
  typedef TableDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableDelete::VT_ID, id);
  }
  explicit TableDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableDelete>(end);
    fbb_.Required(o, TableDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableDelete> CreateTableDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0) {
  TableDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct DocumentUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS_LIST = 4,
    VT_SIGNALS_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct DocumentUpdateBuilder {
  typedef DocumentUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(DocumentUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(DocumentUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit DocumentUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DocumentUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  DocumentUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateDocumentUpdate(
      _fbb,
      methods_list__,
      signals_list__);
}

struct DocumentReset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentResetBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentResetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4
  };
  bool padding() const {
    return GetField<uint8_t>(VT_PADDING, 0) != 0;
  }
  bool mutate_padding(bool _padding) {
    return SetField<uint8_t>(VT_PADDING, static_cast<uint8_t>(_padding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PADDING) &&
           verifier.EndTable();
  }
};

struct DocumentResetBuilder {
  typedef DocumentReset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(bool padding) {
    fbb_.AddElement<uint8_t>(DocumentReset::VT_PADDING, static_cast<uint8_t>(padding), 0);
  }
  explicit DocumentResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DocumentReset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentReset>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentReset> CreateDocumentReset(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool padding = false) {
  DocumentResetBuilder builder_(_fbb);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct SignalInvoke FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalInvokeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalInvokeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ON_OBJECT = 6,
    VT_ON_TABLE = 8,
    VT_ON_PLOT = 10,
    VT_SIGNAL_DATA = 12
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const noodles::ObjectID *on_object() const {
    return GetPointer<const noodles::ObjectID *>(VT_ON_OBJECT);
  }
  noodles::ObjectID *mutable_on_object() {
    return GetPointer<noodles::ObjectID *>(VT_ON_OBJECT);
  }
  const noodles::TableID *on_table() const {
    return GetPointer<const noodles::TableID *>(VT_ON_TABLE);
  }
  noodles::TableID *mutable_on_table() {
    return GetPointer<noodles::TableID *>(VT_ON_TABLE);
  }
  const noodles::PlotID *on_plot() const {
    return GetPointer<const noodles::PlotID *>(VT_ON_PLOT);
  }
  noodles::PlotID *mutable_on_plot() {
    return GetPointer<noodles::PlotID *>(VT_ON_PLOT);
  }
  const noodles::AnyList *signal_data() const {
    return GetPointer<const noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  noodles::AnyList *mutable_signal_data() {
    return GetPointer<noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_ON_OBJECT) &&
           verifier.VerifyTable(on_object()) &&
           VerifyOffset(verifier, VT_ON_TABLE) &&
           verifier.VerifyTable(on_table()) &&
           VerifyOffset(verifier, VT_ON_PLOT) &&
           verifier.VerifyTable(on_plot()) &&
           VerifyOffset(verifier, VT_SIGNAL_DATA) &&
           verifier.VerifyTable(signal_data()) &&
           verifier.EndTable();
  }
};

struct SignalInvokeBuilder {
  typedef SignalInvoke Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalInvoke::VT_ID, id);
  }
  void add_on_object(flatbuffers::Offset<noodles::ObjectID> on_object) {
    fbb_.AddOffset(SignalInvoke::VT_ON_OBJECT, on_object);
  }
  void add_on_table(flatbuffers::Offset<noodles::TableID> on_table) {
    fbb_.AddOffset(SignalInvoke::VT_ON_TABLE, on_table);
  }
  void add_on_plot(flatbuffers::Offset<noodles::PlotID> on_plot) {
    fbb_.AddOffset(SignalInvoke::VT_ON_PLOT, on_plot);
  }
  void add_signal_data(flatbuffers::Offset<noodles::AnyList> signal_data) {
    fbb_.AddOffset(SignalInvoke::VT_SIGNAL_DATA, signal_data);
  }
  explicit SignalInvokeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalInvoke> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalInvoke>(end);
    fbb_.Required(o, SignalInvoke::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalInvoke> CreateSignalInvoke(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::PlotID> on_plot = 0,
    flatbuffers::Offset<noodles::AnyList> signal_data = 0) {
  SignalInvokeBuilder builder_(_fbb);
  builder_.add_signal_data(signal_data);
  builder_.add_on_plot(on_plot);
  builder_.add_on_table(on_table);
  builder_.add_on_object(on_object);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodExceptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodExceptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  int64_t code() const {
    return GetField<int64_t>(VT_CODE, 0);
  }
  bool mutate_code(int64_t _code) {
    return SetField<int64_t>(VT_CODE, _code, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  const noodles::Any *data() const {
    return GetPointer<const noodles::Any *>(VT_DATA);
  }
  noodles::Any *mutable_data() {
    return GetPointer<noodles::Any *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct MethodExceptionBuilder {
  typedef MethodException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int64_t code) {
    fbb_.AddElement<int64_t>(MethodException::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(MethodException::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<noodles::Any> data) {
    fbb_.AddOffset(MethodException::VT_DATA, data);
  }
  explicit MethodExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodException>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodException> CreateMethodException(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<noodles::Any> data = 0) {
  MethodExceptionBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodException> CreateMethodExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    const char *message = nullptr,
    flatbuffers::Offset<noodles::Any> data = 0) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return noodles::CreateMethodException(
      _fbb,
      code,
      message__,
      data);
}

struct MethodReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodReplyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodReplyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVOKE_IDENT = 4,
    VT_METHOD_DATA = 6,
    VT_METHOD_EXCEPTION = 8
  };
  const flatbuffers::String *invoke_ident() const {
    return GetPointer<const flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  flatbuffers::String *mutable_invoke_ident() {
    return GetPointer<flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  const noodles::Any *method_data() const {
    return GetPointer<const noodles::Any *>(VT_METHOD_DATA);
  }
  noodles::Any *mutable_method_data() {
    return GetPointer<noodles::Any *>(VT_METHOD_DATA);
  }
  const noodles::MethodException *method_exception() const {
    return GetPointer<const noodles::MethodException *>(VT_METHOD_EXCEPTION);
  }
  noodles::MethodException *mutable_method_exception() {
    return GetPointer<noodles::MethodException *>(VT_METHOD_EXCEPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INVOKE_IDENT) &&
           verifier.VerifyString(invoke_ident()) &&
           VerifyOffset(verifier, VT_METHOD_DATA) &&
           verifier.VerifyTable(method_data()) &&
           VerifyOffset(verifier, VT_METHOD_EXCEPTION) &&
           verifier.VerifyTable(method_exception()) &&
           verifier.EndTable();
  }
};

struct MethodReplyBuilder {
  typedef MethodReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_invoke_ident(flatbuffers::Offset<flatbuffers::String> invoke_ident) {
    fbb_.AddOffset(MethodReply::VT_INVOKE_IDENT, invoke_ident);
  }
  void add_method_data(flatbuffers::Offset<noodles::Any> method_data) {
    fbb_.AddOffset(MethodReply::VT_METHOD_DATA, method_data);
  }
  void add_method_exception(flatbuffers::Offset<noodles::MethodException> method_exception) {
    fbb_.AddOffset(MethodReply::VT_METHOD_EXCEPTION, method_exception);
  }
  explicit MethodReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodReply>(end);
    fbb_.Required(o, MethodReply::VT_INVOKE_IDENT);
    return o;
  }
};

inline flatbuffers::Offset<MethodReply> CreateMethodReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> invoke_ident = 0,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    flatbuffers::Offset<noodles::MethodException> method_exception = 0) {
  MethodReplyBuilder builder_(_fbb);
  builder_.add_method_exception(method_exception);
  builder_.add_method_data(method_data);
  builder_.add_invoke_ident(invoke_ident);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodReply> CreateMethodReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *invoke_ident = nullptr,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    flatbuffers::Offset<noodles::MethodException> method_exception = 0) {
  auto invoke_ident__ = invoke_ident ? _fbb.CreateString(invoke_ident) : 0;
  return noodles::CreateMethodReply(
      _fbb,
      invoke_ident__,
      method_data,
      method_exception);
}

struct ServerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  noodles::ServerMessageType message_type() const {
    return static_cast<noodles::ServerMessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const noodles::MethodCreate *message_as_MethodCreate() const {
    return message_type() == noodles::ServerMessageType::MethodCreate ? static_cast<const noodles::MethodCreate *>(message()) : nullptr;
  }
  const noodles::MethodDelete *message_as_MethodDelete() const {
    return message_type() == noodles::ServerMessageType::MethodDelete ? static_cast<const noodles::MethodDelete *>(message()) : nullptr;
  }
  const noodles::SignalCreate *message_as_SignalCreate() const {
    return message_type() == noodles::ServerMessageType::SignalCreate ? static_cast<const noodles::SignalCreate *>(message()) : nullptr;
  }
  const noodles::SignalDelete *message_as_SignalDelete() const {
    return message_type() == noodles::ServerMessageType::SignalDelete ? static_cast<const noodles::SignalDelete *>(message()) : nullptr;
  }
  const noodles::ObjectCreateUpdate *message_as_ObjectCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::ObjectCreateUpdate ? static_cast<const noodles::ObjectCreateUpdate *>(message()) : nullptr;
  }
  const noodles::ObjectDelete *message_as_ObjectDelete() const {
    return message_type() == noodles::ServerMessageType::ObjectDelete ? static_cast<const noodles::ObjectDelete *>(message()) : nullptr;
  }
  const noodles::BufferCreate *message_as_BufferCreate() const {
    return message_type() == noodles::ServerMessageType::BufferCreate ? static_cast<const noodles::BufferCreate *>(message()) : nullptr;
  }
  const noodles::BufferDelete *message_as_BufferDelete() const {
    return message_type() == noodles::ServerMessageType::BufferDelete ? static_cast<const noodles::BufferDelete *>(message()) : nullptr;
  }
  const noodles::MaterialCreateUpdate *message_as_MaterialCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::MaterialCreateUpdate ? static_cast<const noodles::MaterialCreateUpdate *>(message()) : nullptr;
  }
  const noodles::MaterialDelete *message_as_MaterialDelete() const {
    return message_type() == noodles::ServerMessageType::MaterialDelete ? static_cast<const noodles::MaterialDelete *>(message()) : nullptr;
  }
  const noodles::TextureCreateUpdate *message_as_TextureCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TextureCreateUpdate ? static_cast<const noodles::TextureCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TextureDelete *message_as_TextureDelete() const {
    return message_type() == noodles::ServerMessageType::TextureDelete ? static_cast<const noodles::TextureDelete *>(message()) : nullptr;
  }
  const noodles::LightCreateUpdate *message_as_LightCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::LightCreateUpdate ? static_cast<const noodles::LightCreateUpdate *>(message()) : nullptr;
  }
  const noodles::LightDelete *message_as_LightDelete() const {
    return message_type() == noodles::ServerMessageType::LightDelete ? static_cast<const noodles::LightDelete *>(message()) : nullptr;
  }
  const noodles::GeometryCreate *message_as_GeometryCreate() const {
    return message_type() == noodles::ServerMessageType::GeometryCreate ? static_cast<const noodles::GeometryCreate *>(message()) : nullptr;
  }
  const noodles::GeometryDelete *message_as_GeometryDelete() const {
    return message_type() == noodles::ServerMessageType::GeometryDelete ? static_cast<const noodles::GeometryDelete *>(message()) : nullptr;
  }
  const noodles::TableCreateUpdate *message_as_TableCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TableCreateUpdate ? static_cast<const noodles::TableCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TableDelete *message_as_TableDelete() const {
    return message_type() == noodles::ServerMessageType::TableDelete ? static_cast<const noodles::TableDelete *>(message()) : nullptr;
  }
  const noodles::DocumentUpdate *message_as_DocumentUpdate() const {
    return message_type() == noodles::ServerMessageType::DocumentUpdate ? static_cast<const noodles::DocumentUpdate *>(message()) : nullptr;
  }
  const noodles::DocumentReset *message_as_DocumentReset() const {
    return message_type() == noodles::ServerMessageType::DocumentReset ? static_cast<const noodles::DocumentReset *>(message()) : nullptr;
  }
  const noodles::SignalInvoke *message_as_SignalInvoke() const {
    return message_type() == noodles::ServerMessageType::SignalInvoke ? static_cast<const noodles::SignalInvoke *>(message()) : nullptr;
  }
  const noodles::MethodReply *message_as_MethodReply() const {
    return message_type() == noodles::ServerMessageType::MethodReply ? static_cast<const noodles::MethodReply *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyServerMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::MethodCreate *ServerMessage::message_as<noodles::MethodCreate>() const {
  return message_as_MethodCreate();
}

template<> inline const noodles::MethodDelete *ServerMessage::message_as<noodles::MethodDelete>() const {
  return message_as_MethodDelete();
}

template<> inline const noodles::SignalCreate *ServerMessage::message_as<noodles::SignalCreate>() const {
  return message_as_SignalCreate();
}

template<> inline const noodles::SignalDelete *ServerMessage::message_as<noodles::SignalDelete>() const {
  return message_as_SignalDelete();
}

template<> inline const noodles::ObjectCreateUpdate *ServerMessage::message_as<noodles::ObjectCreateUpdate>() const {
  return message_as_ObjectCreateUpdate();
}

template<> inline const noodles::ObjectDelete *ServerMessage::message_as<noodles::ObjectDelete>() const {
  return message_as_ObjectDelete();
}

template<> inline const noodles::BufferCreate *ServerMessage::message_as<noodles::BufferCreate>() const {
  return message_as_BufferCreate();
}

template<> inline const noodles::BufferDelete *ServerMessage::message_as<noodles::BufferDelete>() const {
  return message_as_BufferDelete();
}

template<> inline const noodles::MaterialCreateUpdate *ServerMessage::message_as<noodles::MaterialCreateUpdate>() const {
  return message_as_MaterialCreateUpdate();
}

template<> inline const noodles::MaterialDelete *ServerMessage::message_as<noodles::MaterialDelete>() const {
  return message_as_MaterialDelete();
}

template<> inline const noodles::TextureCreateUpdate *ServerMessage::message_as<noodles::TextureCreateUpdate>() const {
  return message_as_TextureCreateUpdate();
}

template<> inline const noodles::TextureDelete *ServerMessage::message_as<noodles::TextureDelete>() const {
  return message_as_TextureDelete();
}

template<> inline const noodles::LightCreateUpdate *ServerMessage::message_as<noodles::LightCreateUpdate>() const {
  return message_as_LightCreateUpdate();
}

template<> inline const noodles::LightDelete *ServerMessage::message_as<noodles::LightDelete>() const {
  return message_as_LightDelete();
}

template<> inline const noodles::GeometryCreate *ServerMessage::message_as<noodles::GeometryCreate>() const {
  return message_as_GeometryCreate();
}

template<> inline const noodles::GeometryDelete *ServerMessage::message_as<noodles::GeometryDelete>() const {
  return message_as_GeometryDelete();
}

template<> inline const noodles::TableCreateUpdate *ServerMessage::message_as<noodles::TableCreateUpdate>() const {
  return message_as_TableCreateUpdate();
}

template<> inline const noodles::TableDelete *ServerMessage::message_as<noodles::TableDelete>() const {
  return message_as_TableDelete();
}

template<> inline const noodles::DocumentUpdate *ServerMessage::message_as<noodles::DocumentUpdate>() const {
  return message_as_DocumentUpdate();
}

template<> inline const noodles::DocumentReset *ServerMessage::message_as<noodles::DocumentReset>() const {
  return message_as_DocumentReset();
}

template<> inline const noodles::SignalInvoke *ServerMessage::message_as<noodles::SignalInvoke>() const {
  return message_as_SignalInvoke();
}

template<> inline const noodles::MethodReply *ServerMessage::message_as<noodles::MethodReply>() const {
  return message_as_MethodReply();
}

struct ServerMessageBuilder {
  typedef ServerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(noodles::ServerMessageType message_type) {
    fbb_.AddElement<uint8_t>(ServerMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ServerMessage::VT_MESSAGE, message);
  }
  explicit ServerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessage> CreateServerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::ServerMessageType message_type = noodles::ServerMessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  ServerMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct ServerMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessagesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessagesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ServerMessagesBuilder {
  typedef ServerMessages Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages) {
    fbb_.AddOffset(ServerMessages::VT_MESSAGES, messages);
  }
  explicit ServerMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerMessages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessages>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessages> CreateServerMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages = 0) {
  ServerMessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerMessages> CreateServerMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::ServerMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<noodles::ServerMessage>>(*messages) : 0;
  return noodles::CreateServerMessages(
      _fbb,
      messages__);
}

inline bool VerifyObjectDefinition(flatbuffers::Verifier &verifier, const void *obj, ObjectDefinition type) {
  switch (type) {
    case ObjectDefinition::NONE: {
      return true;
    }
    case ObjectDefinition::EmptyDefinition: {
      auto ptr = reinterpret_cast<const noodles::EmptyDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::TextDefinition: {
      auto ptr = reinterpret_cast<const noodles::TextDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::WebpageDefinition: {
      auto ptr = reinterpret_cast<const noodles::WebpageDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectDefinition::RenderableDefinition: {
      auto ptr = reinterpret_cast<const noodles::RenderableDefinition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectDefinitionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectDefinition(
        verifier,  values->Get(i), types->GetEnum<ObjectDefinition>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPlotType(flatbuffers::Verifier &verifier, const void *obj, PlotType type) {
  switch (type) {
    case PlotType::NONE: {
      return true;
    }
    case PlotType::SimplePlot: {
      auto ptr = reinterpret_cast<const noodles::SimplePlot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PlotType::URLPlot: {
      auto ptr = reinterpret_cast<const noodles::URLPlot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPlotTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPlotType(
        verifier,  values->Get(i), types->GetEnum<PlotType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type) {
  switch (type) {
    case ServerMessageType::NONE: {
      return true;
    }
    case ServerMessageType::MethodCreate: {
      auto ptr = reinterpret_cast<const noodles::MethodCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodDelete: {
      auto ptr = reinterpret_cast<const noodles::MethodDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalCreate: {
      auto ptr = reinterpret_cast<const noodles::SignalCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalDelete: {
      auto ptr = reinterpret_cast<const noodles::SignalDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::ObjectCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectDelete: {
      auto ptr = reinterpret_cast<const noodles::ObjectDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferCreate: {
      auto ptr = reinterpret_cast<const noodles::BufferCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferDelete: {
      auto ptr = reinterpret_cast<const noodles::BufferDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::MaterialCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialDelete: {
      auto ptr = reinterpret_cast<const noodles::MaterialDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TextureCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureDelete: {
      auto ptr = reinterpret_cast<const noodles::TextureDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::LightCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightDelete: {
      auto ptr = reinterpret_cast<const noodles::LightDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryCreate: {
      auto ptr = reinterpret_cast<const noodles::GeometryCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryDelete: {
      auto ptr = reinterpret_cast<const noodles::GeometryDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TableCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableDelete: {
      auto ptr = reinterpret_cast<const noodles::TableDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentUpdate: {
      auto ptr = reinterpret_cast<const noodles::DocumentUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentReset: {
      auto ptr = reinterpret_cast<const noodles::DocumentReset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalInvoke: {
      auto ptr = reinterpret_cast<const noodles::SignalInvoke *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodReply: {
      auto ptr = reinterpret_cast<const noodles::MethodReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerMessageType(
        verifier,  values->Get(i), types->GetEnum<ServerMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *ObjectDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::EmptyDefinitionTypeTable,
    noodles::TextDefinitionTypeTable,
    noodles::WebpageDefinitionTypeTable,
    noodles::RenderableDefinitionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EmptyDefinition",
    "TextDefinition",
    "WebpageDefinition",
    "RenderableDefinition"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SimplePlotTypeTable,
    noodles::URLPlotTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "SimplePlot",
    "URLPlot"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightTypeTypeTable
  };
  static const char * const names[] = {
    "POINT",
    "SUN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodCreateTypeTable,
    noodles::MethodDeleteTypeTable,
    noodles::SignalCreateTypeTable,
    noodles::SignalDeleteTypeTable,
    noodles::ObjectCreateUpdateTypeTable,
    noodles::ObjectDeleteTypeTable,
    noodles::BufferCreateTypeTable,
    noodles::BufferDeleteTypeTable,
    noodles::MaterialCreateUpdateTypeTable,
    noodles::MaterialDeleteTypeTable,
    noodles::TextureCreateUpdateTypeTable,
    noodles::TextureDeleteTypeTable,
    noodles::LightCreateUpdateTypeTable,
    noodles::LightDeleteTypeTable,
    noodles::GeometryCreateTypeTable,
    noodles::GeometryDeleteTypeTable,
    noodles::TableCreateUpdateTypeTable,
    noodles::TableDeleteTypeTable,
    noodles::DocumentUpdateTypeTable,
    noodles::DocumentResetTypeTable,
    noodles::SignalInvokeTypeTable,
    noodles::MethodReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 23, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodArgTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "doc",
    "hint"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "return_doc",
    "arg_doc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "arg_doc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmptyDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "text",
    "font",
    "height",
    "width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebpageDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "url",
    "height",
    "width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RenderableDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable,
    noodles::GeometryIDTypeTable,
    noodles::Mat4TypeTable,
    noodles::BoundingBoxTypeTable
  };
  static const char * const names[] = {
    "material",
    "mesh",
    "instances",
    "instance_bb"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectVisibilityTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const int64_t values[] = { 0, 1 };
  static const char * const names[] = {
    "visible"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 1, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UTYPE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_SEQUENCE, 1, 5 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_SEQUENCE, 1, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable,
    noodles::Mat4TypeTable,
    noodles::ObjectDefinitionTypeTable,
    noodles::LightIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable,
    noodles::BoundingBoxTypeTable,
    noodles::ObjectVisibilityTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "parent",
    "transform",
    "definition_type",
    "definition",
    "lights",
    "tables",
    "plots",
    "tags",
    "methods_list",
    "signals_list",
    "influence",
    "visibility"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SimplePlotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "definition"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *URLPlotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "url"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UTYPE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::PlotIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotTypeTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "table",
    "type_type",
    "type",
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlotDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::PlotIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "bytes",
    "url",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable,
    noodles::Vec4TypeTable,
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "metallic",
    "roughness",
    "use_blending",
    "texture_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable,
    noodles::BufferRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "reference"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable,
    noodles::RGBTypeTable,
    noodles::Vec4TypeTable,
    noodles::LightTypeTypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "intensity",
    "spatial",
    "light_type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ComponentRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "size",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable,
    noodles::BoundingBoxTypeTable,
    noodles::ComponentRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "extent",
    "positions",
    "normals",
    "tex_coords",
    "colors",
    "lines",
    "triangles"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "meta",
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentResetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalInvokeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::PlotIDTypeTable,
    noodles::AnyListTypeTable
  };
  static const char * const names[] = {
    "id",
    "on_object",
    "on_table",
    "on_plot",
    "signal_data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodExceptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "code",
    "message",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable,
    noodles::MethodExceptionTypeTable
  };
  static const char * const names[] = {
    "invoke_ident",
    "method_data",
    "method_exception"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTypeTable
  };
  static const char * const names[] = {
    "message_type",
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessagesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTable
  };
  static const char * const names[] = {
    "messages"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const noodles::ServerMessages *GetServerMessages(const void *buf) {
  return flatbuffers::GetRoot<noodles::ServerMessages>(buf);
}

inline const noodles::ServerMessages *GetSizePrefixedServerMessages(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<noodles::ServerMessages>(buf);
}

inline ServerMessages *GetMutableServerMessages(void *buf) {
  return flatbuffers::GetMutableRoot<ServerMessages>(buf);
}

inline bool VerifyServerMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<noodles::ServerMessages>(nullptr);
}

inline bool VerifySizePrefixedServerMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<noodles::ServerMessages>(nullptr);
}

inline void FinishServerMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ServerMessages> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedServerMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ServerMessages> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace noodles

#endif  // FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_
