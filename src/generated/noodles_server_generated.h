// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_
#define FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_

#include "flatbuffers/flatbuffers.h"

#include "noodles_generated.h"

namespace noodles {

struct MethodArg;
struct MethodArgBuilder;

struct MethodCreate;
struct MethodCreateBuilder;

struct MethodDelete;
struct MethodDeleteBuilder;

struct SignalCreate;
struct SignalCreateBuilder;

struct SignalDelete;
struct SignalDeleteBuilder;

struct TextDefinition;
struct TextDefinitionBuilder;

struct ObjectCreateUpdate;
struct ObjectCreateUpdateBuilder;

struct ObjectDelete;
struct ObjectDeleteBuilder;

struct BufferCreate;
struct BufferCreateBuilder;

struct BufferDelete;
struct BufferDeleteBuilder;

struct MaterialCreateUpdate;
struct MaterialCreateUpdateBuilder;

struct MaterialDelete;
struct MaterialDeleteBuilder;

struct TextureCreateUpdate;
struct TextureCreateUpdateBuilder;

struct TextureDelete;
struct TextureDeleteBuilder;

struct LightCreateUpdate;
struct LightCreateUpdateBuilder;

struct LightDelete;
struct LightDeleteBuilder;

struct ComponentRef;
struct ComponentRefBuilder;

struct GeometryCreate;
struct GeometryCreateBuilder;

struct GeometryDelete;
struct GeometryDeleteBuilder;

struct TableCreateUpdate;
struct TableCreateUpdateBuilder;

struct TableDelete;
struct TableDeleteBuilder;

struct DocumentUpdate;
struct DocumentUpdateBuilder;

struct DocumentReset;
struct DocumentResetBuilder;

struct SignalInvoke;
struct SignalInvokeBuilder;

struct MethodReply;
struct MethodReplyBuilder;

struct ServerMessage;
struct ServerMessageBuilder;

struct ServerMessages;
struct ServerMessagesBuilder;

inline const flatbuffers::TypeTable *MethodArgTypeTable();

inline const flatbuffers::TypeTable *MethodCreateTypeTable();

inline const flatbuffers::TypeTable *MethodDeleteTypeTable();

inline const flatbuffers::TypeTable *SignalCreateTypeTable();

inline const flatbuffers::TypeTable *SignalDeleteTypeTable();

inline const flatbuffers::TypeTable *TextDefinitionTypeTable();

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable();

inline const flatbuffers::TypeTable *BufferCreateTypeTable();

inline const flatbuffers::TypeTable *BufferDeleteTypeTable();

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable();

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TextureDeleteTypeTable();

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *LightDeleteTypeTable();

inline const flatbuffers::TypeTable *ComponentRefTypeTable();

inline const flatbuffers::TypeTable *GeometryCreateTypeTable();

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable();

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable();

inline const flatbuffers::TypeTable *TableDeleteTypeTable();

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable();

inline const flatbuffers::TypeTable *DocumentResetTypeTable();

inline const flatbuffers::TypeTable *SignalInvokeTypeTable();

inline const flatbuffers::TypeTable *MethodReplyTypeTable();

inline const flatbuffers::TypeTable *ServerMessageTypeTable();

inline const flatbuffers::TypeTable *ServerMessagesTypeTable();

enum class ServerMessageType : uint8_t {
  NONE = 0,
  MethodCreate = 1,
  MethodDelete = 2,
  SignalCreate = 3,
  SignalDelete = 4,
  ObjectCreateUpdate = 5,
  ObjectDelete = 6,
  BufferCreate = 7,
  BufferDelete = 8,
  MaterialCreateUpdate = 9,
  MaterialDelete = 10,
  TextureCreateUpdate = 11,
  TextureDelete = 12,
  LightCreateUpdate = 13,
  LightDelete = 14,
  GeometryCreate = 15,
  GeometryDelete = 16,
  TableCreateUpdate = 17,
  TableDelete = 18,
  DocumentUpdate = 19,
  DocumentReset = 20,
  SignalInvoke = 21,
  MethodReply = 22,
  MIN = NONE,
  MAX = MethodReply
};

inline const ServerMessageType (&EnumValuesServerMessageType())[23] {
  static const ServerMessageType values[] = {
    ServerMessageType::NONE,
    ServerMessageType::MethodCreate,
    ServerMessageType::MethodDelete,
    ServerMessageType::SignalCreate,
    ServerMessageType::SignalDelete,
    ServerMessageType::ObjectCreateUpdate,
    ServerMessageType::ObjectDelete,
    ServerMessageType::BufferCreate,
    ServerMessageType::BufferDelete,
    ServerMessageType::MaterialCreateUpdate,
    ServerMessageType::MaterialDelete,
    ServerMessageType::TextureCreateUpdate,
    ServerMessageType::TextureDelete,
    ServerMessageType::LightCreateUpdate,
    ServerMessageType::LightDelete,
    ServerMessageType::GeometryCreate,
    ServerMessageType::GeometryDelete,
    ServerMessageType::TableCreateUpdate,
    ServerMessageType::TableDelete,
    ServerMessageType::DocumentUpdate,
    ServerMessageType::DocumentReset,
    ServerMessageType::SignalInvoke,
    ServerMessageType::MethodReply
  };
  return values;
}

inline const char * const *EnumNamesServerMessageType() {
  static const char * const names[24] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerMessageType(ServerMessageType e) {
  if (flatbuffers::IsOutRange(e, ServerMessageType::NONE, ServerMessageType::MethodReply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerMessageType()[index];
}

template<typename T> struct ServerMessageTypeTraits {
  static const ServerMessageType enum_value = ServerMessageType::NONE;
};

template<> struct ServerMessageTypeTraits<noodles::MethodCreate> {
  static const ServerMessageType enum_value = ServerMessageType::MethodCreate;
};

template<> struct ServerMessageTypeTraits<noodles::MethodDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MethodDelete;
};

template<> struct ServerMessageTypeTraits<noodles::SignalCreate> {
  static const ServerMessageType enum_value = ServerMessageType::SignalCreate;
};

template<> struct ServerMessageTypeTraits<noodles::SignalDelete> {
  static const ServerMessageType enum_value = ServerMessageType::SignalDelete;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::ObjectDelete> {
  static const ServerMessageType enum_value = ServerMessageType::ObjectDelete;
};

template<> struct ServerMessageTypeTraits<noodles::BufferCreate> {
  static const ServerMessageType enum_value = ServerMessageType::BufferCreate;
};

template<> struct ServerMessageTypeTraits<noodles::BufferDelete> {
  static const ServerMessageType enum_value = ServerMessageType::BufferDelete;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::MaterialDelete> {
  static const ServerMessageType enum_value = ServerMessageType::MaterialDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TextureCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TextureCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TextureDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TextureDelete;
};

template<> struct ServerMessageTypeTraits<noodles::LightCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::LightCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::LightDelete> {
  static const ServerMessageType enum_value = ServerMessageType::LightDelete;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryCreate> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryCreate;
};

template<> struct ServerMessageTypeTraits<noodles::GeometryDelete> {
  static const ServerMessageType enum_value = ServerMessageType::GeometryDelete;
};

template<> struct ServerMessageTypeTraits<noodles::TableCreateUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::TableCreateUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::TableDelete> {
  static const ServerMessageType enum_value = ServerMessageType::TableDelete;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentUpdate> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentUpdate;
};

template<> struct ServerMessageTypeTraits<noodles::DocumentReset> {
  static const ServerMessageType enum_value = ServerMessageType::DocumentReset;
};

template<> struct ServerMessageTypeTraits<noodles::SignalInvoke> {
  static const ServerMessageType enum_value = ServerMessageType::SignalInvoke;
};

template<> struct ServerMessageTypeTraits<noodles::MethodReply> {
  static const ServerMessageType enum_value = ServerMessageType::MethodReply;
};

bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type);
bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct MethodArg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodArgBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodArgTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC);
  }
  flatbuffers::String *mutable_doc() {
    return GetPointer<flatbuffers::String *>(VT_DOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC) &&
           verifier.VerifyString(doc()) &&
           verifier.EndTable();
  }
};

struct MethodArgBuilder {
  typedef MethodArg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodArg::VT_NAME, name);
  }
  void add_doc(flatbuffers::Offset<flatbuffers::String> doc) {
    fbb_.AddOffset(MethodArg::VT_DOC, doc);
  }
  explicit MethodArgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MethodArgBuilder &operator=(const MethodArgBuilder &);
  flatbuffers::Offset<MethodArg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodArg>(end);
    return o;
  }
};

inline flatbuffers::Offset<MethodArg> CreateMethodArg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc = 0) {
  MethodArgBuilder builder_(_fbb);
  builder_.add_doc(doc);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodArg> CreateMethodArgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc__ = doc ? _fbb.CreateString(doc) : 0;
  return noodles::CreateMethodArg(
      _fbb,
      name__,
      doc__);
}

struct MethodCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_RETURNDOC = 10,
    VT_ARGDOC = 12
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::String *returnDoc() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURNDOC);
  }
  flatbuffers::String *mutable_returnDoc() {
    return GetPointer<flatbuffers::String *>(VT_RETURNDOC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *argDoc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARGDOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_argDoc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARGDOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_RETURNDOC) &&
           verifier.VerifyString(returnDoc()) &&
           VerifyOffset(verifier, VT_ARGDOC) &&
           verifier.VerifyVector(argDoc()) &&
           verifier.VerifyVectorOfTables(argDoc()) &&
           verifier.EndTable();
  }
};

struct MethodCreateBuilder {
  typedef MethodCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(MethodCreate::VT_DOCUMENTATION, documentation);
  }
  void add_returnDoc(flatbuffers::Offset<flatbuffers::String> returnDoc) {
    fbb_.AddOffset(MethodCreate::VT_RETURNDOC, returnDoc);
  }
  void add_argDoc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> argDoc) {
    fbb_.AddOffset(MethodCreate::VT_ARGDOC, argDoc);
  }
  explicit MethodCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MethodCreateBuilder &operator=(const MethodCreateBuilder &);
  flatbuffers::Offset<MethodCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodCreate>(end);
    fbb_.Required(o, MethodCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodCreate> CreateMethodCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::String> returnDoc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> argDoc = 0) {
  MethodCreateBuilder builder_(_fbb);
  builder_.add_argDoc(argDoc);
  builder_.add_returnDoc(returnDoc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodCreate> CreateMethodCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const char *returnDoc = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *argDoc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto returnDoc__ = returnDoc ? _fbb.CreateString(returnDoc) : 0;
  auto argDoc__ = argDoc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*argDoc) : 0;
  return noodles::CreateMethodCreate(
      _fbb,
      id,
      name__,
      documentation__,
      returnDoc__,
      argDoc__);
}

struct MethodDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MethodID *id() const {
    return GetPointer<const noodles::MethodID *>(VT_ID);
  }
  noodles::MethodID *mutable_id() {
    return GetPointer<noodles::MethodID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MethodDeleteBuilder {
  typedef MethodDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MethodID> id) {
    fbb_.AddOffset(MethodDelete::VT_ID, id);
  }
  explicit MethodDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MethodDeleteBuilder &operator=(const MethodDeleteBuilder &);
  flatbuffers::Offset<MethodDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodDelete>(end);
    fbb_.Required(o, MethodDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MethodDelete> CreateMethodDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MethodID> id = 0) {
  MethodDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SignalCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DOCUMENTATION = 8,
    VT_ARGDOC = 10
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *documentation() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTATION);
  }
  flatbuffers::String *mutable_documentation() {
    return GetPointer<flatbuffers::String *>(VT_DOCUMENTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *argDoc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARGDOC);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *mutable_argDoc() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>> *>(VT_ARGDOC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOCUMENTATION) &&
           verifier.VerifyString(documentation()) &&
           VerifyOffset(verifier, VT_ARGDOC) &&
           verifier.VerifyVector(argDoc()) &&
           verifier.VerifyVectorOfTables(argDoc()) &&
           verifier.EndTable();
  }
};

struct SignalCreateBuilder {
  typedef SignalCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalCreate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SignalCreate::VT_NAME, name);
  }
  void add_documentation(flatbuffers::Offset<flatbuffers::String> documentation) {
    fbb_.AddOffset(SignalCreate::VT_DOCUMENTATION, documentation);
  }
  void add_argDoc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> argDoc) {
    fbb_.AddOffset(SignalCreate::VT_ARGDOC, argDoc);
  }
  explicit SignalCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalCreateBuilder &operator=(const SignalCreateBuilder &);
  flatbuffers::Offset<SignalCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalCreate>(end);
    fbb_.Required(o, SignalCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalCreate> CreateSignalCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> documentation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodArg>>> argDoc = 0) {
  SignalCreateBuilder builder_(_fbb);
  builder_.add_argDoc(argDoc);
  builder_.add_documentation(documentation);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalCreate> CreateSignalCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    const char *name = nullptr,
    const char *documentation = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodArg>> *argDoc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto documentation__ = documentation ? _fbb.CreateString(documentation) : 0;
  auto argDoc__ = argDoc ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodArg>>(*argDoc) : 0;
  return noodles::CreateSignalCreate(
      _fbb,
      id,
      name__,
      documentation__,
      argDoc__);
}

struct SignalDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct SignalDeleteBuilder {
  typedef SignalDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalDelete::VT_ID, id);
  }
  explicit SignalDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalDeleteBuilder &operator=(const SignalDeleteBuilder &);
  flatbuffers::Offset<SignalDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalDelete>(end);
    fbb_.Required(o, SignalDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalDelete> CreateSignalDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0) {
  SignalDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextDefinitionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextDefinitionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_FONT = 6,
    VT_HEIGHT = 8,
    VT_OPT_WIDTH = 10
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *font() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT);
  }
  flatbuffers::String *mutable_font() {
    return GetPointer<flatbuffers::String *>(VT_FONT);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  bool mutate_height(float _height) {
    return SetField<float>(VT_HEIGHT, _height, 0.0f);
  }
  float opt_width() const {
    return GetField<float>(VT_OPT_WIDTH, 0.0f);
  }
  bool mutate_opt_width(float _opt_width) {
    return SetField<float>(VT_OPT_WIDTH, _opt_width, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_FONT) &&
           verifier.VerifyString(font()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_OPT_WIDTH) &&
           verifier.EndTable();
  }
};

struct TextDefinitionBuilder {
  typedef TextDefinition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextDefinition::VT_TEXT, text);
  }
  void add_font(flatbuffers::Offset<flatbuffers::String> font) {
    fbb_.AddOffset(TextDefinition::VT_FONT, font);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(TextDefinition::VT_HEIGHT, height, 0.0f);
  }
  void add_opt_width(float opt_width) {
    fbb_.AddElement<float>(TextDefinition::VT_OPT_WIDTH, opt_width, 0.0f);
  }
  explicit TextDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextDefinitionBuilder &operator=(const TextDefinitionBuilder &);
  flatbuffers::Offset<TextDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextDefinition>(end);
    fbb_.Required(o, TextDefinition::VT_TEXT);
    fbb_.Required(o, TextDefinition::VT_FONT);
    return o;
  }
};

inline flatbuffers::Offset<TextDefinition> CreateTextDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> font = 0,
    float height = 0.0f,
    float opt_width = 0.0f) {
  TextDefinitionBuilder builder_(_fbb);
  builder_.add_opt_width(opt_width);
  builder_.add_height(height);
  builder_.add_font(font);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextDefinition> CreateTextDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *font = nullptr,
    float height = 0.0f,
    float opt_width = 0.0f) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto font__ = font ? _fbb.CreateString(font) : 0;
  return noodles::CreateTextDefinition(
      _fbb,
      text__,
      font__,
      height,
      opt_width);
}

struct ObjectCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_PARENT = 8,
    VT_TRANSFORM = 10,
    VT_MATERIAL = 12,
    VT_MESH = 14,
    VT_LIGHTS = 16,
    VT_TABLES = 18,
    VT_INSTANCES = 20,
    VT_TAGS = 22,
    VT_METHODS_LIST = 24,
    VT_SIGNALS_LIST = 26,
    VT_TEXT = 28
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const noodles::ObjectID *parent() const {
    return GetPointer<const noodles::ObjectID *>(VT_PARENT);
  }
  noodles::ObjectID *mutable_parent() {
    return GetPointer<noodles::ObjectID *>(VT_PARENT);
  }
  const noodles::Mat4 *transform() const {
    return GetStruct<const noodles::Mat4 *>(VT_TRANSFORM);
  }
  noodles::Mat4 *mutable_transform() {
    return GetStruct<noodles::Mat4 *>(VT_TRANSFORM);
  }
  const noodles::MaterialID *material() const {
    return GetPointer<const noodles::MaterialID *>(VT_MATERIAL);
  }
  noodles::MaterialID *mutable_material() {
    return GetPointer<noodles::MaterialID *>(VT_MATERIAL);
  }
  const noodles::GeometryID *mesh() const {
    return GetPointer<const noodles::GeometryID *>(VT_MESH);
  }
  noodles::GeometryID *mutable_mesh() {
    return GetPointer<noodles::GeometryID *>(VT_MESH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *lights() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *mutable_lights() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>> *>(VT_LIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *mutable_tables() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>> *>(VT_TABLES);
  }
  const flatbuffers::Vector<const noodles::Mat4 *> *instances() const {
    return GetPointer<const flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  flatbuffers::Vector<const noodles::Mat4 *> *mutable_instances() {
    return GetPointer<flatbuffers::Vector<const noodles::Mat4 *> *>(VT_INSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_tags() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TAGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  const noodles::TextDefinition *text() const {
    return GetPointer<const noodles::TextDefinition *>(VT_TEXT);
  }
  noodles::TextDefinition *mutable_text() {
    return GetPointer<noodles::TextDefinition *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARENT) &&
           verifier.VerifyTable(parent()) &&
           VerifyField<noodles::Mat4>(verifier, VT_TRANSFORM) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           VerifyOffset(verifier, VT_MESH) &&
           verifier.VerifyTable(mesh()) &&
           VerifyOffset(verifier, VT_LIGHTS) &&
           verifier.VerifyVector(lights()) &&
           verifier.VerifyVectorOfTables(lights()) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyTable(text()) &&
           verifier.EndTable();
  }
};

struct ObjectCreateUpdateBuilder {
  typedef ObjectCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_NAME, name);
  }
  void add_parent(flatbuffers::Offset<noodles::ObjectID> parent) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_PARENT, parent);
  }
  void add_transform(const noodles::Mat4 *transform) {
    fbb_.AddStruct(ObjectCreateUpdate::VT_TRANSFORM, transform);
  }
  void add_material(flatbuffers::Offset<noodles::MaterialID> material) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_MATERIAL, material);
  }
  void add_mesh(flatbuffers::Offset<noodles::GeometryID> mesh) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_MESH, mesh);
  }
  void add_lights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_LIGHTS, lights);
  }
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TABLES, tables);
  }
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_INSTANCES, instances);
  }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TAGS, tags);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  void add_text(flatbuffers::Offset<noodles::TextDefinition> text) {
    fbb_.AddOffset(ObjectCreateUpdate::VT_TEXT, text);
  }
  explicit ObjectCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectCreateUpdateBuilder &operator=(const ObjectCreateUpdateBuilder &);
  flatbuffers::Offset<ObjectCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectCreateUpdate>(end);
    fbb_.Required(o, ObjectCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::LightID>>> lights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::TableID>>> tables = 0,
    flatbuffers::Offset<flatbuffers::Vector<const noodles::Mat4 *>> instances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tags = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0,
    flatbuffers::Offset<noodles::TextDefinition> text = 0) {
  ObjectCreateUpdateBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_tags(tags);
  builder_.add_instances(instances);
  builder_.add_tables(tables);
  builder_.add_lights(lights);
  builder_.add_mesh(mesh);
  builder_.add_material(material);
  builder_.add_transform(transform);
  builder_.add_parent(parent);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectCreateUpdate> CreateObjectCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0,
    const char *name = nullptr,
    flatbuffers::Offset<noodles::ObjectID> parent = 0,
    const noodles::Mat4 *transform = 0,
    flatbuffers::Offset<noodles::MaterialID> material = 0,
    flatbuffers::Offset<noodles::GeometryID> mesh = 0,
    const std::vector<flatbuffers::Offset<noodles::LightID>> *lights = nullptr,
    const std::vector<flatbuffers::Offset<noodles::TableID>> *tables = nullptr,
    const std::vector<noodles::Mat4> *instances = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tags = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr,
    flatbuffers::Offset<noodles::TextDefinition> text = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lights__ = lights ? _fbb.CreateVector<flatbuffers::Offset<noodles::LightID>>(*lights) : 0;
  auto tables__ = tables ? _fbb.CreateVector<flatbuffers::Offset<noodles::TableID>>(*tables) : 0;
  auto instances__ = instances ? _fbb.CreateVectorOfStructs<noodles::Mat4>(*instances) : 0;
  auto tags__ = tags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tags) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateObjectCreateUpdate(
      _fbb,
      id,
      name__,
      parent,
      transform,
      material,
      mesh,
      lights__,
      tables__,
      instances__,
      tags__,
      methods_list__,
      signals_list__,
      text);
}

struct ObjectDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::ObjectID *id() const {
    return GetPointer<const noodles::ObjectID *>(VT_ID);
  }
  noodles::ObjectID *mutable_id() {
    return GetPointer<noodles::ObjectID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct ObjectDeleteBuilder {
  typedef ObjectDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::ObjectID> id) {
    fbb_.AddOffset(ObjectDelete::VT_ID, id);
  }
  explicit ObjectDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectDeleteBuilder &operator=(const ObjectDeleteBuilder &);
  flatbuffers::Offset<ObjectDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectDelete>(end);
    fbb_.Required(o, ObjectDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ObjectDelete> CreateObjectDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::ObjectID> id = 0) {
  ObjectDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct BufferCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BYTES = 6,
    VT_URL = 8,
    VT_URL_SIZE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  const flatbuffers::Vector<int8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  flatbuffers::Vector<int8_t> *mutable_bytes() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_BYTES);
  }
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  flatbuffers::String *mutable_url() {
    return GetPointer<flatbuffers::String *>(VT_URL);
  }
  uint64_t url_size() const {
    return GetField<uint64_t>(VT_URL_SIZE, 0);
  }
  bool mutate_url_size(uint64_t _url_size) {
    return SetField<uint64_t>(VT_URL_SIZE, _url_size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<uint64_t>(verifier, VT_URL_SIZE) &&
           verifier.EndTable();
  }
};

struct BufferCreateBuilder {
  typedef BufferCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferCreate::VT_ID, id);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes) {
    fbb_.AddOffset(BufferCreate::VT_BYTES, bytes);
  }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(BufferCreate::VT_URL, url);
  }
  void add_url_size(uint64_t url_size) {
    fbb_.AddElement<uint64_t>(BufferCreate::VT_URL_SIZE, url_size, 0);
  }
  explicit BufferCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferCreateBuilder &operator=(const BufferCreateBuilder &);
  flatbuffers::Offset<BufferCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferCreate>(end);
    fbb_.Required(o, BufferCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferCreate> CreateBufferCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> bytes = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    uint64_t url_size = 0) {
  BufferCreateBuilder builder_(_fbb);
  builder_.add_url_size(url_size);
  builder_.add_url(url);
  builder_.add_bytes(bytes);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<BufferCreate> CreateBufferCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    const std::vector<int8_t> *bytes = nullptr,
    const char *url = nullptr,
    uint64_t url_size = 0) {
  auto bytes__ = bytes ? _fbb.CreateVector<int8_t>(*bytes) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return noodles::CreateBufferCreate(
      _fbb,
      id,
      bytes__,
      url__,
      url_size);
}

struct BufferDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct BufferDeleteBuilder {
  typedef BufferDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(BufferDelete::VT_ID, id);
  }
  explicit BufferDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferDeleteBuilder &operator=(const BufferDeleteBuilder &);
  flatbuffers::Offset<BufferDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferDelete>(end);
    fbb_.Required(o, BufferDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<BufferDelete> CreateBufferDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0) {
  BufferDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MaterialCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_METALLIC = 8,
    VT_ROUGHNESS = 10,
    VT_USE_BLENDING = 12,
    VT_TEXTURE_ID = 14
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  const noodles::Vec4 *color() const {
    return GetStruct<const noodles::Vec4 *>(VT_COLOR);
  }
  noodles::Vec4 *mutable_color() {
    return GetStruct<noodles::Vec4 *>(VT_COLOR);
  }
  float metallic() const {
    return GetField<float>(VT_METALLIC, 0.0f);
  }
  bool mutate_metallic(float _metallic) {
    return SetField<float>(VT_METALLIC, _metallic, 0.0f);
  }
  float roughness() const {
    return GetField<float>(VT_ROUGHNESS, 0.0f);
  }
  bool mutate_roughness(float _roughness) {
    return SetField<float>(VT_ROUGHNESS, _roughness, 0.0f);
  }
  bool use_blending() const {
    return GetField<uint8_t>(VT_USE_BLENDING, 0) != 0;
  }
  bool mutate_use_blending(bool _use_blending) {
    return SetField<uint8_t>(VT_USE_BLENDING, static_cast<uint8_t>(_use_blending), 0);
  }
  const noodles::TextureID *texture_id() const {
    return GetPointer<const noodles::TextureID *>(VT_TEXTURE_ID);
  }
  noodles::TextureID *mutable_texture_id() {
    return GetPointer<noodles::TextureID *>(VT_TEXTURE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::Vec4>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_METALLIC) &&
           VerifyField<float>(verifier, VT_ROUGHNESS) &&
           VerifyField<uint8_t>(verifier, VT_USE_BLENDING) &&
           VerifyOffset(verifier, VT_TEXTURE_ID) &&
           verifier.VerifyTable(texture_id()) &&
           verifier.EndTable();
  }
};

struct MaterialCreateUpdateBuilder {
  typedef MaterialCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::Vec4 *color) {
    fbb_.AddStruct(MaterialCreateUpdate::VT_COLOR, color);
  }
  void add_metallic(float metallic) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_METALLIC, metallic, 0.0f);
  }
  void add_roughness(float roughness) {
    fbb_.AddElement<float>(MaterialCreateUpdate::VT_ROUGHNESS, roughness, 0.0f);
  }
  void add_use_blending(bool use_blending) {
    fbb_.AddElement<uint8_t>(MaterialCreateUpdate::VT_USE_BLENDING, static_cast<uint8_t>(use_blending), 0);
  }
  void add_texture_id(flatbuffers::Offset<noodles::TextureID> texture_id) {
    fbb_.AddOffset(MaterialCreateUpdate::VT_TEXTURE_ID, texture_id);
  }
  explicit MaterialCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialCreateUpdateBuilder &operator=(const MaterialCreateUpdateBuilder &);
  flatbuffers::Offset<MaterialCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialCreateUpdate>(end);
    fbb_.Required(o, MaterialCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialCreateUpdate> CreateMaterialCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0,
    const noodles::Vec4 *color = 0,
    float metallic = 0.0f,
    float roughness = 0.0f,
    bool use_blending = false,
    flatbuffers::Offset<noodles::TextureID> texture_id = 0) {
  MaterialCreateUpdateBuilder builder_(_fbb);
  builder_.add_texture_id(texture_id);
  builder_.add_roughness(roughness);
  builder_.add_metallic(metallic);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_use_blending(use_blending);
  return builder_.Finish();
}

struct MaterialDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaterialDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::MaterialID *id() const {
    return GetPointer<const noodles::MaterialID *>(VT_ID);
  }
  noodles::MaterialID *mutable_id() {
    return GetPointer<noodles::MaterialID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct MaterialDeleteBuilder {
  typedef MaterialDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::MaterialID> id) {
    fbb_.AddOffset(MaterialDelete::VT_ID, id);
  }
  explicit MaterialDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialDeleteBuilder &operator=(const MaterialDeleteBuilder &);
  flatbuffers::Offset<MaterialDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialDelete>(end);
    fbb_.Required(o, MaterialDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<MaterialDelete> CreateMaterialDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::MaterialID> id = 0) {
  MaterialDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REFERENCE = 6
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  const noodles::BufferRef *reference() const {
    return GetPointer<const noodles::BufferRef *>(VT_REFERENCE);
  }
  noodles::BufferRef *mutable_reference() {
    return GetPointer<noodles::BufferRef *>(VT_REFERENCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE) &&
           verifier.VerifyTable(reference()) &&
           verifier.EndTable();
  }
};

struct TextureCreateUpdateBuilder {
  typedef TextureCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureCreateUpdate::VT_ID, id);
  }
  void add_reference(flatbuffers::Offset<noodles::BufferRef> reference) {
    fbb_.AddOffset(TextureCreateUpdate::VT_REFERENCE, reference);
  }
  explicit TextureCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureCreateUpdateBuilder &operator=(const TextureCreateUpdateBuilder &);
  flatbuffers::Offset<TextureCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureCreateUpdate>(end);
    fbb_.Required(o, TextureCreateUpdate::VT_ID);
    fbb_.Required(o, TextureCreateUpdate::VT_REFERENCE);
    return o;
  }
};

inline flatbuffers::Offset<TextureCreateUpdate> CreateTextureCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0,
    flatbuffers::Offset<noodles::BufferRef> reference = 0) {
  TextureCreateUpdateBuilder builder_(_fbb);
  builder_.add_reference(reference);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TextureDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TextureDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TextureID *id() const {
    return GetPointer<const noodles::TextureID *>(VT_ID);
  }
  noodles::TextureID *mutable_id() {
    return GetPointer<noodles::TextureID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TextureDeleteBuilder {
  typedef TextureDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TextureID> id) {
    fbb_.AddOffset(TextureDelete::VT_ID, id);
  }
  explicit TextureDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureDeleteBuilder &operator=(const TextureDeleteBuilder &);
  flatbuffers::Offset<TextureDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureDelete>(end);
    fbb_.Required(o, TextureDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TextureDelete> CreateTextureDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TextureID> id = 0) {
  TextureDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct LightCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COLOR = 6,
    VT_INTENSITY = 8
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  const noodles::Vec3 *color() const {
    return GetStruct<const noodles::Vec3 *>(VT_COLOR);
  }
  noodles::Vec3 *mutable_color() {
    return GetStruct<noodles::Vec3 *>(VT_COLOR);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool mutate_intensity(float _intensity) {
    return SetField<float>(VT_INTENSITY, _intensity, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::Vec3>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           verifier.EndTable();
  }
};

struct LightCreateUpdateBuilder {
  typedef LightCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightCreateUpdate::VT_ID, id);
  }
  void add_color(const noodles::Vec3 *color) {
    fbb_.AddStruct(LightCreateUpdate::VT_COLOR, color);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightCreateUpdate::VT_INTENSITY, intensity, 0.0f);
  }
  explicit LightCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightCreateUpdateBuilder &operator=(const LightCreateUpdateBuilder &);
  flatbuffers::Offset<LightCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightCreateUpdate>(end);
    fbb_.Required(o, LightCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightCreateUpdate> CreateLightCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0,
    const noodles::Vec3 *color = 0,
    float intensity = 0.0f) {
  LightCreateUpdateBuilder builder_(_fbb);
  builder_.add_intensity(intensity);
  builder_.add_color(color);
  builder_.add_id(id);
  return builder_.Finish();
}

struct LightDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LightDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::LightID *id() const {
    return GetPointer<const noodles::LightID *>(VT_ID);
  }
  noodles::LightID *mutable_id() {
    return GetPointer<noodles::LightID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct LightDeleteBuilder {
  typedef LightDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::LightID> id) {
    fbb_.AddOffset(LightDelete::VT_ID, id);
  }
  explicit LightDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightDeleteBuilder &operator=(const LightDeleteBuilder &);
  flatbuffers::Offset<LightDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightDelete>(end);
    fbb_.Required(o, LightDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<LightDelete> CreateLightDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::LightID> id = 0) {
  LightDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ComponentRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ComponentRefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ComponentRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_START = 6,
    VT_SIZE = 8,
    VT_STRIDE = 10
  };
  const noodles::BufferID *id() const {
    return GetPointer<const noodles::BufferID *>(VT_ID);
  }
  noodles::BufferID *mutable_id() {
    return GetPointer<noodles::BufferID *>(VT_ID);
  }
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  uint64_t stride() const {
    return GetField<uint64_t>(VT_STRIDE, 0);
  }
  bool mutate_stride(uint64_t _stride) {
    return SetField<uint64_t>(VT_STRIDE, _stride, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint64_t>(verifier, VT_START) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_STRIDE) &&
           verifier.EndTable();
  }
};

struct ComponentRefBuilder {
  typedef ComponentRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::BufferID> id) {
    fbb_.AddOffset(ComponentRef::VT_ID, id);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_START, start, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_SIZE, size, 0);
  }
  void add_stride(uint64_t stride) {
    fbb_.AddElement<uint64_t>(ComponentRef::VT_STRIDE, stride, 0);
  }
  explicit ComponentRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ComponentRefBuilder &operator=(const ComponentRefBuilder &);
  flatbuffers::Offset<ComponentRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComponentRef>(end);
    fbb_.Required(o, ComponentRef::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<ComponentRef> CreateComponentRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::BufferID> id = 0,
    uint64_t start = 0,
    uint64_t size = 0,
    uint64_t stride = 0) {
  ComponentRefBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_size(size);
  builder_.add_start(start);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryCreateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryCreateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MIN_EXTENT = 6,
    VT_MAX_EXTENT = 8,
    VT_POSITIONS = 10,
    VT_NORMALS = 12,
    VT_TEXCOORDS = 14,
    VT_COLORS = 16,
    VT_LINES = 18,
    VT_TRIANGLES = 20
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  const noodles::Vec3 *min_extent() const {
    return GetStruct<const noodles::Vec3 *>(VT_MIN_EXTENT);
  }
  noodles::Vec3 *mutable_min_extent() {
    return GetStruct<noodles::Vec3 *>(VT_MIN_EXTENT);
  }
  const noodles::Vec3 *max_extent() const {
    return GetStruct<const noodles::Vec3 *>(VT_MAX_EXTENT);
  }
  noodles::Vec3 *mutable_max_extent() {
    return GetStruct<noodles::Vec3 *>(VT_MAX_EXTENT);
  }
  const noodles::ComponentRef *positions() const {
    return GetPointer<const noodles::ComponentRef *>(VT_POSITIONS);
  }
  noodles::ComponentRef *mutable_positions() {
    return GetPointer<noodles::ComponentRef *>(VT_POSITIONS);
  }
  const noodles::ComponentRef *normals() const {
    return GetPointer<const noodles::ComponentRef *>(VT_NORMALS);
  }
  noodles::ComponentRef *mutable_normals() {
    return GetPointer<noodles::ComponentRef *>(VT_NORMALS);
  }
  const noodles::ComponentRef *texCoords() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TEXCOORDS);
  }
  noodles::ComponentRef *mutable_texCoords() {
    return GetPointer<noodles::ComponentRef *>(VT_TEXCOORDS);
  }
  const noodles::ComponentRef *colors() const {
    return GetPointer<const noodles::ComponentRef *>(VT_COLORS);
  }
  noodles::ComponentRef *mutable_colors() {
    return GetPointer<noodles::ComponentRef *>(VT_COLORS);
  }
  const noodles::ComponentRef *lines() const {
    return GetPointer<const noodles::ComponentRef *>(VT_LINES);
  }
  noodles::ComponentRef *mutable_lines() {
    return GetPointer<noodles::ComponentRef *>(VT_LINES);
  }
  const noodles::ComponentRef *triangles() const {
    return GetPointer<const noodles::ComponentRef *>(VT_TRIANGLES);
  }
  noodles::ComponentRef *mutable_triangles() {
    return GetPointer<noodles::ComponentRef *>(VT_TRIANGLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<noodles::Vec3>(verifier, VT_MIN_EXTENT) &&
           VerifyField<noodles::Vec3>(verifier, VT_MAX_EXTENT) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyTable(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyTable(normals()) &&
           VerifyOffset(verifier, VT_TEXCOORDS) &&
           verifier.VerifyTable(texCoords()) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyTable(colors()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyTable(lines()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyTable(triangles()) &&
           verifier.EndTable();
  }
};

struct GeometryCreateBuilder {
  typedef GeometryCreate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryCreate::VT_ID, id);
  }
  void add_min_extent(const noodles::Vec3 *min_extent) {
    fbb_.AddStruct(GeometryCreate::VT_MIN_EXTENT, min_extent);
  }
  void add_max_extent(const noodles::Vec3 *max_extent) {
    fbb_.AddStruct(GeometryCreate::VT_MAX_EXTENT, max_extent);
  }
  void add_positions(flatbuffers::Offset<noodles::ComponentRef> positions) {
    fbb_.AddOffset(GeometryCreate::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<noodles::ComponentRef> normals) {
    fbb_.AddOffset(GeometryCreate::VT_NORMALS, normals);
  }
  void add_texCoords(flatbuffers::Offset<noodles::ComponentRef> texCoords) {
    fbb_.AddOffset(GeometryCreate::VT_TEXCOORDS, texCoords);
  }
  void add_colors(flatbuffers::Offset<noodles::ComponentRef> colors) {
    fbb_.AddOffset(GeometryCreate::VT_COLORS, colors);
  }
  void add_lines(flatbuffers::Offset<noodles::ComponentRef> lines) {
    fbb_.AddOffset(GeometryCreate::VT_LINES, lines);
  }
  void add_triangles(flatbuffers::Offset<noodles::ComponentRef> triangles) {
    fbb_.AddOffset(GeometryCreate::VT_TRIANGLES, triangles);
  }
  explicit GeometryCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryCreateBuilder &operator=(const GeometryCreateBuilder &);
  flatbuffers::Offset<GeometryCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryCreate>(end);
    fbb_.Required(o, GeometryCreate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryCreate> CreateGeometryCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0,
    const noodles::Vec3 *min_extent = 0,
    const noodles::Vec3 *max_extent = 0,
    flatbuffers::Offset<noodles::ComponentRef> positions = 0,
    flatbuffers::Offset<noodles::ComponentRef> normals = 0,
    flatbuffers::Offset<noodles::ComponentRef> texCoords = 0,
    flatbuffers::Offset<noodles::ComponentRef> colors = 0,
    flatbuffers::Offset<noodles::ComponentRef> lines = 0,
    flatbuffers::Offset<noodles::ComponentRef> triangles = 0) {
  GeometryCreateBuilder builder_(_fbb);
  builder_.add_triangles(triangles);
  builder_.add_lines(lines);
  builder_.add_colors(colors);
  builder_.add_texCoords(texCoords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  builder_.add_max_extent(max_extent);
  builder_.add_min_extent(min_extent);
  builder_.add_id(id);
  return builder_.Finish();
}

struct GeometryDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeometryDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::GeometryID *id() const {
    return GetPointer<const noodles::GeometryID *>(VT_ID);
  }
  noodles::GeometryID *mutable_id() {
    return GetPointer<noodles::GeometryID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct GeometryDeleteBuilder {
  typedef GeometryDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::GeometryID> id) {
    fbb_.AddOffset(GeometryDelete::VT_ID, id);
  }
  explicit GeometryDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryDeleteBuilder &operator=(const GeometryDeleteBuilder &);
  flatbuffers::Offset<GeometryDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryDelete>(end);
    fbb_.Required(o, GeometryDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<GeometryDelete> CreateGeometryDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::GeometryID> id = 0) {
  GeometryDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TableCreateUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableCreateUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableCreateUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_META = 8,
    VT_METHODS_LIST = 10,
    VT_SIGNALS_LIST = 12
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *meta() const {
    return GetPointer<const flatbuffers::String *>(VT_META);
  }
  flatbuffers::String *mutable_meta() {
    return GetPointer<flatbuffers::String *>(VT_META);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyString(meta()) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct TableCreateUpdateBuilder {
  typedef TableCreateUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableCreateUpdate::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableCreateUpdate::VT_NAME, name);
  }
  void add_meta(flatbuffers::Offset<flatbuffers::String> meta) {
    fbb_.AddOffset(TableCreateUpdate::VT_META, meta);
  }
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(TableCreateUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit TableCreateUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableCreateUpdateBuilder &operator=(const TableCreateUpdateBuilder &);
  flatbuffers::Offset<TableCreateUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableCreateUpdate>(end);
    fbb_.Required(o, TableCreateUpdate::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> meta = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  TableCreateUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  builder_.add_meta(meta);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableCreateUpdate> CreateTableCreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0,
    const char *name = nullptr,
    const char *meta = nullptr,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto meta__ = meta ? _fbb.CreateString(meta) : 0;
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateTableCreateUpdate(
      _fbb,
      id,
      name__,
      meta__,
      methods_list__,
      signals_list__);
}

struct TableDelete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableDeleteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableDeleteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const noodles::TableID *id() const {
    return GetPointer<const noodles::TableID *>(VT_ID);
  }
  noodles::TableID *mutable_id() {
    return GetPointer<noodles::TableID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TableDeleteBuilder {
  typedef TableDelete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::TableID> id) {
    fbb_.AddOffset(TableDelete::VT_ID, id);
  }
  explicit TableDeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableDeleteBuilder &operator=(const TableDeleteBuilder &);
  flatbuffers::Offset<TableDelete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableDelete>(end);
    fbb_.Required(o, TableDelete::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<TableDelete> CreateTableDelete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::TableID> id = 0) {
  TableDeleteBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct DocumentUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS_LIST = 4,
    VT_SIGNALS_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *methods_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *mutable_methods_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>> *>(VT_METHODS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *signals_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *mutable_signals_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>> *>(VT_SIGNALS_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS_LIST) &&
           verifier.VerifyVector(methods_list()) &&
           verifier.VerifyVectorOfTables(methods_list()) &&
           VerifyOffset(verifier, VT_SIGNALS_LIST) &&
           verifier.VerifyVector(signals_list()) &&
           verifier.VerifyVectorOfTables(signals_list()) &&
           verifier.EndTable();
  }
};

struct DocumentUpdateBuilder {
  typedef DocumentUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_methods_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list) {
    fbb_.AddOffset(DocumentUpdate::VT_METHODS_LIST, methods_list);
  }
  void add_signals_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list) {
    fbb_.AddOffset(DocumentUpdate::VT_SIGNALS_LIST, signals_list);
  }
  explicit DocumentUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DocumentUpdateBuilder &operator=(const DocumentUpdateBuilder &);
  flatbuffers::Offset<DocumentUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::MethodID>>> methods_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::SignalID>>> signals_list = 0) {
  DocumentUpdateBuilder builder_(_fbb);
  builder_.add_signals_list(signals_list);
  builder_.add_methods_list(methods_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<DocumentUpdate> CreateDocumentUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::MethodID>> *methods_list = nullptr,
    const std::vector<flatbuffers::Offset<noodles::SignalID>> *signals_list = nullptr) {
  auto methods_list__ = methods_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::MethodID>>(*methods_list) : 0;
  auto signals_list__ = signals_list ? _fbb.CreateVector<flatbuffers::Offset<noodles::SignalID>>(*signals_list) : 0;
  return noodles::CreateDocumentUpdate(
      _fbb,
      methods_list__,
      signals_list__);
}

struct DocumentReset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DocumentResetBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DocumentResetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4
  };
  bool padding() const {
    return GetField<uint8_t>(VT_PADDING, 0) != 0;
  }
  bool mutate_padding(bool _padding) {
    return SetField<uint8_t>(VT_PADDING, static_cast<uint8_t>(_padding), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PADDING) &&
           verifier.EndTable();
  }
};

struct DocumentResetBuilder {
  typedef DocumentReset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(bool padding) {
    fbb_.AddElement<uint8_t>(DocumentReset::VT_PADDING, static_cast<uint8_t>(padding), 0);
  }
  explicit DocumentResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DocumentResetBuilder &operator=(const DocumentResetBuilder &);
  flatbuffers::Offset<DocumentReset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DocumentReset>(end);
    return o;
  }
};

inline flatbuffers::Offset<DocumentReset> CreateDocumentReset(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool padding = false) {
  DocumentResetBuilder builder_(_fbb);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct SignalInvoke FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalInvokeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalInvokeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ON_OBJECT = 6,
    VT_ON_TABLE = 8,
    VT_SIGNAL_DATA = 10
  };
  const noodles::SignalID *id() const {
    return GetPointer<const noodles::SignalID *>(VT_ID);
  }
  noodles::SignalID *mutable_id() {
    return GetPointer<noodles::SignalID *>(VT_ID);
  }
  const noodles::ObjectID *on_object() const {
    return GetPointer<const noodles::ObjectID *>(VT_ON_OBJECT);
  }
  noodles::ObjectID *mutable_on_object() {
    return GetPointer<noodles::ObjectID *>(VT_ON_OBJECT);
  }
  const noodles::TableID *on_table() const {
    return GetPointer<const noodles::TableID *>(VT_ON_TABLE);
  }
  noodles::TableID *mutable_on_table() {
    return GetPointer<noodles::TableID *>(VT_ON_TABLE);
  }
  const noodles::AnyList *signal_data() const {
    return GetPointer<const noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  noodles::AnyList *mutable_signal_data() {
    return GetPointer<noodles::AnyList *>(VT_SIGNAL_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_ON_OBJECT) &&
           verifier.VerifyTable(on_object()) &&
           VerifyOffset(verifier, VT_ON_TABLE) &&
           verifier.VerifyTable(on_table()) &&
           VerifyOffset(verifier, VT_SIGNAL_DATA) &&
           verifier.VerifyTable(signal_data()) &&
           verifier.EndTable();
  }
};

struct SignalInvokeBuilder {
  typedef SignalInvoke Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<noodles::SignalID> id) {
    fbb_.AddOffset(SignalInvoke::VT_ID, id);
  }
  void add_on_object(flatbuffers::Offset<noodles::ObjectID> on_object) {
    fbb_.AddOffset(SignalInvoke::VT_ON_OBJECT, on_object);
  }
  void add_on_table(flatbuffers::Offset<noodles::TableID> on_table) {
    fbb_.AddOffset(SignalInvoke::VT_ON_TABLE, on_table);
  }
  void add_signal_data(flatbuffers::Offset<noodles::AnyList> signal_data) {
    fbb_.AddOffset(SignalInvoke::VT_SIGNAL_DATA, signal_data);
  }
  explicit SignalInvokeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalInvokeBuilder &operator=(const SignalInvokeBuilder &);
  flatbuffers::Offset<SignalInvoke> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalInvoke>(end);
    fbb_.Required(o, SignalInvoke::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SignalInvoke> CreateSignalInvoke(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<noodles::SignalID> id = 0,
    flatbuffers::Offset<noodles::ObjectID> on_object = 0,
    flatbuffers::Offset<noodles::TableID> on_table = 0,
    flatbuffers::Offset<noodles::AnyList> signal_data = 0) {
  SignalInvokeBuilder builder_(_fbb);
  builder_.add_signal_data(signal_data);
  builder_.add_on_table(on_table);
  builder_.add_on_object(on_object);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodReplyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MethodReplyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVOKE_IDENT = 4,
    VT_METHOD_DATA = 6,
    VT_METHOD_EXCEPTION = 8
  };
  const flatbuffers::String *invoke_ident() const {
    return GetPointer<const flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  flatbuffers::String *mutable_invoke_ident() {
    return GetPointer<flatbuffers::String *>(VT_INVOKE_IDENT);
  }
  const noodles::Any *method_data() const {
    return GetPointer<const noodles::Any *>(VT_METHOD_DATA);
  }
  noodles::Any *mutable_method_data() {
    return GetPointer<noodles::Any *>(VT_METHOD_DATA);
  }
  const flatbuffers::String *method_exception() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD_EXCEPTION);
  }
  flatbuffers::String *mutable_method_exception() {
    return GetPointer<flatbuffers::String *>(VT_METHOD_EXCEPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INVOKE_IDENT) &&
           verifier.VerifyString(invoke_ident()) &&
           VerifyOffset(verifier, VT_METHOD_DATA) &&
           verifier.VerifyTable(method_data()) &&
           VerifyOffset(verifier, VT_METHOD_EXCEPTION) &&
           verifier.VerifyString(method_exception()) &&
           verifier.EndTable();
  }
};

struct MethodReplyBuilder {
  typedef MethodReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_invoke_ident(flatbuffers::Offset<flatbuffers::String> invoke_ident) {
    fbb_.AddOffset(MethodReply::VT_INVOKE_IDENT, invoke_ident);
  }
  void add_method_data(flatbuffers::Offset<noodles::Any> method_data) {
    fbb_.AddOffset(MethodReply::VT_METHOD_DATA, method_data);
  }
  void add_method_exception(flatbuffers::Offset<flatbuffers::String> method_exception) {
    fbb_.AddOffset(MethodReply::VT_METHOD_EXCEPTION, method_exception);
  }
  explicit MethodReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MethodReplyBuilder &operator=(const MethodReplyBuilder &);
  flatbuffers::Offset<MethodReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodReply>(end);
    fbb_.Required(o, MethodReply::VT_INVOKE_IDENT);
    return o;
  }
};

inline flatbuffers::Offset<MethodReply> CreateMethodReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> invoke_ident = 0,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    flatbuffers::Offset<flatbuffers::String> method_exception = 0) {
  MethodReplyBuilder builder_(_fbb);
  builder_.add_method_exception(method_exception);
  builder_.add_method_data(method_data);
  builder_.add_invoke_ident(invoke_ident);
  return builder_.Finish();
}

inline flatbuffers::Offset<MethodReply> CreateMethodReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *invoke_ident = nullptr,
    flatbuffers::Offset<noodles::Any> method_data = 0,
    const char *method_exception = nullptr) {
  auto invoke_ident__ = invoke_ident ? _fbb.CreateString(invoke_ident) : 0;
  auto method_exception__ = method_exception ? _fbb.CreateString(method_exception) : 0;
  return noodles::CreateMethodReply(
      _fbb,
      invoke_ident__,
      method_data,
      method_exception__);
}

struct ServerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  noodles::ServerMessageType message_type() const {
    return static_cast<noodles::ServerMessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const noodles::MethodCreate *message_as_MethodCreate() const {
    return message_type() == noodles::ServerMessageType::MethodCreate ? static_cast<const noodles::MethodCreate *>(message()) : nullptr;
  }
  const noodles::MethodDelete *message_as_MethodDelete() const {
    return message_type() == noodles::ServerMessageType::MethodDelete ? static_cast<const noodles::MethodDelete *>(message()) : nullptr;
  }
  const noodles::SignalCreate *message_as_SignalCreate() const {
    return message_type() == noodles::ServerMessageType::SignalCreate ? static_cast<const noodles::SignalCreate *>(message()) : nullptr;
  }
  const noodles::SignalDelete *message_as_SignalDelete() const {
    return message_type() == noodles::ServerMessageType::SignalDelete ? static_cast<const noodles::SignalDelete *>(message()) : nullptr;
  }
  const noodles::ObjectCreateUpdate *message_as_ObjectCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::ObjectCreateUpdate ? static_cast<const noodles::ObjectCreateUpdate *>(message()) : nullptr;
  }
  const noodles::ObjectDelete *message_as_ObjectDelete() const {
    return message_type() == noodles::ServerMessageType::ObjectDelete ? static_cast<const noodles::ObjectDelete *>(message()) : nullptr;
  }
  const noodles::BufferCreate *message_as_BufferCreate() const {
    return message_type() == noodles::ServerMessageType::BufferCreate ? static_cast<const noodles::BufferCreate *>(message()) : nullptr;
  }
  const noodles::BufferDelete *message_as_BufferDelete() const {
    return message_type() == noodles::ServerMessageType::BufferDelete ? static_cast<const noodles::BufferDelete *>(message()) : nullptr;
  }
  const noodles::MaterialCreateUpdate *message_as_MaterialCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::MaterialCreateUpdate ? static_cast<const noodles::MaterialCreateUpdate *>(message()) : nullptr;
  }
  const noodles::MaterialDelete *message_as_MaterialDelete() const {
    return message_type() == noodles::ServerMessageType::MaterialDelete ? static_cast<const noodles::MaterialDelete *>(message()) : nullptr;
  }
  const noodles::TextureCreateUpdate *message_as_TextureCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TextureCreateUpdate ? static_cast<const noodles::TextureCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TextureDelete *message_as_TextureDelete() const {
    return message_type() == noodles::ServerMessageType::TextureDelete ? static_cast<const noodles::TextureDelete *>(message()) : nullptr;
  }
  const noodles::LightCreateUpdate *message_as_LightCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::LightCreateUpdate ? static_cast<const noodles::LightCreateUpdate *>(message()) : nullptr;
  }
  const noodles::LightDelete *message_as_LightDelete() const {
    return message_type() == noodles::ServerMessageType::LightDelete ? static_cast<const noodles::LightDelete *>(message()) : nullptr;
  }
  const noodles::GeometryCreate *message_as_GeometryCreate() const {
    return message_type() == noodles::ServerMessageType::GeometryCreate ? static_cast<const noodles::GeometryCreate *>(message()) : nullptr;
  }
  const noodles::GeometryDelete *message_as_GeometryDelete() const {
    return message_type() == noodles::ServerMessageType::GeometryDelete ? static_cast<const noodles::GeometryDelete *>(message()) : nullptr;
  }
  const noodles::TableCreateUpdate *message_as_TableCreateUpdate() const {
    return message_type() == noodles::ServerMessageType::TableCreateUpdate ? static_cast<const noodles::TableCreateUpdate *>(message()) : nullptr;
  }
  const noodles::TableDelete *message_as_TableDelete() const {
    return message_type() == noodles::ServerMessageType::TableDelete ? static_cast<const noodles::TableDelete *>(message()) : nullptr;
  }
  const noodles::DocumentUpdate *message_as_DocumentUpdate() const {
    return message_type() == noodles::ServerMessageType::DocumentUpdate ? static_cast<const noodles::DocumentUpdate *>(message()) : nullptr;
  }
  const noodles::DocumentReset *message_as_DocumentReset() const {
    return message_type() == noodles::ServerMessageType::DocumentReset ? static_cast<const noodles::DocumentReset *>(message()) : nullptr;
  }
  const noodles::SignalInvoke *message_as_SignalInvoke() const {
    return message_type() == noodles::ServerMessageType::SignalInvoke ? static_cast<const noodles::SignalInvoke *>(message()) : nullptr;
  }
  const noodles::MethodReply *message_as_MethodReply() const {
    return message_type() == noodles::ServerMessageType::MethodReply ? static_cast<const noodles::MethodReply *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyServerMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const noodles::MethodCreate *ServerMessage::message_as<noodles::MethodCreate>() const {
  return message_as_MethodCreate();
}

template<> inline const noodles::MethodDelete *ServerMessage::message_as<noodles::MethodDelete>() const {
  return message_as_MethodDelete();
}

template<> inline const noodles::SignalCreate *ServerMessage::message_as<noodles::SignalCreate>() const {
  return message_as_SignalCreate();
}

template<> inline const noodles::SignalDelete *ServerMessage::message_as<noodles::SignalDelete>() const {
  return message_as_SignalDelete();
}

template<> inline const noodles::ObjectCreateUpdate *ServerMessage::message_as<noodles::ObjectCreateUpdate>() const {
  return message_as_ObjectCreateUpdate();
}

template<> inline const noodles::ObjectDelete *ServerMessage::message_as<noodles::ObjectDelete>() const {
  return message_as_ObjectDelete();
}

template<> inline const noodles::BufferCreate *ServerMessage::message_as<noodles::BufferCreate>() const {
  return message_as_BufferCreate();
}

template<> inline const noodles::BufferDelete *ServerMessage::message_as<noodles::BufferDelete>() const {
  return message_as_BufferDelete();
}

template<> inline const noodles::MaterialCreateUpdate *ServerMessage::message_as<noodles::MaterialCreateUpdate>() const {
  return message_as_MaterialCreateUpdate();
}

template<> inline const noodles::MaterialDelete *ServerMessage::message_as<noodles::MaterialDelete>() const {
  return message_as_MaterialDelete();
}

template<> inline const noodles::TextureCreateUpdate *ServerMessage::message_as<noodles::TextureCreateUpdate>() const {
  return message_as_TextureCreateUpdate();
}

template<> inline const noodles::TextureDelete *ServerMessage::message_as<noodles::TextureDelete>() const {
  return message_as_TextureDelete();
}

template<> inline const noodles::LightCreateUpdate *ServerMessage::message_as<noodles::LightCreateUpdate>() const {
  return message_as_LightCreateUpdate();
}

template<> inline const noodles::LightDelete *ServerMessage::message_as<noodles::LightDelete>() const {
  return message_as_LightDelete();
}

template<> inline const noodles::GeometryCreate *ServerMessage::message_as<noodles::GeometryCreate>() const {
  return message_as_GeometryCreate();
}

template<> inline const noodles::GeometryDelete *ServerMessage::message_as<noodles::GeometryDelete>() const {
  return message_as_GeometryDelete();
}

template<> inline const noodles::TableCreateUpdate *ServerMessage::message_as<noodles::TableCreateUpdate>() const {
  return message_as_TableCreateUpdate();
}

template<> inline const noodles::TableDelete *ServerMessage::message_as<noodles::TableDelete>() const {
  return message_as_TableDelete();
}

template<> inline const noodles::DocumentUpdate *ServerMessage::message_as<noodles::DocumentUpdate>() const {
  return message_as_DocumentUpdate();
}

template<> inline const noodles::DocumentReset *ServerMessage::message_as<noodles::DocumentReset>() const {
  return message_as_DocumentReset();
}

template<> inline const noodles::SignalInvoke *ServerMessage::message_as<noodles::SignalInvoke>() const {
  return message_as_SignalInvoke();
}

template<> inline const noodles::MethodReply *ServerMessage::message_as<noodles::MethodReply>() const {
  return message_as_MethodReply();
}

struct ServerMessageBuilder {
  typedef ServerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(noodles::ServerMessageType message_type) {
    fbb_.AddElement<uint8_t>(ServerMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ServerMessage::VT_MESSAGE, message);
  }
  explicit ServerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerMessageBuilder &operator=(const ServerMessageBuilder &);
  flatbuffers::Offset<ServerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessage> CreateServerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    noodles::ServerMessageType message_type = noodles::ServerMessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  ServerMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct ServerMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerMessagesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerMessagesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *mutable_messages() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ServerMessagesBuilder {
  typedef ServerMessages Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages) {
    fbb_.AddOffset(ServerMessages::VT_MESSAGES, messages);
  }
  explicit ServerMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerMessagesBuilder &operator=(const ServerMessagesBuilder &);
  flatbuffers::Offset<ServerMessages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerMessages>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerMessages> CreateServerMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<noodles::ServerMessage>>> messages = 0) {
  ServerMessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerMessages> CreateServerMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<noodles::ServerMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<noodles::ServerMessage>>(*messages) : 0;
  return noodles::CreateServerMessages(
      _fbb,
      messages__);
}

inline bool VerifyServerMessageType(flatbuffers::Verifier &verifier, const void *obj, ServerMessageType type) {
  switch (type) {
    case ServerMessageType::NONE: {
      return true;
    }
    case ServerMessageType::MethodCreate: {
      auto ptr = reinterpret_cast<const noodles::MethodCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodDelete: {
      auto ptr = reinterpret_cast<const noodles::MethodDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalCreate: {
      auto ptr = reinterpret_cast<const noodles::SignalCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalDelete: {
      auto ptr = reinterpret_cast<const noodles::SignalDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::ObjectCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::ObjectDelete: {
      auto ptr = reinterpret_cast<const noodles::ObjectDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferCreate: {
      auto ptr = reinterpret_cast<const noodles::BufferCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::BufferDelete: {
      auto ptr = reinterpret_cast<const noodles::BufferDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::MaterialCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MaterialDelete: {
      auto ptr = reinterpret_cast<const noodles::MaterialDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TextureCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TextureDelete: {
      auto ptr = reinterpret_cast<const noodles::TextureDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::LightCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::LightDelete: {
      auto ptr = reinterpret_cast<const noodles::LightDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryCreate: {
      auto ptr = reinterpret_cast<const noodles::GeometryCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::GeometryDelete: {
      auto ptr = reinterpret_cast<const noodles::GeometryDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableCreateUpdate: {
      auto ptr = reinterpret_cast<const noodles::TableCreateUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::TableDelete: {
      auto ptr = reinterpret_cast<const noodles::TableDelete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentUpdate: {
      auto ptr = reinterpret_cast<const noodles::DocumentUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::DocumentReset: {
      auto ptr = reinterpret_cast<const noodles::DocumentReset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::SignalInvoke: {
      auto ptr = reinterpret_cast<const noodles::SignalInvoke *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerMessageType::MethodReply: {
      auto ptr = reinterpret_cast<const noodles::MethodReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerMessageType(
        verifier,  values->Get(i), types->GetEnum<ServerMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodCreateTypeTable,
    noodles::MethodDeleteTypeTable,
    noodles::SignalCreateTypeTable,
    noodles::SignalDeleteTypeTable,
    noodles::ObjectCreateUpdateTypeTable,
    noodles::ObjectDeleteTypeTable,
    noodles::BufferCreateTypeTable,
    noodles::BufferDeleteTypeTable,
    noodles::MaterialCreateUpdateTypeTable,
    noodles::MaterialDeleteTypeTable,
    noodles::TextureCreateUpdateTypeTable,
    noodles::TextureDeleteTypeTable,
    noodles::LightCreateUpdateTypeTable,
    noodles::LightDeleteTypeTable,
    noodles::GeometryCreateTypeTable,
    noodles::GeometryDeleteTypeTable,
    noodles::TableCreateUpdateTypeTable,
    noodles::TableDeleteTypeTable,
    noodles::DocumentUpdateTypeTable,
    noodles::DocumentResetTypeTable,
    noodles::SignalInvokeTypeTable,
    noodles::MethodReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "MethodCreate",
    "MethodDelete",
    "SignalCreate",
    "SignalDelete",
    "ObjectCreateUpdate",
    "ObjectDelete",
    "BufferCreate",
    "BufferDelete",
    "MaterialCreateUpdate",
    "MaterialDelete",
    "TextureCreateUpdate",
    "TextureDelete",
    "LightCreateUpdate",
    "LightDelete",
    "GeometryCreate",
    "GeometryDelete",
    "TableCreateUpdate",
    "TableDelete",
    "DocumentUpdate",
    "DocumentReset",
    "SignalInvoke",
    "MethodReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 23, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodArgTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "doc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "returnDoc",
    "argDoc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::MethodArgTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "documentation",
    "argDoc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextDefinitionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "text",
    "font",
    "height",
    "opt_width"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_SEQUENCE, 1, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_SEQUENCE, 1, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable,
    noodles::Mat4TypeTable,
    noodles::MaterialIDTypeTable,
    noodles::GeometryIDTypeTable,
    noodles::LightIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable,
    noodles::TextDefinitionTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "parent",
    "transform",
    "material",
    "mesh",
    "lights",
    "tables",
    "instances",
    "tags",
    "methods_list",
    "signals_list",
    "text"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ObjectIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "bytes",
    "url",
    "url_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BufferDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable,
    noodles::Vec4TypeTable,
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "metallic",
    "roughness",
    "use_blending",
    "texture_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaterialDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MaterialIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable,
    noodles::BufferRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "reference"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TextureDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TextureIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable,
    noodles::Vec3TypeTable
  };
  static const char * const names[] = {
    "id",
    "color",
    "intensity"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LightDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::LightIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ComponentRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::BufferIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "size",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryCreateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable,
    noodles::Vec3TypeTable,
    noodles::ComponentRefTypeTable
  };
  static const char * const names[] = {
    "id",
    "min_extent",
    "max_extent",
    "positions",
    "normals",
    "texCoords",
    "colors",
    "lines",
    "triangles"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeometryDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::GeometryIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableCreateUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable,
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "id",
    "name",
    "meta",
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TableDeleteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::TableIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentUpdateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::MethodIDTypeTable,
    noodles::SignalIDTypeTable
  };
  static const char * const names[] = {
    "methods_list",
    "signals_list"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DocumentResetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalInvokeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::SignalIDTypeTable,
    noodles::ObjectIDTypeTable,
    noodles::TableIDTypeTable,
    noodles::AnyListTypeTable
  };
  static const char * const names[] = {
    "id",
    "on_object",
    "on_table",
    "signal_data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MethodReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::AnyTypeTable
  };
  static const char * const names[] = {
    "invoke_ident",
    "method_data",
    "method_exception"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTypeTable
  };
  static const char * const names[] = {
    "message_type",
    "message"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerMessagesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    noodles::ServerMessageTypeTable
  };
  static const char * const names[] = {
    "messages"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const noodles::ServerMessages *GetServerMessages(const void *buf) {
  return flatbuffers::GetRoot<noodles::ServerMessages>(buf);
}

inline const noodles::ServerMessages *GetSizePrefixedServerMessages(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<noodles::ServerMessages>(buf);
}

inline ServerMessages *GetMutableServerMessages(void *buf) {
  return flatbuffers::GetMutableRoot<ServerMessages>(buf);
}

inline bool VerifyServerMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<noodles::ServerMessages>(nullptr);
}

inline bool VerifySizePrefixedServerMessagesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<noodles::ServerMessages>(nullptr);
}

inline void FinishServerMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ServerMessages> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedServerMessagesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<noodles::ServerMessages> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace noodles

#endif  // FLATBUFFERS_GENERATED_NOODLESSERVER_NOODLES_H_
